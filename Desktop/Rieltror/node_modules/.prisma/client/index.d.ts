
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Realtor
 * 
 */
export type Realtor = $Result.DefaultSelection<Prisma.$RealtorPayload>
/**
 * Model ObjectType
 * 
 */
export type ObjectType = $Result.DefaultSelection<Prisma.$ObjectTypePayload>
/**
 * Model ResidenceType
 * 
 */
export type ResidenceType = $Result.DefaultSelection<Prisma.$ResidenceTypePayload>
/**
 * Model ObjectCategory
 * 
 */
export type ObjectCategory = $Result.DefaultSelection<Prisma.$ObjectCategoryPayload>
/**
 * Model ObjectStatus
 * 
 */
export type ObjectStatus = $Result.DefaultSelection<Prisma.$ObjectStatusPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model Renovation
 * 
 */
export type Renovation = $Result.DefaultSelection<Prisma.$RenovationPayload>
/**
 * Model WindowSide
 * 
 */
export type WindowSide = $Result.DefaultSelection<Prisma.$WindowSidePayload>
/**
 * Model RoomType
 * 
 */
export type RoomType = $Result.DefaultSelection<Prisma.$RoomTypePayload>
/**
 * Model Object
 * 
 */
export type Object = $Result.DefaultSelection<Prisma.$ObjectPayload>
/**
 * Model OwnerShip
 * 
 */
export type OwnerShip = $Result.DefaultSelection<Prisma.$OwnerShipPayload>
/**
 * Model ReasonDeleting
 * 
 */
export type ReasonDeleting = $Result.DefaultSelection<Prisma.$ReasonDeletingPayload>
/**
 * Model OwnerCooperation
 * 
 */
export type OwnerCooperation = $Result.DefaultSelection<Prisma.$OwnerCooperationPayload>
/**
 * Model RelationshipType
 * 
 */
export type RelationshipType = $Result.DefaultSelection<Prisma.$RelationshipTypePayload>
/**
 * Model OwnerRelation
 * 
 */
export type OwnerRelation = $Result.DefaultSelection<Prisma.$OwnerRelationPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model District
 * 
 */
export type District = $Result.DefaultSelection<Prisma.$DistrictPayload>
/**
 * Model Area
 * 
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model Mahalla
 * 
 */
export type Mahalla = $Result.DefaultSelection<Prisma.$MahallaPayload>
/**
 * Model Street
 * 
 */
export type Street = $Result.DefaultSelection<Prisma.$StreetPayload>
/**
 * Model Metro
 * 
 */
export type Metro = $Result.DefaultSelection<Prisma.$MetroPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model BuildingCondition
 * 
 */
export type BuildingCondition = $Result.DefaultSelection<Prisma.$BuildingConditionPayload>
/**
 * Model BuildingSeria
 * 
 */
export type BuildingSeria = $Result.DefaultSelection<Prisma.$BuildingSeriaPayload>
/**
 * Model WallMaterial
 * 
 */
export type WallMaterial = $Result.DefaultSelection<Prisma.$WallMaterialPayload>
/**
 * Model Overlaps
 * 
 */
export type Overlaps = $Result.DefaultSelection<Prisma.$OverlapsPayload>
/**
 * Model WaterSupply
 * 
 */
export type WaterSupply = $Result.DefaultSelection<Prisma.$WaterSupplyPayload>
/**
 * Model HeatingSystem
 * 
 */
export type HeatingSystem = $Result.DefaultSelection<Prisma.$HeatingSystemPayload>
/**
 * Model Parking
 * 
 */
export type Parking = $Result.DefaultSelection<Prisma.$ParkingPayload>
/**
 * Model BuildingCharacter
 * 
 */
export type BuildingCharacter = $Result.DefaultSelection<Prisma.$BuildingCharacterPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Realtors
 * const realtors = await prisma.realtor.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Realtors
   * const realtors = await prisma.realtor.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.realtor`: Exposes CRUD operations for the **Realtor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Realtors
    * const realtors = await prisma.realtor.findMany()
    * ```
    */
  get realtor(): Prisma.RealtorDelegate<ExtArgs>;

  /**
   * `prisma.objectType`: Exposes CRUD operations for the **ObjectType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjectTypes
    * const objectTypes = await prisma.objectType.findMany()
    * ```
    */
  get objectType(): Prisma.ObjectTypeDelegate<ExtArgs>;

  /**
   * `prisma.residenceType`: Exposes CRUD operations for the **ResidenceType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResidenceTypes
    * const residenceTypes = await prisma.residenceType.findMany()
    * ```
    */
  get residenceType(): Prisma.ResidenceTypeDelegate<ExtArgs>;

  /**
   * `prisma.objectCategory`: Exposes CRUD operations for the **ObjectCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjectCategories
    * const objectCategories = await prisma.objectCategory.findMany()
    * ```
    */
  get objectCategory(): Prisma.ObjectCategoryDelegate<ExtArgs>;

  /**
   * `prisma.objectStatus`: Exposes CRUD operations for the **ObjectStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjectStatuses
    * const objectStatuses = await prisma.objectStatus.findMany()
    * ```
    */
  get objectStatus(): Prisma.ObjectStatusDelegate<ExtArgs>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs>;

  /**
   * `prisma.renovation`: Exposes CRUD operations for the **Renovation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Renovations
    * const renovations = await prisma.renovation.findMany()
    * ```
    */
  get renovation(): Prisma.RenovationDelegate<ExtArgs>;

  /**
   * `prisma.windowSide`: Exposes CRUD operations for the **WindowSide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WindowSides
    * const windowSides = await prisma.windowSide.findMany()
    * ```
    */
  get windowSide(): Prisma.WindowSideDelegate<ExtArgs>;

  /**
   * `prisma.roomType`: Exposes CRUD operations for the **RoomType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomTypes
    * const roomTypes = await prisma.roomType.findMany()
    * ```
    */
  get roomType(): Prisma.RoomTypeDelegate<ExtArgs>;

  /**
   * `prisma.object`: Exposes CRUD operations for the **Object** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objects
    * const objects = await prisma.object.findMany()
    * ```
    */
  get object(): Prisma.ObjectDelegate<ExtArgs>;

  /**
   * `prisma.ownerShip`: Exposes CRUD operations for the **OwnerShip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerShips
    * const ownerShips = await prisma.ownerShip.findMany()
    * ```
    */
  get ownerShip(): Prisma.OwnerShipDelegate<ExtArgs>;

  /**
   * `prisma.reasonDeleting`: Exposes CRUD operations for the **ReasonDeleting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReasonDeletings
    * const reasonDeletings = await prisma.reasonDeleting.findMany()
    * ```
    */
  get reasonDeleting(): Prisma.ReasonDeletingDelegate<ExtArgs>;

  /**
   * `prisma.ownerCooperation`: Exposes CRUD operations for the **OwnerCooperation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerCooperations
    * const ownerCooperations = await prisma.ownerCooperation.findMany()
    * ```
    */
  get ownerCooperation(): Prisma.OwnerCooperationDelegate<ExtArgs>;

  /**
   * `prisma.relationshipType`: Exposes CRUD operations for the **RelationshipType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelationshipTypes
    * const relationshipTypes = await prisma.relationshipType.findMany()
    * ```
    */
  get relationshipType(): Prisma.RelationshipTypeDelegate<ExtArgs>;

  /**
   * `prisma.ownerRelation`: Exposes CRUD operations for the **OwnerRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerRelations
    * const ownerRelations = await prisma.ownerRelation.findMany()
    * ```
    */
  get ownerRelation(): Prisma.OwnerRelationDelegate<ExtArgs>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs>;

  /**
   * `prisma.district`: Exposes CRUD operations for the **District** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.district.findMany()
    * ```
    */
  get district(): Prisma.DistrictDelegate<ExtArgs>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs>;

  /**
   * `prisma.mahalla`: Exposes CRUD operations for the **Mahalla** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mahallas
    * const mahallas = await prisma.mahalla.findMany()
    * ```
    */
  get mahalla(): Prisma.MahallaDelegate<ExtArgs>;

  /**
   * `prisma.street`: Exposes CRUD operations for the **Street** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Streets
    * const streets = await prisma.street.findMany()
    * ```
    */
  get street(): Prisma.StreetDelegate<ExtArgs>;

  /**
   * `prisma.metro`: Exposes CRUD operations for the **Metro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metros
    * const metros = await prisma.metro.findMany()
    * ```
    */
  get metro(): Prisma.MetroDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs>;

  /**
   * `prisma.buildingCondition`: Exposes CRUD operations for the **BuildingCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildingConditions
    * const buildingConditions = await prisma.buildingCondition.findMany()
    * ```
    */
  get buildingCondition(): Prisma.BuildingConditionDelegate<ExtArgs>;

  /**
   * `prisma.buildingSeria`: Exposes CRUD operations for the **BuildingSeria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildingSerias
    * const buildingSerias = await prisma.buildingSeria.findMany()
    * ```
    */
  get buildingSeria(): Prisma.BuildingSeriaDelegate<ExtArgs>;

  /**
   * `prisma.wallMaterial`: Exposes CRUD operations for the **WallMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WallMaterials
    * const wallMaterials = await prisma.wallMaterial.findMany()
    * ```
    */
  get wallMaterial(): Prisma.WallMaterialDelegate<ExtArgs>;

  /**
   * `prisma.overlaps`: Exposes CRUD operations for the **Overlaps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Overlaps
    * const overlaps = await prisma.overlaps.findMany()
    * ```
    */
  get overlaps(): Prisma.OverlapsDelegate<ExtArgs>;

  /**
   * `prisma.waterSupply`: Exposes CRUD operations for the **WaterSupply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WaterSupplies
    * const waterSupplies = await prisma.waterSupply.findMany()
    * ```
    */
  get waterSupply(): Prisma.WaterSupplyDelegate<ExtArgs>;

  /**
   * `prisma.heatingSystem`: Exposes CRUD operations for the **HeatingSystem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeatingSystems
    * const heatingSystems = await prisma.heatingSystem.findMany()
    * ```
    */
  get heatingSystem(): Prisma.HeatingSystemDelegate<ExtArgs>;

  /**
   * `prisma.parking`: Exposes CRUD operations for the **Parking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parkings
    * const parkings = await prisma.parking.findMany()
    * ```
    */
  get parking(): Prisma.ParkingDelegate<ExtArgs>;

  /**
   * `prisma.buildingCharacter`: Exposes CRUD operations for the **BuildingCharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildingCharacters
    * const buildingCharacters = await prisma.buildingCharacter.findMany()
    * ```
    */
  get buildingCharacter(): Prisma.BuildingCharacterDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.13.0
   * Query Engine version: b9a39a7ee606c28e3455d0fd60e78c3ba82b1a2b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Realtor: 'Realtor',
    ObjectType: 'ObjectType',
    ResidenceType: 'ResidenceType',
    ObjectCategory: 'ObjectCategory',
    ObjectStatus: 'ObjectStatus',
    Currency: 'Currency',
    Renovation: 'Renovation',
    WindowSide: 'WindowSide',
    RoomType: 'RoomType',
    Object: 'Object',
    OwnerShip: 'OwnerShip',
    ReasonDeleting: 'ReasonDeleting',
    OwnerCooperation: 'OwnerCooperation',
    RelationshipType: 'RelationshipType',
    OwnerRelation: 'OwnerRelation',
    Region: 'Region',
    District: 'District',
    Area: 'Area',
    Mahalla: 'Mahalla',
    Street: 'Street',
    Metro: 'Metro',
    Address: 'Address',
    BuildingCondition: 'BuildingCondition',
    BuildingSeria: 'BuildingSeria',
    WallMaterial: 'WallMaterial',
    Overlaps: 'Overlaps',
    WaterSupply: 'WaterSupply',
    HeatingSystem: 'HeatingSystem',
    Parking: 'Parking',
    BuildingCharacter: 'BuildingCharacter'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'realtor' | 'objectType' | 'residenceType' | 'objectCategory' | 'objectStatus' | 'currency' | 'renovation' | 'windowSide' | 'roomType' | 'object' | 'ownerShip' | 'reasonDeleting' | 'ownerCooperation' | 'relationshipType' | 'ownerRelation' | 'region' | 'district' | 'area' | 'mahalla' | 'street' | 'metro' | 'address' | 'buildingCondition' | 'buildingSeria' | 'wallMaterial' | 'overlaps' | 'waterSupply' | 'heatingSystem' | 'parking' | 'buildingCharacter'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Realtor: {
        payload: Prisma.$RealtorPayload<ExtArgs>
        fields: Prisma.RealtorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RealtorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RealtorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload>
          }
          findFirst: {
            args: Prisma.RealtorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RealtorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload>
          }
          findMany: {
            args: Prisma.RealtorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload>[]
          }
          create: {
            args: Prisma.RealtorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload>
          }
          createMany: {
            args: Prisma.RealtorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RealtorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload>
          }
          update: {
            args: Prisma.RealtorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload>
          }
          deleteMany: {
            args: Prisma.RealtorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RealtorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RealtorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RealtorPayload>
          }
          aggregate: {
            args: Prisma.RealtorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRealtor>
          }
          groupBy: {
            args: Prisma.RealtorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RealtorGroupByOutputType>[]
          }
          count: {
            args: Prisma.RealtorCountArgs<ExtArgs>,
            result: $Utils.Optional<RealtorCountAggregateOutputType> | number
          }
        }
      }
      ObjectType: {
        payload: Prisma.$ObjectTypePayload<ExtArgs>
        fields: Prisma.ObjectTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload>
          }
          findFirst: {
            args: Prisma.ObjectTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload>
          }
          findMany: {
            args: Prisma.ObjectTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload>[]
          }
          create: {
            args: Prisma.ObjectTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload>
          }
          createMany: {
            args: Prisma.ObjectTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload>
          }
          update: {
            args: Prisma.ObjectTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload>
          }
          deleteMany: {
            args: Prisma.ObjectTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectTypePayload>
          }
          aggregate: {
            args: Prisma.ObjectTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObjectType>
          }
          groupBy: {
            args: Prisma.ObjectTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectTypeCountAggregateOutputType> | number
          }
        }
      }
      ResidenceType: {
        payload: Prisma.$ResidenceTypePayload<ExtArgs>
        fields: Prisma.ResidenceTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResidenceTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResidenceTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload>
          }
          findFirst: {
            args: Prisma.ResidenceTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResidenceTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload>
          }
          findMany: {
            args: Prisma.ResidenceTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload>[]
          }
          create: {
            args: Prisma.ResidenceTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload>
          }
          createMany: {
            args: Prisma.ResidenceTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResidenceTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload>
          }
          update: {
            args: Prisma.ResidenceTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload>
          }
          deleteMany: {
            args: Prisma.ResidenceTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResidenceTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResidenceTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResidenceTypePayload>
          }
          aggregate: {
            args: Prisma.ResidenceTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResidenceType>
          }
          groupBy: {
            args: Prisma.ResidenceTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResidenceTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResidenceTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<ResidenceTypeCountAggregateOutputType> | number
          }
        }
      }
      ObjectCategory: {
        payload: Prisma.$ObjectCategoryPayload<ExtArgs>
        fields: Prisma.ObjectCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload>
          }
          findFirst: {
            args: Prisma.ObjectCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload>
          }
          findMany: {
            args: Prisma.ObjectCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload>[]
          }
          create: {
            args: Prisma.ObjectCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload>
          }
          createMany: {
            args: Prisma.ObjectCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload>
          }
          update: {
            args: Prisma.ObjectCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ObjectCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectCategoryPayload>
          }
          aggregate: {
            args: Prisma.ObjectCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObjectCategory>
          }
          groupBy: {
            args: Prisma.ObjectCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectCategoryCountAggregateOutputType> | number
          }
        }
      }
      ObjectStatus: {
        payload: Prisma.$ObjectStatusPayload<ExtArgs>
        fields: Prisma.ObjectStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload>
          }
          findFirst: {
            args: Prisma.ObjectStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload>
          }
          findMany: {
            args: Prisma.ObjectStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload>[]
          }
          create: {
            args: Prisma.ObjectStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload>
          }
          createMany: {
            args: Prisma.ObjectStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload>
          }
          update: {
            args: Prisma.ObjectStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload>
          }
          deleteMany: {
            args: Prisma.ObjectStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectStatusPayload>
          }
          aggregate: {
            args: Prisma.ObjectStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObjectStatus>
          }
          groupBy: {
            args: Prisma.ObjectStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectStatusCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>,
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      Renovation: {
        payload: Prisma.$RenovationPayload<ExtArgs>
        fields: Prisma.RenovationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RenovationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RenovationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload>
          }
          findFirst: {
            args: Prisma.RenovationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RenovationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload>
          }
          findMany: {
            args: Prisma.RenovationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload>[]
          }
          create: {
            args: Prisma.RenovationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload>
          }
          createMany: {
            args: Prisma.RenovationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RenovationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload>
          }
          update: {
            args: Prisma.RenovationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload>
          }
          deleteMany: {
            args: Prisma.RenovationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RenovationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RenovationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RenovationPayload>
          }
          aggregate: {
            args: Prisma.RenovationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRenovation>
          }
          groupBy: {
            args: Prisma.RenovationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RenovationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RenovationCountArgs<ExtArgs>,
            result: $Utils.Optional<RenovationCountAggregateOutputType> | number
          }
        }
      }
      WindowSide: {
        payload: Prisma.$WindowSidePayload<ExtArgs>
        fields: Prisma.WindowSideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WindowSideFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WindowSideFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload>
          }
          findFirst: {
            args: Prisma.WindowSideFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WindowSideFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload>
          }
          findMany: {
            args: Prisma.WindowSideFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload>[]
          }
          create: {
            args: Prisma.WindowSideCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload>
          }
          createMany: {
            args: Prisma.WindowSideCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WindowSideDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload>
          }
          update: {
            args: Prisma.WindowSideUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload>
          }
          deleteMany: {
            args: Prisma.WindowSideDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WindowSideUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WindowSideUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WindowSidePayload>
          }
          aggregate: {
            args: Prisma.WindowSideAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWindowSide>
          }
          groupBy: {
            args: Prisma.WindowSideGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WindowSideGroupByOutputType>[]
          }
          count: {
            args: Prisma.WindowSideCountArgs<ExtArgs>,
            result: $Utils.Optional<WindowSideCountAggregateOutputType> | number
          }
        }
      }
      RoomType: {
        payload: Prisma.$RoomTypePayload<ExtArgs>
        fields: Prisma.RoomTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          findFirst: {
            args: Prisma.RoomTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          findMany: {
            args: Prisma.RoomTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>[]
          }
          create: {
            args: Prisma.RoomTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          createMany: {
            args: Prisma.RoomTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          update: {
            args: Prisma.RoomTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          deleteMany: {
            args: Prisma.RoomTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          aggregate: {
            args: Prisma.RoomTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomType>
          }
          groupBy: {
            args: Prisma.RoomTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomTypeCountAggregateOutputType> | number
          }
        }
      }
      Object: {
        payload: Prisma.$ObjectPayload<ExtArgs>
        fields: Prisma.ObjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          findFirst: {
            args: Prisma.ObjectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          findMany: {
            args: Prisma.ObjectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>[]
          }
          create: {
            args: Prisma.ObjectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          createMany: {
            args: Prisma.ObjectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObjectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          update: {
            args: Prisma.ObjectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          deleteMany: {
            args: Prisma.ObjectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObjectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ObjectPayload>
          }
          aggregate: {
            args: Prisma.ObjectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObject>
          }
          groupBy: {
            args: Prisma.ObjectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectCountArgs<ExtArgs>,
            result: $Utils.Optional<ObjectCountAggregateOutputType> | number
          }
        }
      }
      OwnerShip: {
        payload: Prisma.$OwnerShipPayload<ExtArgs>
        fields: Prisma.OwnerShipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerShipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerShipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload>
          }
          findFirst: {
            args: Prisma.OwnerShipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerShipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload>
          }
          findMany: {
            args: Prisma.OwnerShipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload>[]
          }
          create: {
            args: Prisma.OwnerShipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload>
          }
          createMany: {
            args: Prisma.OwnerShipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OwnerShipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload>
          }
          update: {
            args: Prisma.OwnerShipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload>
          }
          deleteMany: {
            args: Prisma.OwnerShipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerShipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OwnerShipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerShipPayload>
          }
          aggregate: {
            args: Prisma.OwnerShipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOwnerShip>
          }
          groupBy: {
            args: Prisma.OwnerShipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OwnerShipGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerShipCountArgs<ExtArgs>,
            result: $Utils.Optional<OwnerShipCountAggregateOutputType> | number
          }
        }
      }
      ReasonDeleting: {
        payload: Prisma.$ReasonDeletingPayload<ExtArgs>
        fields: Prisma.ReasonDeletingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReasonDeletingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReasonDeletingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload>
          }
          findFirst: {
            args: Prisma.ReasonDeletingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReasonDeletingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload>
          }
          findMany: {
            args: Prisma.ReasonDeletingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload>[]
          }
          create: {
            args: Prisma.ReasonDeletingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload>
          }
          createMany: {
            args: Prisma.ReasonDeletingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReasonDeletingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload>
          }
          update: {
            args: Prisma.ReasonDeletingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload>
          }
          deleteMany: {
            args: Prisma.ReasonDeletingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReasonDeletingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReasonDeletingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReasonDeletingPayload>
          }
          aggregate: {
            args: Prisma.ReasonDeletingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReasonDeleting>
          }
          groupBy: {
            args: Prisma.ReasonDeletingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReasonDeletingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReasonDeletingCountArgs<ExtArgs>,
            result: $Utils.Optional<ReasonDeletingCountAggregateOutputType> | number
          }
        }
      }
      OwnerCooperation: {
        payload: Prisma.$OwnerCooperationPayload<ExtArgs>
        fields: Prisma.OwnerCooperationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerCooperationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerCooperationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload>
          }
          findFirst: {
            args: Prisma.OwnerCooperationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerCooperationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload>
          }
          findMany: {
            args: Prisma.OwnerCooperationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload>[]
          }
          create: {
            args: Prisma.OwnerCooperationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload>
          }
          createMany: {
            args: Prisma.OwnerCooperationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OwnerCooperationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload>
          }
          update: {
            args: Prisma.OwnerCooperationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload>
          }
          deleteMany: {
            args: Prisma.OwnerCooperationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerCooperationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OwnerCooperationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerCooperationPayload>
          }
          aggregate: {
            args: Prisma.OwnerCooperationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOwnerCooperation>
          }
          groupBy: {
            args: Prisma.OwnerCooperationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OwnerCooperationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerCooperationCountArgs<ExtArgs>,
            result: $Utils.Optional<OwnerCooperationCountAggregateOutputType> | number
          }
        }
      }
      RelationshipType: {
        payload: Prisma.$RelationshipTypePayload<ExtArgs>
        fields: Prisma.RelationshipTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationshipTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationshipTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload>
          }
          findFirst: {
            args: Prisma.RelationshipTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationshipTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload>
          }
          findMany: {
            args: Prisma.RelationshipTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload>[]
          }
          create: {
            args: Prisma.RelationshipTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload>
          }
          createMany: {
            args: Prisma.RelationshipTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RelationshipTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload>
          }
          update: {
            args: Prisma.RelationshipTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload>
          }
          deleteMany: {
            args: Prisma.RelationshipTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RelationshipTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RelationshipTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RelationshipTypePayload>
          }
          aggregate: {
            args: Prisma.RelationshipTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRelationshipType>
          }
          groupBy: {
            args: Prisma.RelationshipTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RelationshipTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationshipTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<RelationshipTypeCountAggregateOutputType> | number
          }
        }
      }
      OwnerRelation: {
        payload: Prisma.$OwnerRelationPayload<ExtArgs>
        fields: Prisma.OwnerRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerRelationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerRelationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload>
          }
          findFirst: {
            args: Prisma.OwnerRelationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerRelationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload>
          }
          findMany: {
            args: Prisma.OwnerRelationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload>[]
          }
          create: {
            args: Prisma.OwnerRelationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload>
          }
          createMany: {
            args: Prisma.OwnerRelationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OwnerRelationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload>
          }
          update: {
            args: Prisma.OwnerRelationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload>
          }
          deleteMany: {
            args: Prisma.OwnerRelationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerRelationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OwnerRelationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OwnerRelationPayload>
          }
          aggregate: {
            args: Prisma.OwnerRelationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOwnerRelation>
          }
          groupBy: {
            args: Prisma.OwnerRelationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OwnerRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerRelationCountArgs<ExtArgs>,
            result: $Utils.Optional<OwnerRelationCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>,
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      District: {
        payload: Prisma.$DistrictPayload<ExtArgs>
        fields: Prisma.DistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistrictFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistrictFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findFirst: {
            args: Prisma.DistrictFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistrictFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findMany: {
            args: Prisma.DistrictFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          create: {
            args: Prisma.DistrictCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          createMany: {
            args: Prisma.DistrictCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DistrictDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          update: {
            args: Prisma.DistrictUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          deleteMany: {
            args: Prisma.DistrictDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DistrictUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DistrictUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          aggregate: {
            args: Prisma.DistrictAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDistrict>
          }
          groupBy: {
            args: Prisma.DistrictGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistrictCountArgs<ExtArgs>,
            result: $Utils.Optional<DistrictCountAggregateOutputType> | number
          }
        }
      }
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>,
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      Mahalla: {
        payload: Prisma.$MahallaPayload<ExtArgs>
        fields: Prisma.MahallaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MahallaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MahallaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload>
          }
          findFirst: {
            args: Prisma.MahallaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MahallaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload>
          }
          findMany: {
            args: Prisma.MahallaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload>[]
          }
          create: {
            args: Prisma.MahallaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload>
          }
          createMany: {
            args: Prisma.MahallaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MahallaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload>
          }
          update: {
            args: Prisma.MahallaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload>
          }
          deleteMany: {
            args: Prisma.MahallaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MahallaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MahallaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MahallaPayload>
          }
          aggregate: {
            args: Prisma.MahallaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMahalla>
          }
          groupBy: {
            args: Prisma.MahallaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MahallaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MahallaCountArgs<ExtArgs>,
            result: $Utils.Optional<MahallaCountAggregateOutputType> | number
          }
        }
      }
      Street: {
        payload: Prisma.$StreetPayload<ExtArgs>
        fields: Prisma.StreetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload>
          }
          findFirst: {
            args: Prisma.StreetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload>
          }
          findMany: {
            args: Prisma.StreetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload>[]
          }
          create: {
            args: Prisma.StreetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload>
          }
          createMany: {
            args: Prisma.StreetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StreetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload>
          }
          update: {
            args: Prisma.StreetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload>
          }
          deleteMany: {
            args: Prisma.StreetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StreetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StreetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StreetPayload>
          }
          aggregate: {
            args: Prisma.StreetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStreet>
          }
          groupBy: {
            args: Prisma.StreetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StreetGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreetCountArgs<ExtArgs>,
            result: $Utils.Optional<StreetCountAggregateOutputType> | number
          }
        }
      }
      Metro: {
        payload: Prisma.$MetroPayload<ExtArgs>
        fields: Prisma.MetroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetroFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetroFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload>
          }
          findFirst: {
            args: Prisma.MetroFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetroFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload>
          }
          findMany: {
            args: Prisma.MetroFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload>[]
          }
          create: {
            args: Prisma.MetroCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload>
          }
          createMany: {
            args: Prisma.MetroCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MetroDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload>
          }
          update: {
            args: Prisma.MetroUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload>
          }
          deleteMany: {
            args: Prisma.MetroDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MetroUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MetroUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MetroPayload>
          }
          aggregate: {
            args: Prisma.MetroAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMetro>
          }
          groupBy: {
            args: Prisma.MetroGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MetroGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetroCountArgs<ExtArgs>,
            result: $Utils.Optional<MetroCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      BuildingCondition: {
        payload: Prisma.$BuildingConditionPayload<ExtArgs>
        fields: Prisma.BuildingConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingConditionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingConditionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload>
          }
          findFirst: {
            args: Prisma.BuildingConditionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingConditionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload>
          }
          findMany: {
            args: Prisma.BuildingConditionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload>[]
          }
          create: {
            args: Prisma.BuildingConditionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload>
          }
          createMany: {
            args: Prisma.BuildingConditionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildingConditionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload>
          }
          update: {
            args: Prisma.BuildingConditionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload>
          }
          deleteMany: {
            args: Prisma.BuildingConditionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingConditionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildingConditionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingConditionPayload>
          }
          aggregate: {
            args: Prisma.BuildingConditionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuildingCondition>
          }
          groupBy: {
            args: Prisma.BuildingConditionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildingConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingConditionCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildingConditionCountAggregateOutputType> | number
          }
        }
      }
      BuildingSeria: {
        payload: Prisma.$BuildingSeriaPayload<ExtArgs>
        fields: Prisma.BuildingSeriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingSeriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingSeriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload>
          }
          findFirst: {
            args: Prisma.BuildingSeriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingSeriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload>
          }
          findMany: {
            args: Prisma.BuildingSeriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload>[]
          }
          create: {
            args: Prisma.BuildingSeriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload>
          }
          createMany: {
            args: Prisma.BuildingSeriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildingSeriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload>
          }
          update: {
            args: Prisma.BuildingSeriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload>
          }
          deleteMany: {
            args: Prisma.BuildingSeriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingSeriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildingSeriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingSeriaPayload>
          }
          aggregate: {
            args: Prisma.BuildingSeriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuildingSeria>
          }
          groupBy: {
            args: Prisma.BuildingSeriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildingSeriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingSeriaCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildingSeriaCountAggregateOutputType> | number
          }
        }
      }
      WallMaterial: {
        payload: Prisma.$WallMaterialPayload<ExtArgs>
        fields: Prisma.WallMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WallMaterialFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WallMaterialFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload>
          }
          findFirst: {
            args: Prisma.WallMaterialFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WallMaterialFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload>
          }
          findMany: {
            args: Prisma.WallMaterialFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload>[]
          }
          create: {
            args: Prisma.WallMaterialCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload>
          }
          createMany: {
            args: Prisma.WallMaterialCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WallMaterialDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload>
          }
          update: {
            args: Prisma.WallMaterialUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload>
          }
          deleteMany: {
            args: Prisma.WallMaterialDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WallMaterialUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WallMaterialUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WallMaterialPayload>
          }
          aggregate: {
            args: Prisma.WallMaterialAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWallMaterial>
          }
          groupBy: {
            args: Prisma.WallMaterialGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WallMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.WallMaterialCountArgs<ExtArgs>,
            result: $Utils.Optional<WallMaterialCountAggregateOutputType> | number
          }
        }
      }
      Overlaps: {
        payload: Prisma.$OverlapsPayload<ExtArgs>
        fields: Prisma.OverlapsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OverlapsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OverlapsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload>
          }
          findFirst: {
            args: Prisma.OverlapsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OverlapsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload>
          }
          findMany: {
            args: Prisma.OverlapsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload>[]
          }
          create: {
            args: Prisma.OverlapsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload>
          }
          createMany: {
            args: Prisma.OverlapsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OverlapsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload>
          }
          update: {
            args: Prisma.OverlapsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload>
          }
          deleteMany: {
            args: Prisma.OverlapsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OverlapsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OverlapsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OverlapsPayload>
          }
          aggregate: {
            args: Prisma.OverlapsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOverlaps>
          }
          groupBy: {
            args: Prisma.OverlapsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OverlapsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OverlapsCountArgs<ExtArgs>,
            result: $Utils.Optional<OverlapsCountAggregateOutputType> | number
          }
        }
      }
      WaterSupply: {
        payload: Prisma.$WaterSupplyPayload<ExtArgs>
        fields: Prisma.WaterSupplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WaterSupplyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WaterSupplyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload>
          }
          findFirst: {
            args: Prisma.WaterSupplyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WaterSupplyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload>
          }
          findMany: {
            args: Prisma.WaterSupplyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload>[]
          }
          create: {
            args: Prisma.WaterSupplyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload>
          }
          createMany: {
            args: Prisma.WaterSupplyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WaterSupplyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload>
          }
          update: {
            args: Prisma.WaterSupplyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload>
          }
          deleteMany: {
            args: Prisma.WaterSupplyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WaterSupplyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WaterSupplyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WaterSupplyPayload>
          }
          aggregate: {
            args: Prisma.WaterSupplyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWaterSupply>
          }
          groupBy: {
            args: Prisma.WaterSupplyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WaterSupplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.WaterSupplyCountArgs<ExtArgs>,
            result: $Utils.Optional<WaterSupplyCountAggregateOutputType> | number
          }
        }
      }
      HeatingSystem: {
        payload: Prisma.$HeatingSystemPayload<ExtArgs>
        fields: Prisma.HeatingSystemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeatingSystemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeatingSystemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload>
          }
          findFirst: {
            args: Prisma.HeatingSystemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeatingSystemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload>
          }
          findMany: {
            args: Prisma.HeatingSystemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload>[]
          }
          create: {
            args: Prisma.HeatingSystemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload>
          }
          createMany: {
            args: Prisma.HeatingSystemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HeatingSystemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload>
          }
          update: {
            args: Prisma.HeatingSystemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload>
          }
          deleteMany: {
            args: Prisma.HeatingSystemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HeatingSystemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HeatingSystemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HeatingSystemPayload>
          }
          aggregate: {
            args: Prisma.HeatingSystemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHeatingSystem>
          }
          groupBy: {
            args: Prisma.HeatingSystemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HeatingSystemGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeatingSystemCountArgs<ExtArgs>,
            result: $Utils.Optional<HeatingSystemCountAggregateOutputType> | number
          }
        }
      }
      Parking: {
        payload: Prisma.$ParkingPayload<ExtArgs>
        fields: Prisma.ParkingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          findFirst: {
            args: Prisma.ParkingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          findMany: {
            args: Prisma.ParkingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>[]
          }
          create: {
            args: Prisma.ParkingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          createMany: {
            args: Prisma.ParkingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ParkingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          update: {
            args: Prisma.ParkingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          deleteMany: {
            args: Prisma.ParkingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ParkingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          aggregate: {
            args: Prisma.ParkingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParking>
          }
          groupBy: {
            args: Prisma.ParkingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParkingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingCountArgs<ExtArgs>,
            result: $Utils.Optional<ParkingCountAggregateOutputType> | number
          }
        }
      }
      BuildingCharacter: {
        payload: Prisma.$BuildingCharacterPayload<ExtArgs>
        fields: Prisma.BuildingCharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingCharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingCharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload>
          }
          findFirst: {
            args: Prisma.BuildingCharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingCharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload>
          }
          findMany: {
            args: Prisma.BuildingCharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload>[]
          }
          create: {
            args: Prisma.BuildingCharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload>
          }
          createMany: {
            args: Prisma.BuildingCharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildingCharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload>
          }
          update: {
            args: Prisma.BuildingCharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload>
          }
          deleteMany: {
            args: Prisma.BuildingCharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingCharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildingCharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingCharacterPayload>
          }
          aggregate: {
            args: Prisma.BuildingCharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuildingCharacter>
          }
          groupBy: {
            args: Prisma.BuildingCharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildingCharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingCharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildingCharacterCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RealtorCountOutputType
   */

  export type RealtorCountOutputType = {
    object: number
  }

  export type RealtorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | RealtorCountOutputTypeCountObjectArgs
  }

  // Custom InputTypes
  /**
   * RealtorCountOutputType without action
   */
  export type RealtorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealtorCountOutputType
     */
    select?: RealtorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RealtorCountOutputType without action
   */
  export type RealtorCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * Count Type ObjectTypeCountOutputType
   */

  export type ObjectTypeCountOutputType = {
    object: number
    residenceType: number
  }

  export type ObjectTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectTypeCountOutputTypeCountObjectArgs
    residenceType?: boolean | ObjectTypeCountOutputTypeCountResidenceTypeArgs
  }

  // Custom InputTypes
  /**
   * ObjectTypeCountOutputType without action
   */
  export type ObjectTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectTypeCountOutputType
     */
    select?: ObjectTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObjectTypeCountOutputType without action
   */
  export type ObjectTypeCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }

  /**
   * ObjectTypeCountOutputType without action
   */
  export type ObjectTypeCountOutputTypeCountResidenceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidenceTypeWhereInput
  }


  /**
   * Count Type ResidenceTypeCountOutputType
   */

  export type ResidenceTypeCountOutputType = {
    object: number
  }

  export type ResidenceTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ResidenceTypeCountOutputTypeCountObjectArgs
  }

  // Custom InputTypes
  /**
   * ResidenceTypeCountOutputType without action
   */
  export type ResidenceTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceTypeCountOutputType
     */
    select?: ResidenceTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResidenceTypeCountOutputType without action
   */
  export type ResidenceTypeCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * Count Type ObjectCategoryCountOutputType
   */

  export type ObjectCategoryCountOutputType = {
    object: number
  }

  export type ObjectCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectCategoryCountOutputTypeCountObjectArgs
  }

  // Custom InputTypes
  /**
   * ObjectCategoryCountOutputType without action
   */
  export type ObjectCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategoryCountOutputType
     */
    select?: ObjectCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObjectCategoryCountOutputType without action
   */
  export type ObjectCategoryCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * Count Type ObjectStatusCountOutputType
   */

  export type ObjectStatusCountOutputType = {
    object: number
  }

  export type ObjectStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectStatusCountOutputTypeCountObjectArgs
  }

  // Custom InputTypes
  /**
   * ObjectStatusCountOutputType without action
   */
  export type ObjectStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatusCountOutputType
     */
    select?: ObjectStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObjectStatusCountOutputType without action
   */
  export type ObjectStatusCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    object: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | CurrencyCountOutputTypeCountObjectArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * Count Type RenovationCountOutputType
   */

  export type RenovationCountOutputType = {
    object: number
  }

  export type RenovationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | RenovationCountOutputTypeCountObjectArgs
  }

  // Custom InputTypes
  /**
   * RenovationCountOutputType without action
   */
  export type RenovationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RenovationCountOutputType
     */
    select?: RenovationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RenovationCountOutputType without action
   */
  export type RenovationCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * Count Type WindowSideCountOutputType
   */

  export type WindowSideCountOutputType = {
    object: number
  }

  export type WindowSideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | WindowSideCountOutputTypeCountObjectArgs
  }

  // Custom InputTypes
  /**
   * WindowSideCountOutputType without action
   */
  export type WindowSideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSideCountOutputType
     */
    select?: WindowSideCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WindowSideCountOutputType without action
   */
  export type WindowSideCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * Count Type RoomTypeCountOutputType
   */

  export type RoomTypeCountOutputType = {
    object: number
  }

  export type RoomTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | RoomTypeCountOutputTypeCountObjectArgs
  }

  // Custom InputTypes
  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeCountOutputType
     */
    select?: RoomTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
  }


  /**
   * Count Type OwnerShipCountOutputType
   */

  export type OwnerShipCountOutputType = {
    ownerRelation: number
  }

  export type OwnerShipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerRelation?: boolean | OwnerShipCountOutputTypeCountOwnerRelationArgs
  }

  // Custom InputTypes
  /**
   * OwnerShipCountOutputType without action
   */
  export type OwnerShipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShipCountOutputType
     */
    select?: OwnerShipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OwnerShipCountOutputType without action
   */
  export type OwnerShipCountOutputTypeCountOwnerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerRelationWhereInput
  }


  /**
   * Count Type ReasonDeletingCountOutputType
   */

  export type ReasonDeletingCountOutputType = {
    ownerRelation: number
  }

  export type ReasonDeletingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerRelation?: boolean | ReasonDeletingCountOutputTypeCountOwnerRelationArgs
  }

  // Custom InputTypes
  /**
   * ReasonDeletingCountOutputType without action
   */
  export type ReasonDeletingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeletingCountOutputType
     */
    select?: ReasonDeletingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReasonDeletingCountOutputType without action
   */
  export type ReasonDeletingCountOutputTypeCountOwnerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerRelationWhereInput
  }


  /**
   * Count Type OwnerCooperationCountOutputType
   */

  export type OwnerCooperationCountOutputType = {
    ownerRelation: number
  }

  export type OwnerCooperationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerRelation?: boolean | OwnerCooperationCountOutputTypeCountOwnerRelationArgs
  }

  // Custom InputTypes
  /**
   * OwnerCooperationCountOutputType without action
   */
  export type OwnerCooperationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperationCountOutputType
     */
    select?: OwnerCooperationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OwnerCooperationCountOutputType without action
   */
  export type OwnerCooperationCountOutputTypeCountOwnerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerRelationWhereInput
  }


  /**
   * Count Type RelationshipTypeCountOutputType
   */

  export type RelationshipTypeCountOutputType = {
    ownerRelation: number
  }

  export type RelationshipTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerRelation?: boolean | RelationshipTypeCountOutputTypeCountOwnerRelationArgs
  }

  // Custom InputTypes
  /**
   * RelationshipTypeCountOutputType without action
   */
  export type RelationshipTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipTypeCountOutputType
     */
    select?: RelationshipTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RelationshipTypeCountOutputType without action
   */
  export type RelationshipTypeCountOutputTypeCountOwnerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerRelationWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    address: number
    district: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | RegionCountOutputTypeCountAddressArgs
    district?: boolean | RegionCountOutputTypeCountDistrictArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountDistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
  }


  /**
   * Count Type DistrictCountOutputType
   */

  export type DistrictCountOutputType = {
    address: number
  }

  export type DistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | DistrictCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes
  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictCountOutputType
     */
    select?: DistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    address: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AreaCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type MahallaCountOutputType
   */

  export type MahallaCountOutputType = {
    address: number
  }

  export type MahallaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | MahallaCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes
  /**
   * MahallaCountOutputType without action
   */
  export type MahallaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahallaCountOutputType
     */
    select?: MahallaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MahallaCountOutputType without action
   */
  export type MahallaCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type StreetCountOutputType
   */

  export type StreetCountOutputType = {
    address: number
  }

  export type StreetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | StreetCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes
  /**
   * StreetCountOutputType without action
   */
  export type StreetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreetCountOutputType
     */
    select?: StreetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StreetCountOutputType without action
   */
  export type StreetCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type MetroCountOutputType
   */

  export type MetroCountOutputType = {
    address: number
  }

  export type MetroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | MetroCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes
  /**
   * MetroCountOutputType without action
   */
  export type MetroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetroCountOutputType
     */
    select?: MetroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MetroCountOutputType without action
   */
  export type MetroCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type BuildingConditionCountOutputType
   */

  export type BuildingConditionCountOutputType = {
    buildingCharacter: number
  }

  export type BuildingConditionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | BuildingConditionCountOutputTypeCountBuildingCharacterArgs
  }

  // Custom InputTypes
  /**
   * BuildingConditionCountOutputType without action
   */
  export type BuildingConditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingConditionCountOutputType
     */
    select?: BuildingConditionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingConditionCountOutputType without action
   */
  export type BuildingConditionCountOutputTypeCountBuildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingCharacterWhereInput
  }


  /**
   * Count Type BuildingSeriaCountOutputType
   */

  export type BuildingSeriaCountOutputType = {
    buildingCharacter: number
  }

  export type BuildingSeriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | BuildingSeriaCountOutputTypeCountBuildingCharacterArgs
  }

  // Custom InputTypes
  /**
   * BuildingSeriaCountOutputType without action
   */
  export type BuildingSeriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeriaCountOutputType
     */
    select?: BuildingSeriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingSeriaCountOutputType without action
   */
  export type BuildingSeriaCountOutputTypeCountBuildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingCharacterWhereInput
  }


  /**
   * Count Type WallMaterialCountOutputType
   */

  export type WallMaterialCountOutputType = {
    buildingCharacter: number
  }

  export type WallMaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | WallMaterialCountOutputTypeCountBuildingCharacterArgs
  }

  // Custom InputTypes
  /**
   * WallMaterialCountOutputType without action
   */
  export type WallMaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterialCountOutputType
     */
    select?: WallMaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WallMaterialCountOutputType without action
   */
  export type WallMaterialCountOutputTypeCountBuildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingCharacterWhereInput
  }


  /**
   * Count Type OverlapsCountOutputType
   */

  export type OverlapsCountOutputType = {
    buildingCharacter: number
  }

  export type OverlapsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | OverlapsCountOutputTypeCountBuildingCharacterArgs
  }

  // Custom InputTypes
  /**
   * OverlapsCountOutputType without action
   */
  export type OverlapsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverlapsCountOutputType
     */
    select?: OverlapsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OverlapsCountOutputType without action
   */
  export type OverlapsCountOutputTypeCountBuildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingCharacterWhereInput
  }


  /**
   * Count Type WaterSupplyCountOutputType
   */

  export type WaterSupplyCountOutputType = {
    buildingCharacter: number
  }

  export type WaterSupplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | WaterSupplyCountOutputTypeCountBuildingCharacterArgs
  }

  // Custom InputTypes
  /**
   * WaterSupplyCountOutputType without action
   */
  export type WaterSupplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupplyCountOutputType
     */
    select?: WaterSupplyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WaterSupplyCountOutputType without action
   */
  export type WaterSupplyCountOutputTypeCountBuildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingCharacterWhereInput
  }


  /**
   * Count Type HeatingSystemCountOutputType
   */

  export type HeatingSystemCountOutputType = {
    buildingCharacter: number
  }

  export type HeatingSystemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | HeatingSystemCountOutputTypeCountBuildingCharacterArgs
  }

  // Custom InputTypes
  /**
   * HeatingSystemCountOutputType without action
   */
  export type HeatingSystemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystemCountOutputType
     */
    select?: HeatingSystemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HeatingSystemCountOutputType without action
   */
  export type HeatingSystemCountOutputTypeCountBuildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingCharacterWhereInput
  }


  /**
   * Count Type ParkingCountOutputType
   */

  export type ParkingCountOutputType = {
    buildingCharacter: number
  }

  export type ParkingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | ParkingCountOutputTypeCountBuildingCharacterArgs
  }

  // Custom InputTypes
  /**
   * ParkingCountOutputType without action
   */
  export type ParkingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkingCountOutputType
     */
    select?: ParkingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParkingCountOutputType without action
   */
  export type ParkingCountOutputTypeCountBuildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingCharacterWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Realtor
   */

  export type AggregateRealtor = {
    _count: RealtorCountAggregateOutputType | null
    _avg: RealtorAvgAggregateOutputType | null
    _sum: RealtorSumAggregateOutputType | null
    _min: RealtorMinAggregateOutputType | null
    _max: RealtorMaxAggregateOutputType | null
  }

  export type RealtorAvgAggregateOutputType = {
    id: number | null
  }

  export type RealtorSumAggregateOutputType = {
    id: number | null
  }

  export type RealtorMinAggregateOutputType = {
    id: number | null
    name: string | null
    is_active: boolean | null
    reg_date: Date | null
    deactivate_date: Date | null
    photo: string | null
    login: string | null
    password: string | null
  }

  export type RealtorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    is_active: boolean | null
    reg_date: Date | null
    deactivate_date: Date | null
    photo: string | null
    login: string | null
    password: string | null
  }

  export type RealtorCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    reg_date: number
    deactivate_date: number
    photo: number
    login: number
    password: number
    _all: number
  }


  export type RealtorAvgAggregateInputType = {
    id?: true
  }

  export type RealtorSumAggregateInputType = {
    id?: true
  }

  export type RealtorMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    reg_date?: true
    deactivate_date?: true
    photo?: true
    login?: true
    password?: true
  }

  export type RealtorMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    reg_date?: true
    deactivate_date?: true
    photo?: true
    login?: true
    password?: true
  }

  export type RealtorCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    reg_date?: true
    deactivate_date?: true
    photo?: true
    login?: true
    password?: true
    _all?: true
  }

  export type RealtorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Realtor to aggregate.
     */
    where?: RealtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Realtors to fetch.
     */
    orderBy?: RealtorOrderByWithRelationInput | RealtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Realtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Realtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Realtors
    **/
    _count?: true | RealtorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RealtorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RealtorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealtorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealtorMaxAggregateInputType
  }

  export type GetRealtorAggregateType<T extends RealtorAggregateArgs> = {
        [P in keyof T & keyof AggregateRealtor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealtor[P]>
      : GetScalarType<T[P], AggregateRealtor[P]>
  }




  export type RealtorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealtorWhereInput
    orderBy?: RealtorOrderByWithAggregationInput | RealtorOrderByWithAggregationInput[]
    by: RealtorScalarFieldEnum[] | RealtorScalarFieldEnum
    having?: RealtorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealtorCountAggregateInputType | true
    _avg?: RealtorAvgAggregateInputType
    _sum?: RealtorSumAggregateInputType
    _min?: RealtorMinAggregateInputType
    _max?: RealtorMaxAggregateInputType
  }

  export type RealtorGroupByOutputType = {
    id: number
    name: string
    is_active: boolean
    reg_date: Date
    deactivate_date: Date
    photo: string
    login: string
    password: string
    _count: RealtorCountAggregateOutputType | null
    _avg: RealtorAvgAggregateOutputType | null
    _sum: RealtorSumAggregateOutputType | null
    _min: RealtorMinAggregateOutputType | null
    _max: RealtorMaxAggregateOutputType | null
  }

  type GetRealtorGroupByPayload<T extends RealtorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RealtorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealtorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealtorGroupByOutputType[P]>
            : GetScalarType<T[P], RealtorGroupByOutputType[P]>
        }
      >
    >


  export type RealtorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    reg_date?: boolean
    deactivate_date?: boolean
    photo?: boolean
    login?: boolean
    password?: boolean
    object?: boolean | Realtor$objectArgs<ExtArgs>
    _count?: boolean | RealtorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["realtor"]>

  export type RealtorSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    reg_date?: boolean
    deactivate_date?: boolean
    photo?: boolean
    login?: boolean
    password?: boolean
  }


  export type RealtorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | Realtor$objectArgs<ExtArgs>
    _count?: boolean | RealtorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RealtorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Realtor"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      is_active: boolean
      reg_date: Date
      deactivate_date: Date
      photo: string
      login: string
      password: string
    }, ExtArgs["result"]["realtor"]>
    composites: {}
  }


  type RealtorGetPayload<S extends boolean | null | undefined | RealtorDefaultArgs> = $Result.GetResult<Prisma.$RealtorPayload, S>

  type RealtorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RealtorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RealtorCountAggregateInputType | true
    }

  export interface RealtorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Realtor'], meta: { name: 'Realtor' } }
    /**
     * Find zero or one Realtor that matches the filter.
     * @param {RealtorFindUniqueArgs} args - Arguments to find a Realtor
     * @example
     * // Get one Realtor
     * const realtor = await prisma.realtor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealtorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RealtorFindUniqueArgs<ExtArgs>>
    ): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Realtor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RealtorFindUniqueOrThrowArgs} args - Arguments to find a Realtor
     * @example
     * // Get one Realtor
     * const realtor = await prisma.realtor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealtorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealtorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Realtor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealtorFindFirstArgs} args - Arguments to find a Realtor
     * @example
     * // Get one Realtor
     * const realtor = await prisma.realtor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealtorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RealtorFindFirstArgs<ExtArgs>>
    ): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Realtor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealtorFindFirstOrThrowArgs} args - Arguments to find a Realtor
     * @example
     * // Get one Realtor
     * const realtor = await prisma.realtor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealtorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RealtorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Realtors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealtorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Realtors
     * const realtors = await prisma.realtor.findMany()
     * 
     * // Get first 10 Realtors
     * const realtors = await prisma.realtor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realtorWithIdOnly = await prisma.realtor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealtorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealtorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Realtor.
     * @param {RealtorCreateArgs} args - Arguments to create a Realtor.
     * @example
     * // Create one Realtor
     * const Realtor = await prisma.realtor.create({
     *   data: {
     *     // ... data to create a Realtor
     *   }
     * })
     * 
    **/
    create<T extends RealtorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RealtorCreateArgs<ExtArgs>>
    ): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Realtors.
     *     @param {RealtorCreateManyArgs} args - Arguments to create many Realtors.
     *     @example
     *     // Create many Realtors
     *     const realtor = await prisma.realtor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RealtorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealtorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Realtor.
     * @param {RealtorDeleteArgs} args - Arguments to delete one Realtor.
     * @example
     * // Delete one Realtor
     * const Realtor = await prisma.realtor.delete({
     *   where: {
     *     // ... filter to delete one Realtor
     *   }
     * })
     * 
    **/
    delete<T extends RealtorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RealtorDeleteArgs<ExtArgs>>
    ): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Realtor.
     * @param {RealtorUpdateArgs} args - Arguments to update one Realtor.
     * @example
     * // Update one Realtor
     * const realtor = await prisma.realtor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealtorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RealtorUpdateArgs<ExtArgs>>
    ): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Realtors.
     * @param {RealtorDeleteManyArgs} args - Arguments to filter Realtors to delete.
     * @example
     * // Delete a few Realtors
     * const { count } = await prisma.realtor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealtorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RealtorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Realtors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealtorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Realtors
     * const realtor = await prisma.realtor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealtorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RealtorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Realtor.
     * @param {RealtorUpsertArgs} args - Arguments to update or create a Realtor.
     * @example
     * // Update or create a Realtor
     * const realtor = await prisma.realtor.upsert({
     *   create: {
     *     // ... data to create a Realtor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Realtor we want to update
     *   }
     * })
    **/
    upsert<T extends RealtorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RealtorUpsertArgs<ExtArgs>>
    ): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Realtors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealtorCountArgs} args - Arguments to filter Realtors to count.
     * @example
     * // Count the number of Realtors
     * const count = await prisma.realtor.count({
     *   where: {
     *     // ... the filter for the Realtors we want to count
     *   }
     * })
    **/
    count<T extends RealtorCountArgs>(
      args?: Subset<T, RealtorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealtorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Realtor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealtorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealtorAggregateArgs>(args: Subset<T, RealtorAggregateArgs>): Prisma.PrismaPromise<GetRealtorAggregateType<T>>

    /**
     * Group by Realtor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealtorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealtorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealtorGroupByArgs['orderBy'] }
        : { orderBy?: RealtorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealtorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealtorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Realtor model
   */
  readonly fields: RealtorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Realtor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RealtorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends Realtor$objectArgs<ExtArgs> = {}>(args?: Subset<T, Realtor$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Realtor model
   */ 
  interface RealtorFieldRefs {
    readonly id: FieldRef<"Realtor", 'Int'>
    readonly name: FieldRef<"Realtor", 'String'>
    readonly is_active: FieldRef<"Realtor", 'Boolean'>
    readonly reg_date: FieldRef<"Realtor", 'DateTime'>
    readonly deactivate_date: FieldRef<"Realtor", 'DateTime'>
    readonly photo: FieldRef<"Realtor", 'String'>
    readonly login: FieldRef<"Realtor", 'String'>
    readonly password: FieldRef<"Realtor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Realtor findUnique
   */
  export type RealtorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * Filter, which Realtor to fetch.
     */
    where: RealtorWhereUniqueInput
  }

  /**
   * Realtor findUniqueOrThrow
   */
  export type RealtorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * Filter, which Realtor to fetch.
     */
    where: RealtorWhereUniqueInput
  }

  /**
   * Realtor findFirst
   */
  export type RealtorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * Filter, which Realtor to fetch.
     */
    where?: RealtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Realtors to fetch.
     */
    orderBy?: RealtorOrderByWithRelationInput | RealtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Realtors.
     */
    cursor?: RealtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Realtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Realtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Realtors.
     */
    distinct?: RealtorScalarFieldEnum | RealtorScalarFieldEnum[]
  }

  /**
   * Realtor findFirstOrThrow
   */
  export type RealtorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * Filter, which Realtor to fetch.
     */
    where?: RealtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Realtors to fetch.
     */
    orderBy?: RealtorOrderByWithRelationInput | RealtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Realtors.
     */
    cursor?: RealtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Realtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Realtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Realtors.
     */
    distinct?: RealtorScalarFieldEnum | RealtorScalarFieldEnum[]
  }

  /**
   * Realtor findMany
   */
  export type RealtorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * Filter, which Realtors to fetch.
     */
    where?: RealtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Realtors to fetch.
     */
    orderBy?: RealtorOrderByWithRelationInput | RealtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Realtors.
     */
    cursor?: RealtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Realtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Realtors.
     */
    skip?: number
    distinct?: RealtorScalarFieldEnum | RealtorScalarFieldEnum[]
  }

  /**
   * Realtor create
   */
  export type RealtorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * The data needed to create a Realtor.
     */
    data: XOR<RealtorCreateInput, RealtorUncheckedCreateInput>
  }

  /**
   * Realtor createMany
   */
  export type RealtorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Realtors.
     */
    data: RealtorCreateManyInput | RealtorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Realtor update
   */
  export type RealtorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * The data needed to update a Realtor.
     */
    data: XOR<RealtorUpdateInput, RealtorUncheckedUpdateInput>
    /**
     * Choose, which Realtor to update.
     */
    where: RealtorWhereUniqueInput
  }

  /**
   * Realtor updateMany
   */
  export type RealtorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Realtors.
     */
    data: XOR<RealtorUpdateManyMutationInput, RealtorUncheckedUpdateManyInput>
    /**
     * Filter which Realtors to update
     */
    where?: RealtorWhereInput
  }

  /**
   * Realtor upsert
   */
  export type RealtorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * The filter to search for the Realtor to update in case it exists.
     */
    where: RealtorWhereUniqueInput
    /**
     * In case the Realtor found by the `where` argument doesn't exist, create a new Realtor with this data.
     */
    create: XOR<RealtorCreateInput, RealtorUncheckedCreateInput>
    /**
     * In case the Realtor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealtorUpdateInput, RealtorUncheckedUpdateInput>
  }

  /**
   * Realtor delete
   */
  export type RealtorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    /**
     * Filter which Realtor to delete.
     */
    where: RealtorWhereUniqueInput
  }

  /**
   * Realtor deleteMany
   */
  export type RealtorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Realtors to delete
     */
    where?: RealtorWhereInput
  }

  /**
   * Realtor.object
   */
  export type Realtor$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Realtor without action
   */
  export type RealtorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
  }


  /**
   * Model ObjectType
   */

  export type AggregateObjectType = {
    _count: ObjectTypeCountAggregateOutputType | null
    _avg: ObjectTypeAvgAggregateOutputType | null
    _sum: ObjectTypeSumAggregateOutputType | null
    _min: ObjectTypeMinAggregateOutputType | null
    _max: ObjectTypeMaxAggregateOutputType | null
  }

  export type ObjectTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ObjectTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ObjectTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ObjectTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ObjectTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ObjectTypeAvgAggregateInputType = {
    id?: true
  }

  export type ObjectTypeSumAggregateInputType = {
    id?: true
  }

  export type ObjectTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ObjectTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ObjectTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ObjectTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectType to aggregate.
     */
    where?: ObjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectTypes to fetch.
     */
    orderBy?: ObjectTypeOrderByWithRelationInput | ObjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjectTypes
    **/
    _count?: true | ObjectTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectTypeMaxAggregateInputType
  }

  export type GetObjectTypeAggregateType<T extends ObjectTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateObjectType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjectType[P]>
      : GetScalarType<T[P], AggregateObjectType[P]>
  }




  export type ObjectTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectTypeWhereInput
    orderBy?: ObjectTypeOrderByWithAggregationInput | ObjectTypeOrderByWithAggregationInput[]
    by: ObjectTypeScalarFieldEnum[] | ObjectTypeScalarFieldEnum
    having?: ObjectTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectTypeCountAggregateInputType | true
    _avg?: ObjectTypeAvgAggregateInputType
    _sum?: ObjectTypeSumAggregateInputType
    _min?: ObjectTypeMinAggregateInputType
    _max?: ObjectTypeMaxAggregateInputType
  }

  export type ObjectTypeGroupByOutputType = {
    id: number
    name: string
    _count: ObjectTypeCountAggregateOutputType | null
    _avg: ObjectTypeAvgAggregateOutputType | null
    _sum: ObjectTypeSumAggregateOutputType | null
    _min: ObjectTypeMinAggregateOutputType | null
    _max: ObjectTypeMaxAggregateOutputType | null
  }

  type GetObjectTypeGroupByPayload<T extends ObjectTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectTypeGroupByOutputType[P]>
        }
      >
    >


  export type ObjectTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    object?: boolean | ObjectType$objectArgs<ExtArgs>
    residenceType?: boolean | ObjectType$residenceTypeArgs<ExtArgs>
    _count?: boolean | ObjectTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectType"]>

  export type ObjectTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type ObjectTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectType$objectArgs<ExtArgs>
    residenceType?: boolean | ObjectType$residenceTypeArgs<ExtArgs>
    _count?: boolean | ObjectTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ObjectTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjectType"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
      residenceType: Prisma.$ResidenceTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["objectType"]>
    composites: {}
  }


  type ObjectTypeGetPayload<S extends boolean | null | undefined | ObjectTypeDefaultArgs> = $Result.GetResult<Prisma.$ObjectTypePayload, S>

  type ObjectTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjectTypeCountAggregateInputType | true
    }

  export interface ObjectTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjectType'], meta: { name: 'ObjectType' } }
    /**
     * Find zero or one ObjectType that matches the filter.
     * @param {ObjectTypeFindUniqueArgs} args - Arguments to find a ObjectType
     * @example
     * // Get one ObjectType
     * const objectType = await prisma.objectType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ObjectType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectTypeFindUniqueOrThrowArgs} args - Arguments to find a ObjectType
     * @example
     * // Get one ObjectType
     * const objectType = await prisma.objectType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ObjectType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectTypeFindFirstArgs} args - Arguments to find a ObjectType
     * @example
     * // Get one ObjectType
     * const objectType = await prisma.objectType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectTypeFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ObjectType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectTypeFindFirstOrThrowArgs} args - Arguments to find a ObjectType
     * @example
     * // Get one ObjectType
     * const objectType = await prisma.objectType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ObjectTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjectTypes
     * const objectTypes = await prisma.objectType.findMany()
     * 
     * // Get first 10 ObjectTypes
     * const objectTypes = await prisma.objectType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectTypeWithIdOnly = await prisma.objectType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ObjectType.
     * @param {ObjectTypeCreateArgs} args - Arguments to create a ObjectType.
     * @example
     * // Create one ObjectType
     * const ObjectType = await prisma.objectType.create({
     *   data: {
     *     // ... data to create a ObjectType
     *   }
     * })
     * 
    **/
    create<T extends ObjectTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectTypeCreateArgs<ExtArgs>>
    ): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ObjectTypes.
     *     @param {ObjectTypeCreateManyArgs} args - Arguments to create many ObjectTypes.
     *     @example
     *     // Create many ObjectTypes
     *     const objectType = await prisma.objectType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ObjectType.
     * @param {ObjectTypeDeleteArgs} args - Arguments to delete one ObjectType.
     * @example
     * // Delete one ObjectType
     * const ObjectType = await prisma.objectType.delete({
     *   where: {
     *     // ... filter to delete one ObjectType
     *   }
     * })
     * 
    **/
    delete<T extends ObjectTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectTypeDeleteArgs<ExtArgs>>
    ): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ObjectType.
     * @param {ObjectTypeUpdateArgs} args - Arguments to update one ObjectType.
     * @example
     * // Update one ObjectType
     * const objectType = await prisma.objectType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectTypeUpdateArgs<ExtArgs>>
    ): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ObjectTypes.
     * @param {ObjectTypeDeleteManyArgs} args - Arguments to filter ObjectTypes to delete.
     * @example
     * // Delete a few ObjectTypes
     * const { count } = await prisma.objectType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjectTypes
     * const objectType = await prisma.objectType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjectType.
     * @param {ObjectTypeUpsertArgs} args - Arguments to update or create a ObjectType.
     * @example
     * // Update or create a ObjectType
     * const objectType = await prisma.objectType.upsert({
     *   create: {
     *     // ... data to create a ObjectType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjectType we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectTypeUpsertArgs<ExtArgs>>
    ): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ObjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectTypeCountArgs} args - Arguments to filter ObjectTypes to count.
     * @example
     * // Count the number of ObjectTypes
     * const count = await prisma.objectType.count({
     *   where: {
     *     // ... the filter for the ObjectTypes we want to count
     *   }
     * })
    **/
    count<T extends ObjectTypeCountArgs>(
      args?: Subset<T, ObjectTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjectType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectTypeAggregateArgs>(args: Subset<T, ObjectTypeAggregateArgs>): Prisma.PrismaPromise<GetObjectTypeAggregateType<T>>

    /**
     * Group by ObjectType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectTypeGroupByArgs['orderBy'] }
        : { orderBy?: ObjectTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjectType model
   */
  readonly fields: ObjectTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjectType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectType$objectArgs<ExtArgs> = {}>(args?: Subset<T, ObjectType$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    residenceType<T extends ObjectType$residenceTypeArgs<ExtArgs> = {}>(args?: Subset<T, ObjectType$residenceTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ObjectType model
   */ 
  interface ObjectTypeFieldRefs {
    readonly id: FieldRef<"ObjectType", 'Int'>
    readonly name: FieldRef<"ObjectType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ObjectType findUnique
   */
  export type ObjectTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ObjectType to fetch.
     */
    where: ObjectTypeWhereUniqueInput
  }

  /**
   * ObjectType findUniqueOrThrow
   */
  export type ObjectTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ObjectType to fetch.
     */
    where: ObjectTypeWhereUniqueInput
  }

  /**
   * ObjectType findFirst
   */
  export type ObjectTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ObjectType to fetch.
     */
    where?: ObjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectTypes to fetch.
     */
    orderBy?: ObjectTypeOrderByWithRelationInput | ObjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectTypes.
     */
    cursor?: ObjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectTypes.
     */
    distinct?: ObjectTypeScalarFieldEnum | ObjectTypeScalarFieldEnum[]
  }

  /**
   * ObjectType findFirstOrThrow
   */
  export type ObjectTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ObjectType to fetch.
     */
    where?: ObjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectTypes to fetch.
     */
    orderBy?: ObjectTypeOrderByWithRelationInput | ObjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectTypes.
     */
    cursor?: ObjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectTypes.
     */
    distinct?: ObjectTypeScalarFieldEnum | ObjectTypeScalarFieldEnum[]
  }

  /**
   * ObjectType findMany
   */
  export type ObjectTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ObjectTypes to fetch.
     */
    where?: ObjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectTypes to fetch.
     */
    orderBy?: ObjectTypeOrderByWithRelationInput | ObjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjectTypes.
     */
    cursor?: ObjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectTypes.
     */
    skip?: number
    distinct?: ObjectTypeScalarFieldEnum | ObjectTypeScalarFieldEnum[]
  }

  /**
   * ObjectType create
   */
  export type ObjectTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjectType.
     */
    data: XOR<ObjectTypeCreateInput, ObjectTypeUncheckedCreateInput>
  }

  /**
   * ObjectType createMany
   */
  export type ObjectTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjectTypes.
     */
    data: ObjectTypeCreateManyInput | ObjectTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObjectType update
   */
  export type ObjectTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjectType.
     */
    data: XOR<ObjectTypeUpdateInput, ObjectTypeUncheckedUpdateInput>
    /**
     * Choose, which ObjectType to update.
     */
    where: ObjectTypeWhereUniqueInput
  }

  /**
   * ObjectType updateMany
   */
  export type ObjectTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjectTypes.
     */
    data: XOR<ObjectTypeUpdateManyMutationInput, ObjectTypeUncheckedUpdateManyInput>
    /**
     * Filter which ObjectTypes to update
     */
    where?: ObjectTypeWhereInput
  }

  /**
   * ObjectType upsert
   */
  export type ObjectTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjectType to update in case it exists.
     */
    where: ObjectTypeWhereUniqueInput
    /**
     * In case the ObjectType found by the `where` argument doesn't exist, create a new ObjectType with this data.
     */
    create: XOR<ObjectTypeCreateInput, ObjectTypeUncheckedCreateInput>
    /**
     * In case the ObjectType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectTypeUpdateInput, ObjectTypeUncheckedUpdateInput>
  }

  /**
   * ObjectType delete
   */
  export type ObjectTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    /**
     * Filter which ObjectType to delete.
     */
    where: ObjectTypeWhereUniqueInput
  }

  /**
   * ObjectType deleteMany
   */
  export type ObjectTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectTypes to delete
     */
    where?: ObjectTypeWhereInput
  }

  /**
   * ObjectType.object
   */
  export type ObjectType$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * ObjectType.residenceType
   */
  export type ObjectType$residenceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    where?: ResidenceTypeWhereInput
    orderBy?: ResidenceTypeOrderByWithRelationInput | ResidenceTypeOrderByWithRelationInput[]
    cursor?: ResidenceTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResidenceTypeScalarFieldEnum | ResidenceTypeScalarFieldEnum[]
  }

  /**
   * ObjectType without action
   */
  export type ObjectTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
  }


  /**
   * Model ResidenceType
   */

  export type AggregateResidenceType = {
    _count: ResidenceTypeCountAggregateOutputType | null
    _avg: ResidenceTypeAvgAggregateOutputType | null
    _sum: ResidenceTypeSumAggregateOutputType | null
    _min: ResidenceTypeMinAggregateOutputType | null
    _max: ResidenceTypeMaxAggregateOutputType | null
  }

  export type ResidenceTypeAvgAggregateOutputType = {
    id: number | null
    objectTypeId: number | null
  }

  export type ResidenceTypeSumAggregateOutputType = {
    id: number | null
    objectTypeId: number | null
  }

  export type ResidenceTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    objectTypeId: number | null
  }

  export type ResidenceTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    objectTypeId: number | null
  }

  export type ResidenceTypeCountAggregateOutputType = {
    id: number
    name: number
    objectTypeId: number
    _all: number
  }


  export type ResidenceTypeAvgAggregateInputType = {
    id?: true
    objectTypeId?: true
  }

  export type ResidenceTypeSumAggregateInputType = {
    id?: true
    objectTypeId?: true
  }

  export type ResidenceTypeMinAggregateInputType = {
    id?: true
    name?: true
    objectTypeId?: true
  }

  export type ResidenceTypeMaxAggregateInputType = {
    id?: true
    name?: true
    objectTypeId?: true
  }

  export type ResidenceTypeCountAggregateInputType = {
    id?: true
    name?: true
    objectTypeId?: true
    _all?: true
  }

  export type ResidenceTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResidenceType to aggregate.
     */
    where?: ResidenceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResidenceTypes to fetch.
     */
    orderBy?: ResidenceTypeOrderByWithRelationInput | ResidenceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResidenceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResidenceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResidenceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResidenceTypes
    **/
    _count?: true | ResidenceTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResidenceTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResidenceTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResidenceTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResidenceTypeMaxAggregateInputType
  }

  export type GetResidenceTypeAggregateType<T extends ResidenceTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateResidenceType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResidenceType[P]>
      : GetScalarType<T[P], AggregateResidenceType[P]>
  }




  export type ResidenceTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResidenceTypeWhereInput
    orderBy?: ResidenceTypeOrderByWithAggregationInput | ResidenceTypeOrderByWithAggregationInput[]
    by: ResidenceTypeScalarFieldEnum[] | ResidenceTypeScalarFieldEnum
    having?: ResidenceTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResidenceTypeCountAggregateInputType | true
    _avg?: ResidenceTypeAvgAggregateInputType
    _sum?: ResidenceTypeSumAggregateInputType
    _min?: ResidenceTypeMinAggregateInputType
    _max?: ResidenceTypeMaxAggregateInputType
  }

  export type ResidenceTypeGroupByOutputType = {
    id: number
    name: string
    objectTypeId: number | null
    _count: ResidenceTypeCountAggregateOutputType | null
    _avg: ResidenceTypeAvgAggregateOutputType | null
    _sum: ResidenceTypeSumAggregateOutputType | null
    _min: ResidenceTypeMinAggregateOutputType | null
    _max: ResidenceTypeMaxAggregateOutputType | null
  }

  type GetResidenceTypeGroupByPayload<T extends ResidenceTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResidenceTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResidenceTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResidenceTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ResidenceTypeGroupByOutputType[P]>
        }
      >
    >


  export type ResidenceTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    objectTypeId?: boolean
    object?: boolean | ResidenceType$objectArgs<ExtArgs>
    ObjectType?: boolean | ResidenceType$ObjectTypeArgs<ExtArgs>
    _count?: boolean | ResidenceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["residenceType"]>

  export type ResidenceTypeSelectScalar = {
    id?: boolean
    name?: boolean
    objectTypeId?: boolean
  }


  export type ResidenceTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ResidenceType$objectArgs<ExtArgs>
    ObjectType?: boolean | ResidenceType$ObjectTypeArgs<ExtArgs>
    _count?: boolean | ResidenceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ResidenceTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResidenceType"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
      ObjectType: Prisma.$ObjectTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      objectTypeId: number | null
    }, ExtArgs["result"]["residenceType"]>
    composites: {}
  }


  type ResidenceTypeGetPayload<S extends boolean | null | undefined | ResidenceTypeDefaultArgs> = $Result.GetResult<Prisma.$ResidenceTypePayload, S>

  type ResidenceTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResidenceTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResidenceTypeCountAggregateInputType | true
    }

  export interface ResidenceTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResidenceType'], meta: { name: 'ResidenceType' } }
    /**
     * Find zero or one ResidenceType that matches the filter.
     * @param {ResidenceTypeFindUniqueArgs} args - Arguments to find a ResidenceType
     * @example
     * // Get one ResidenceType
     * const residenceType = await prisma.residenceType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResidenceTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResidenceTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ResidenceType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResidenceTypeFindUniqueOrThrowArgs} args - Arguments to find a ResidenceType
     * @example
     * // Get one ResidenceType
     * const residenceType = await prisma.residenceType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResidenceTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResidenceTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ResidenceType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceTypeFindFirstArgs} args - Arguments to find a ResidenceType
     * @example
     * // Get one ResidenceType
     * const residenceType = await prisma.residenceType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResidenceTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResidenceTypeFindFirstArgs<ExtArgs>>
    ): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ResidenceType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceTypeFindFirstOrThrowArgs} args - Arguments to find a ResidenceType
     * @example
     * // Get one ResidenceType
     * const residenceType = await prisma.residenceType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResidenceTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResidenceTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ResidenceTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResidenceTypes
     * const residenceTypes = await prisma.residenceType.findMany()
     * 
     * // Get first 10 ResidenceTypes
     * const residenceTypes = await prisma.residenceType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const residenceTypeWithIdOnly = await prisma.residenceType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResidenceTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResidenceTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ResidenceType.
     * @param {ResidenceTypeCreateArgs} args - Arguments to create a ResidenceType.
     * @example
     * // Create one ResidenceType
     * const ResidenceType = await prisma.residenceType.create({
     *   data: {
     *     // ... data to create a ResidenceType
     *   }
     * })
     * 
    **/
    create<T extends ResidenceTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResidenceTypeCreateArgs<ExtArgs>>
    ): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ResidenceTypes.
     *     @param {ResidenceTypeCreateManyArgs} args - Arguments to create many ResidenceTypes.
     *     @example
     *     // Create many ResidenceTypes
     *     const residenceType = await prisma.residenceType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResidenceTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResidenceTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResidenceType.
     * @param {ResidenceTypeDeleteArgs} args - Arguments to delete one ResidenceType.
     * @example
     * // Delete one ResidenceType
     * const ResidenceType = await prisma.residenceType.delete({
     *   where: {
     *     // ... filter to delete one ResidenceType
     *   }
     * })
     * 
    **/
    delete<T extends ResidenceTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResidenceTypeDeleteArgs<ExtArgs>>
    ): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ResidenceType.
     * @param {ResidenceTypeUpdateArgs} args - Arguments to update one ResidenceType.
     * @example
     * // Update one ResidenceType
     * const residenceType = await prisma.residenceType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResidenceTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResidenceTypeUpdateArgs<ExtArgs>>
    ): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ResidenceTypes.
     * @param {ResidenceTypeDeleteManyArgs} args - Arguments to filter ResidenceTypes to delete.
     * @example
     * // Delete a few ResidenceTypes
     * const { count } = await prisma.residenceType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResidenceTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResidenceTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResidenceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResidenceTypes
     * const residenceType = await prisma.residenceType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResidenceTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResidenceTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResidenceType.
     * @param {ResidenceTypeUpsertArgs} args - Arguments to update or create a ResidenceType.
     * @example
     * // Update or create a ResidenceType
     * const residenceType = await prisma.residenceType.upsert({
     *   create: {
     *     // ... data to create a ResidenceType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResidenceType we want to update
     *   }
     * })
    **/
    upsert<T extends ResidenceTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResidenceTypeUpsertArgs<ExtArgs>>
    ): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ResidenceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceTypeCountArgs} args - Arguments to filter ResidenceTypes to count.
     * @example
     * // Count the number of ResidenceTypes
     * const count = await prisma.residenceType.count({
     *   where: {
     *     // ... the filter for the ResidenceTypes we want to count
     *   }
     * })
    **/
    count<T extends ResidenceTypeCountArgs>(
      args?: Subset<T, ResidenceTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResidenceTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResidenceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResidenceTypeAggregateArgs>(args: Subset<T, ResidenceTypeAggregateArgs>): Prisma.PrismaPromise<GetResidenceTypeAggregateType<T>>

    /**
     * Group by ResidenceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResidenceTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResidenceTypeGroupByArgs['orderBy'] }
        : { orderBy?: ResidenceTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResidenceTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResidenceTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResidenceType model
   */
  readonly fields: ResidenceTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResidenceType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResidenceTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ResidenceType$objectArgs<ExtArgs> = {}>(args?: Subset<T, ResidenceType$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    ObjectType<T extends ResidenceType$ObjectTypeArgs<ExtArgs> = {}>(args?: Subset<T, ResidenceType$ObjectTypeArgs<ExtArgs>>): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ResidenceType model
   */ 
  interface ResidenceTypeFieldRefs {
    readonly id: FieldRef<"ResidenceType", 'Int'>
    readonly name: FieldRef<"ResidenceType", 'String'>
    readonly objectTypeId: FieldRef<"ResidenceType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ResidenceType findUnique
   */
  export type ResidenceTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ResidenceType to fetch.
     */
    where: ResidenceTypeWhereUniqueInput
  }

  /**
   * ResidenceType findUniqueOrThrow
   */
  export type ResidenceTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ResidenceType to fetch.
     */
    where: ResidenceTypeWhereUniqueInput
  }

  /**
   * ResidenceType findFirst
   */
  export type ResidenceTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ResidenceType to fetch.
     */
    where?: ResidenceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResidenceTypes to fetch.
     */
    orderBy?: ResidenceTypeOrderByWithRelationInput | ResidenceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResidenceTypes.
     */
    cursor?: ResidenceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResidenceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResidenceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResidenceTypes.
     */
    distinct?: ResidenceTypeScalarFieldEnum | ResidenceTypeScalarFieldEnum[]
  }

  /**
   * ResidenceType findFirstOrThrow
   */
  export type ResidenceTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ResidenceType to fetch.
     */
    where?: ResidenceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResidenceTypes to fetch.
     */
    orderBy?: ResidenceTypeOrderByWithRelationInput | ResidenceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResidenceTypes.
     */
    cursor?: ResidenceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResidenceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResidenceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResidenceTypes.
     */
    distinct?: ResidenceTypeScalarFieldEnum | ResidenceTypeScalarFieldEnum[]
  }

  /**
   * ResidenceType findMany
   */
  export type ResidenceTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ResidenceTypes to fetch.
     */
    where?: ResidenceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResidenceTypes to fetch.
     */
    orderBy?: ResidenceTypeOrderByWithRelationInput | ResidenceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResidenceTypes.
     */
    cursor?: ResidenceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResidenceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResidenceTypes.
     */
    skip?: number
    distinct?: ResidenceTypeScalarFieldEnum | ResidenceTypeScalarFieldEnum[]
  }

  /**
   * ResidenceType create
   */
  export type ResidenceTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ResidenceType.
     */
    data: XOR<ResidenceTypeCreateInput, ResidenceTypeUncheckedCreateInput>
  }

  /**
   * ResidenceType createMany
   */
  export type ResidenceTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResidenceTypes.
     */
    data: ResidenceTypeCreateManyInput | ResidenceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResidenceType update
   */
  export type ResidenceTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ResidenceType.
     */
    data: XOR<ResidenceTypeUpdateInput, ResidenceTypeUncheckedUpdateInput>
    /**
     * Choose, which ResidenceType to update.
     */
    where: ResidenceTypeWhereUniqueInput
  }

  /**
   * ResidenceType updateMany
   */
  export type ResidenceTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResidenceTypes.
     */
    data: XOR<ResidenceTypeUpdateManyMutationInput, ResidenceTypeUncheckedUpdateManyInput>
    /**
     * Filter which ResidenceTypes to update
     */
    where?: ResidenceTypeWhereInput
  }

  /**
   * ResidenceType upsert
   */
  export type ResidenceTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ResidenceType to update in case it exists.
     */
    where: ResidenceTypeWhereUniqueInput
    /**
     * In case the ResidenceType found by the `where` argument doesn't exist, create a new ResidenceType with this data.
     */
    create: XOR<ResidenceTypeCreateInput, ResidenceTypeUncheckedCreateInput>
    /**
     * In case the ResidenceType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResidenceTypeUpdateInput, ResidenceTypeUncheckedUpdateInput>
  }

  /**
   * ResidenceType delete
   */
  export type ResidenceTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    /**
     * Filter which ResidenceType to delete.
     */
    where: ResidenceTypeWhereUniqueInput
  }

  /**
   * ResidenceType deleteMany
   */
  export type ResidenceTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResidenceTypes to delete
     */
    where?: ResidenceTypeWhereInput
  }

  /**
   * ResidenceType.object
   */
  export type ResidenceType$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * ResidenceType.ObjectType
   */
  export type ResidenceType$ObjectTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    where?: ObjectTypeWhereInput
  }

  /**
   * ResidenceType without action
   */
  export type ResidenceTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
  }


  /**
   * Model ObjectCategory
   */

  export type AggregateObjectCategory = {
    _count: ObjectCategoryCountAggregateOutputType | null
    _avg: ObjectCategoryAvgAggregateOutputType | null
    _sum: ObjectCategorySumAggregateOutputType | null
    _min: ObjectCategoryMinAggregateOutputType | null
    _max: ObjectCategoryMaxAggregateOutputType | null
  }

  export type ObjectCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ObjectCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ObjectCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ObjectCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ObjectCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ObjectCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ObjectCategorySumAggregateInputType = {
    id?: true
  }

  export type ObjectCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ObjectCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ObjectCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ObjectCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectCategory to aggregate.
     */
    where?: ObjectCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectCategories to fetch.
     */
    orderBy?: ObjectCategoryOrderByWithRelationInput | ObjectCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjectCategories
    **/
    _count?: true | ObjectCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectCategoryMaxAggregateInputType
  }

  export type GetObjectCategoryAggregateType<T extends ObjectCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateObjectCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjectCategory[P]>
      : GetScalarType<T[P], AggregateObjectCategory[P]>
  }




  export type ObjectCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectCategoryWhereInput
    orderBy?: ObjectCategoryOrderByWithAggregationInput | ObjectCategoryOrderByWithAggregationInput[]
    by: ObjectCategoryScalarFieldEnum[] | ObjectCategoryScalarFieldEnum
    having?: ObjectCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectCategoryCountAggregateInputType | true
    _avg?: ObjectCategoryAvgAggregateInputType
    _sum?: ObjectCategorySumAggregateInputType
    _min?: ObjectCategoryMinAggregateInputType
    _max?: ObjectCategoryMaxAggregateInputType
  }

  export type ObjectCategoryGroupByOutputType = {
    id: number
    name: string
    _count: ObjectCategoryCountAggregateOutputType | null
    _avg: ObjectCategoryAvgAggregateOutputType | null
    _sum: ObjectCategorySumAggregateOutputType | null
    _min: ObjectCategoryMinAggregateOutputType | null
    _max: ObjectCategoryMaxAggregateOutputType | null
  }

  type GetObjectCategoryGroupByPayload<T extends ObjectCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ObjectCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    object?: boolean | ObjectCategory$objectArgs<ExtArgs>
    _count?: boolean | ObjectCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectCategory"]>

  export type ObjectCategorySelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type ObjectCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectCategory$objectArgs<ExtArgs>
    _count?: boolean | ObjectCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ObjectCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjectCategory"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["objectCategory"]>
    composites: {}
  }


  type ObjectCategoryGetPayload<S extends boolean | null | undefined | ObjectCategoryDefaultArgs> = $Result.GetResult<Prisma.$ObjectCategoryPayload, S>

  type ObjectCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjectCategoryCountAggregateInputType | true
    }

  export interface ObjectCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjectCategory'], meta: { name: 'ObjectCategory' } }
    /**
     * Find zero or one ObjectCategory that matches the filter.
     * @param {ObjectCategoryFindUniqueArgs} args - Arguments to find a ObjectCategory
     * @example
     * // Get one ObjectCategory
     * const objectCategory = await prisma.objectCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ObjectCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectCategoryFindUniqueOrThrowArgs} args - Arguments to find a ObjectCategory
     * @example
     * // Get one ObjectCategory
     * const objectCategory = await prisma.objectCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ObjectCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCategoryFindFirstArgs} args - Arguments to find a ObjectCategory
     * @example
     * // Get one ObjectCategory
     * const objectCategory = await prisma.objectCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ObjectCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCategoryFindFirstOrThrowArgs} args - Arguments to find a ObjectCategory
     * @example
     * // Get one ObjectCategory
     * const objectCategory = await prisma.objectCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ObjectCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjectCategories
     * const objectCategories = await prisma.objectCategory.findMany()
     * 
     * // Get first 10 ObjectCategories
     * const objectCategories = await prisma.objectCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectCategoryWithIdOnly = await prisma.objectCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ObjectCategory.
     * @param {ObjectCategoryCreateArgs} args - Arguments to create a ObjectCategory.
     * @example
     * // Create one ObjectCategory
     * const ObjectCategory = await prisma.objectCategory.create({
     *   data: {
     *     // ... data to create a ObjectCategory
     *   }
     * })
     * 
    **/
    create<T extends ObjectCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCategoryCreateArgs<ExtArgs>>
    ): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ObjectCategories.
     *     @param {ObjectCategoryCreateManyArgs} args - Arguments to create many ObjectCategories.
     *     @example
     *     // Create many ObjectCategories
     *     const objectCategory = await prisma.objectCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ObjectCategory.
     * @param {ObjectCategoryDeleteArgs} args - Arguments to delete one ObjectCategory.
     * @example
     * // Delete one ObjectCategory
     * const ObjectCategory = await prisma.objectCategory.delete({
     *   where: {
     *     // ... filter to delete one ObjectCategory
     *   }
     * })
     * 
    **/
    delete<T extends ObjectCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCategoryDeleteArgs<ExtArgs>>
    ): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ObjectCategory.
     * @param {ObjectCategoryUpdateArgs} args - Arguments to update one ObjectCategory.
     * @example
     * // Update one ObjectCategory
     * const objectCategory = await prisma.objectCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCategoryUpdateArgs<ExtArgs>>
    ): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ObjectCategories.
     * @param {ObjectCategoryDeleteManyArgs} args - Arguments to filter ObjectCategories to delete.
     * @example
     * // Delete a few ObjectCategories
     * const { count } = await prisma.objectCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjectCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjectCategories
     * const objectCategory = await prisma.objectCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjectCategory.
     * @param {ObjectCategoryUpsertArgs} args - Arguments to update or create a ObjectCategory.
     * @example
     * // Update or create a ObjectCategory
     * const objectCategory = await prisma.objectCategory.upsert({
     *   create: {
     *     // ... data to create a ObjectCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjectCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCategoryUpsertArgs<ExtArgs>>
    ): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ObjectCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCategoryCountArgs} args - Arguments to filter ObjectCategories to count.
     * @example
     * // Count the number of ObjectCategories
     * const count = await prisma.objectCategory.count({
     *   where: {
     *     // ... the filter for the ObjectCategories we want to count
     *   }
     * })
    **/
    count<T extends ObjectCategoryCountArgs>(
      args?: Subset<T, ObjectCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjectCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectCategoryAggregateArgs>(args: Subset<T, ObjectCategoryAggregateArgs>): Prisma.PrismaPromise<GetObjectCategoryAggregateType<T>>

    /**
     * Group by ObjectCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ObjectCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjectCategory model
   */
  readonly fields: ObjectCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjectCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectCategory$objectArgs<ExtArgs> = {}>(args?: Subset<T, ObjectCategory$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ObjectCategory model
   */ 
  interface ObjectCategoryFieldRefs {
    readonly id: FieldRef<"ObjectCategory", 'Int'>
    readonly name: FieldRef<"ObjectCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ObjectCategory findUnique
   */
  export type ObjectCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ObjectCategory to fetch.
     */
    where: ObjectCategoryWhereUniqueInput
  }

  /**
   * ObjectCategory findUniqueOrThrow
   */
  export type ObjectCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ObjectCategory to fetch.
     */
    where: ObjectCategoryWhereUniqueInput
  }

  /**
   * ObjectCategory findFirst
   */
  export type ObjectCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ObjectCategory to fetch.
     */
    where?: ObjectCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectCategories to fetch.
     */
    orderBy?: ObjectCategoryOrderByWithRelationInput | ObjectCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectCategories.
     */
    cursor?: ObjectCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectCategories.
     */
    distinct?: ObjectCategoryScalarFieldEnum | ObjectCategoryScalarFieldEnum[]
  }

  /**
   * ObjectCategory findFirstOrThrow
   */
  export type ObjectCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ObjectCategory to fetch.
     */
    where?: ObjectCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectCategories to fetch.
     */
    orderBy?: ObjectCategoryOrderByWithRelationInput | ObjectCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectCategories.
     */
    cursor?: ObjectCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectCategories.
     */
    distinct?: ObjectCategoryScalarFieldEnum | ObjectCategoryScalarFieldEnum[]
  }

  /**
   * ObjectCategory findMany
   */
  export type ObjectCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ObjectCategories to fetch.
     */
    where?: ObjectCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectCategories to fetch.
     */
    orderBy?: ObjectCategoryOrderByWithRelationInput | ObjectCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjectCategories.
     */
    cursor?: ObjectCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectCategories.
     */
    skip?: number
    distinct?: ObjectCategoryScalarFieldEnum | ObjectCategoryScalarFieldEnum[]
  }

  /**
   * ObjectCategory create
   */
  export type ObjectCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjectCategory.
     */
    data: XOR<ObjectCategoryCreateInput, ObjectCategoryUncheckedCreateInput>
  }

  /**
   * ObjectCategory createMany
   */
  export type ObjectCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjectCategories.
     */
    data: ObjectCategoryCreateManyInput | ObjectCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObjectCategory update
   */
  export type ObjectCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjectCategory.
     */
    data: XOR<ObjectCategoryUpdateInput, ObjectCategoryUncheckedUpdateInput>
    /**
     * Choose, which ObjectCategory to update.
     */
    where: ObjectCategoryWhereUniqueInput
  }

  /**
   * ObjectCategory updateMany
   */
  export type ObjectCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjectCategories.
     */
    data: XOR<ObjectCategoryUpdateManyMutationInput, ObjectCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ObjectCategories to update
     */
    where?: ObjectCategoryWhereInput
  }

  /**
   * ObjectCategory upsert
   */
  export type ObjectCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjectCategory to update in case it exists.
     */
    where: ObjectCategoryWhereUniqueInput
    /**
     * In case the ObjectCategory found by the `where` argument doesn't exist, create a new ObjectCategory with this data.
     */
    create: XOR<ObjectCategoryCreateInput, ObjectCategoryUncheckedCreateInput>
    /**
     * In case the ObjectCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectCategoryUpdateInput, ObjectCategoryUncheckedUpdateInput>
  }

  /**
   * ObjectCategory delete
   */
  export type ObjectCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    /**
     * Filter which ObjectCategory to delete.
     */
    where: ObjectCategoryWhereUniqueInput
  }

  /**
   * ObjectCategory deleteMany
   */
  export type ObjectCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectCategories to delete
     */
    where?: ObjectCategoryWhereInput
  }

  /**
   * ObjectCategory.object
   */
  export type ObjectCategory$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * ObjectCategory without action
   */
  export type ObjectCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ObjectStatus
   */

  export type AggregateObjectStatus = {
    _count: ObjectStatusCountAggregateOutputType | null
    _avg: ObjectStatusAvgAggregateOutputType | null
    _sum: ObjectStatusSumAggregateOutputType | null
    _min: ObjectStatusMinAggregateOutputType | null
    _max: ObjectStatusMaxAggregateOutputType | null
  }

  export type ObjectStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type ObjectStatusSumAggregateOutputType = {
    id: number | null
  }

  export type ObjectStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ObjectStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ObjectStatusCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ObjectStatusAvgAggregateInputType = {
    id?: true
  }

  export type ObjectStatusSumAggregateInputType = {
    id?: true
  }

  export type ObjectStatusMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ObjectStatusMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ObjectStatusCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ObjectStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectStatus to aggregate.
     */
    where?: ObjectStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectStatuses to fetch.
     */
    orderBy?: ObjectStatusOrderByWithRelationInput | ObjectStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjectStatuses
    **/
    _count?: true | ObjectStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectStatusMaxAggregateInputType
  }

  export type GetObjectStatusAggregateType<T extends ObjectStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateObjectStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjectStatus[P]>
      : GetScalarType<T[P], AggregateObjectStatus[P]>
  }




  export type ObjectStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectStatusWhereInput
    orderBy?: ObjectStatusOrderByWithAggregationInput | ObjectStatusOrderByWithAggregationInput[]
    by: ObjectStatusScalarFieldEnum[] | ObjectStatusScalarFieldEnum
    having?: ObjectStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectStatusCountAggregateInputType | true
    _avg?: ObjectStatusAvgAggregateInputType
    _sum?: ObjectStatusSumAggregateInputType
    _min?: ObjectStatusMinAggregateInputType
    _max?: ObjectStatusMaxAggregateInputType
  }

  export type ObjectStatusGroupByOutputType = {
    id: number
    name: string
    _count: ObjectStatusCountAggregateOutputType | null
    _avg: ObjectStatusAvgAggregateOutputType | null
    _sum: ObjectStatusSumAggregateOutputType | null
    _min: ObjectStatusMinAggregateOutputType | null
    _max: ObjectStatusMaxAggregateOutputType | null
  }

  type GetObjectStatusGroupByPayload<T extends ObjectStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectStatusGroupByOutputType[P]>
        }
      >
    >


  export type ObjectStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    object?: boolean | ObjectStatus$objectArgs<ExtArgs>
    _count?: boolean | ObjectStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectStatus"]>

  export type ObjectStatusSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type ObjectStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | ObjectStatus$objectArgs<ExtArgs>
    _count?: boolean | ObjectStatusCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ObjectStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjectStatus"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["objectStatus"]>
    composites: {}
  }


  type ObjectStatusGetPayload<S extends boolean | null | undefined | ObjectStatusDefaultArgs> = $Result.GetResult<Prisma.$ObjectStatusPayload, S>

  type ObjectStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjectStatusCountAggregateInputType | true
    }

  export interface ObjectStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjectStatus'], meta: { name: 'ObjectStatus' } }
    /**
     * Find zero or one ObjectStatus that matches the filter.
     * @param {ObjectStatusFindUniqueArgs} args - Arguments to find a ObjectStatus
     * @example
     * // Get one ObjectStatus
     * const objectStatus = await prisma.objectStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ObjectStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectStatusFindUniqueOrThrowArgs} args - Arguments to find a ObjectStatus
     * @example
     * // Get one ObjectStatus
     * const objectStatus = await prisma.objectStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ObjectStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectStatusFindFirstArgs} args - Arguments to find a ObjectStatus
     * @example
     * // Get one ObjectStatus
     * const objectStatus = await prisma.objectStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectStatusFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ObjectStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectStatusFindFirstOrThrowArgs} args - Arguments to find a ObjectStatus
     * @example
     * // Get one ObjectStatus
     * const objectStatus = await prisma.objectStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ObjectStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjectStatuses
     * const objectStatuses = await prisma.objectStatus.findMany()
     * 
     * // Get first 10 ObjectStatuses
     * const objectStatuses = await prisma.objectStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectStatusWithIdOnly = await prisma.objectStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ObjectStatus.
     * @param {ObjectStatusCreateArgs} args - Arguments to create a ObjectStatus.
     * @example
     * // Create one ObjectStatus
     * const ObjectStatus = await prisma.objectStatus.create({
     *   data: {
     *     // ... data to create a ObjectStatus
     *   }
     * })
     * 
    **/
    create<T extends ObjectStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectStatusCreateArgs<ExtArgs>>
    ): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ObjectStatuses.
     *     @param {ObjectStatusCreateManyArgs} args - Arguments to create many ObjectStatuses.
     *     @example
     *     // Create many ObjectStatuses
     *     const objectStatus = await prisma.objectStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ObjectStatus.
     * @param {ObjectStatusDeleteArgs} args - Arguments to delete one ObjectStatus.
     * @example
     * // Delete one ObjectStatus
     * const ObjectStatus = await prisma.objectStatus.delete({
     *   where: {
     *     // ... filter to delete one ObjectStatus
     *   }
     * })
     * 
    **/
    delete<T extends ObjectStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectStatusDeleteArgs<ExtArgs>>
    ): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ObjectStatus.
     * @param {ObjectStatusUpdateArgs} args - Arguments to update one ObjectStatus.
     * @example
     * // Update one ObjectStatus
     * const objectStatus = await prisma.objectStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectStatusUpdateArgs<ExtArgs>>
    ): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ObjectStatuses.
     * @param {ObjectStatusDeleteManyArgs} args - Arguments to filter ObjectStatuses to delete.
     * @example
     * // Delete a few ObjectStatuses
     * const { count } = await prisma.objectStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjectStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjectStatuses
     * const objectStatus = await prisma.objectStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjectStatus.
     * @param {ObjectStatusUpsertArgs} args - Arguments to update or create a ObjectStatus.
     * @example
     * // Update or create a ObjectStatus
     * const objectStatus = await prisma.objectStatus.upsert({
     *   create: {
     *     // ... data to create a ObjectStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjectStatus we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectStatusUpsertArgs<ExtArgs>>
    ): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ObjectStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectStatusCountArgs} args - Arguments to filter ObjectStatuses to count.
     * @example
     * // Count the number of ObjectStatuses
     * const count = await prisma.objectStatus.count({
     *   where: {
     *     // ... the filter for the ObjectStatuses we want to count
     *   }
     * })
    **/
    count<T extends ObjectStatusCountArgs>(
      args?: Subset<T, ObjectStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjectStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectStatusAggregateArgs>(args: Subset<T, ObjectStatusAggregateArgs>): Prisma.PrismaPromise<GetObjectStatusAggregateType<T>>

    /**
     * Group by ObjectStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectStatusGroupByArgs['orderBy'] }
        : { orderBy?: ObjectStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjectStatus model
   */
  readonly fields: ObjectStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjectStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends ObjectStatus$objectArgs<ExtArgs> = {}>(args?: Subset<T, ObjectStatus$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ObjectStatus model
   */ 
  interface ObjectStatusFieldRefs {
    readonly id: FieldRef<"ObjectStatus", 'Int'>
    readonly name: FieldRef<"ObjectStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ObjectStatus findUnique
   */
  export type ObjectStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ObjectStatus to fetch.
     */
    where: ObjectStatusWhereUniqueInput
  }

  /**
   * ObjectStatus findUniqueOrThrow
   */
  export type ObjectStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ObjectStatus to fetch.
     */
    where: ObjectStatusWhereUniqueInput
  }

  /**
   * ObjectStatus findFirst
   */
  export type ObjectStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ObjectStatus to fetch.
     */
    where?: ObjectStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectStatuses to fetch.
     */
    orderBy?: ObjectStatusOrderByWithRelationInput | ObjectStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectStatuses.
     */
    cursor?: ObjectStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectStatuses.
     */
    distinct?: ObjectStatusScalarFieldEnum | ObjectStatusScalarFieldEnum[]
  }

  /**
   * ObjectStatus findFirstOrThrow
   */
  export type ObjectStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ObjectStatus to fetch.
     */
    where?: ObjectStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectStatuses to fetch.
     */
    orderBy?: ObjectStatusOrderByWithRelationInput | ObjectStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectStatuses.
     */
    cursor?: ObjectStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectStatuses.
     */
    distinct?: ObjectStatusScalarFieldEnum | ObjectStatusScalarFieldEnum[]
  }

  /**
   * ObjectStatus findMany
   */
  export type ObjectStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ObjectStatuses to fetch.
     */
    where?: ObjectStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectStatuses to fetch.
     */
    orderBy?: ObjectStatusOrderByWithRelationInput | ObjectStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjectStatuses.
     */
    cursor?: ObjectStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectStatuses.
     */
    skip?: number
    distinct?: ObjectStatusScalarFieldEnum | ObjectStatusScalarFieldEnum[]
  }

  /**
   * ObjectStatus create
   */
  export type ObjectStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjectStatus.
     */
    data: XOR<ObjectStatusCreateInput, ObjectStatusUncheckedCreateInput>
  }

  /**
   * ObjectStatus createMany
   */
  export type ObjectStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjectStatuses.
     */
    data: ObjectStatusCreateManyInput | ObjectStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObjectStatus update
   */
  export type ObjectStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjectStatus.
     */
    data: XOR<ObjectStatusUpdateInput, ObjectStatusUncheckedUpdateInput>
    /**
     * Choose, which ObjectStatus to update.
     */
    where: ObjectStatusWhereUniqueInput
  }

  /**
   * ObjectStatus updateMany
   */
  export type ObjectStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjectStatuses.
     */
    data: XOR<ObjectStatusUpdateManyMutationInput, ObjectStatusUncheckedUpdateManyInput>
    /**
     * Filter which ObjectStatuses to update
     */
    where?: ObjectStatusWhereInput
  }

  /**
   * ObjectStatus upsert
   */
  export type ObjectStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjectStatus to update in case it exists.
     */
    where: ObjectStatusWhereUniqueInput
    /**
     * In case the ObjectStatus found by the `where` argument doesn't exist, create a new ObjectStatus with this data.
     */
    create: XOR<ObjectStatusCreateInput, ObjectStatusUncheckedCreateInput>
    /**
     * In case the ObjectStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectStatusUpdateInput, ObjectStatusUncheckedUpdateInput>
  }

  /**
   * ObjectStatus delete
   */
  export type ObjectStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    /**
     * Filter which ObjectStatus to delete.
     */
    where: ObjectStatusWhereUniqueInput
  }

  /**
   * ObjectStatus deleteMany
   */
  export type ObjectStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectStatuses to delete
     */
    where?: ObjectStatusWhereInput
  }

  /**
   * ObjectStatus.object
   */
  export type ObjectStatus$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * ObjectStatus without action
   */
  export type ObjectStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    id: number | null
  }

  export type CurrencySumAggregateOutputType = {
    id: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: number | null
    name: string | null
    rate: string | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    rate: string | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    name: number
    rate: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    id?: true
  }

  export type CurrencySumAggregateInputType = {
    id?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    name?: true
    rate?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    name?: true
    rate?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: number
    name: string
    rate: string
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rate?: boolean
    object?: boolean | Currency$objectArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    name?: boolean
    rate?: boolean
  }


  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | Currency$objectArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      rate: string
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }


  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CurrencyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>
    ): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Currency that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CurrencyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>
    ): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CurrencyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
    **/
    create<T extends CurrencyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>
    ): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Currencies.
     *     @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     *     @example
     *     // Create many Currencies
     *     const currency = await prisma.currency.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CurrencyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
    **/
    delete<T extends CurrencyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>
    ): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CurrencyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>
    ): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CurrencyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CurrencyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
    **/
    upsert<T extends CurrencyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>
    ): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends Currency$objectArgs<ExtArgs> = {}>(args?: Subset<T, Currency$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Currency model
   */ 
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'Int'>
    readonly name: FieldRef<"Currency", 'String'>
    readonly rate: FieldRef<"Currency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
  }

  /**
   * Currency.object
   */
  export type Currency$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model Renovation
   */

  export type AggregateRenovation = {
    _count: RenovationCountAggregateOutputType | null
    _avg: RenovationAvgAggregateOutputType | null
    _sum: RenovationSumAggregateOutputType | null
    _min: RenovationMinAggregateOutputType | null
    _max: RenovationMaxAggregateOutputType | null
  }

  export type RenovationAvgAggregateOutputType = {
    id: number | null
  }

  export type RenovationSumAggregateOutputType = {
    id: number | null
  }

  export type RenovationMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RenovationMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RenovationCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RenovationAvgAggregateInputType = {
    id?: true
  }

  export type RenovationSumAggregateInputType = {
    id?: true
  }

  export type RenovationMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RenovationMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RenovationCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RenovationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Renovation to aggregate.
     */
    where?: RenovationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Renovations to fetch.
     */
    orderBy?: RenovationOrderByWithRelationInput | RenovationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RenovationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Renovations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Renovations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Renovations
    **/
    _count?: true | RenovationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RenovationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RenovationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RenovationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RenovationMaxAggregateInputType
  }

  export type GetRenovationAggregateType<T extends RenovationAggregateArgs> = {
        [P in keyof T & keyof AggregateRenovation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRenovation[P]>
      : GetScalarType<T[P], AggregateRenovation[P]>
  }




  export type RenovationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RenovationWhereInput
    orderBy?: RenovationOrderByWithAggregationInput | RenovationOrderByWithAggregationInput[]
    by: RenovationScalarFieldEnum[] | RenovationScalarFieldEnum
    having?: RenovationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RenovationCountAggregateInputType | true
    _avg?: RenovationAvgAggregateInputType
    _sum?: RenovationSumAggregateInputType
    _min?: RenovationMinAggregateInputType
    _max?: RenovationMaxAggregateInputType
  }

  export type RenovationGroupByOutputType = {
    id: number
    name: string
    _count: RenovationCountAggregateOutputType | null
    _avg: RenovationAvgAggregateOutputType | null
    _sum: RenovationSumAggregateOutputType | null
    _min: RenovationMinAggregateOutputType | null
    _max: RenovationMaxAggregateOutputType | null
  }

  type GetRenovationGroupByPayload<T extends RenovationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RenovationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RenovationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RenovationGroupByOutputType[P]>
            : GetScalarType<T[P], RenovationGroupByOutputType[P]>
        }
      >
    >


  export type RenovationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    object?: boolean | Renovation$objectArgs<ExtArgs>
    _count?: boolean | RenovationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["renovation"]>

  export type RenovationSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type RenovationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | Renovation$objectArgs<ExtArgs>
    _count?: boolean | RenovationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RenovationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Renovation"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["renovation"]>
    composites: {}
  }


  type RenovationGetPayload<S extends boolean | null | undefined | RenovationDefaultArgs> = $Result.GetResult<Prisma.$RenovationPayload, S>

  type RenovationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RenovationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RenovationCountAggregateInputType | true
    }

  export interface RenovationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Renovation'], meta: { name: 'Renovation' } }
    /**
     * Find zero or one Renovation that matches the filter.
     * @param {RenovationFindUniqueArgs} args - Arguments to find a Renovation
     * @example
     * // Get one Renovation
     * const renovation = await prisma.renovation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RenovationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RenovationFindUniqueArgs<ExtArgs>>
    ): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Renovation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RenovationFindUniqueOrThrowArgs} args - Arguments to find a Renovation
     * @example
     * // Get one Renovation
     * const renovation = await prisma.renovation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RenovationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RenovationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Renovation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenovationFindFirstArgs} args - Arguments to find a Renovation
     * @example
     * // Get one Renovation
     * const renovation = await prisma.renovation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RenovationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RenovationFindFirstArgs<ExtArgs>>
    ): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Renovation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenovationFindFirstOrThrowArgs} args - Arguments to find a Renovation
     * @example
     * // Get one Renovation
     * const renovation = await prisma.renovation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RenovationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RenovationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Renovations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenovationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Renovations
     * const renovations = await prisma.renovation.findMany()
     * 
     * // Get first 10 Renovations
     * const renovations = await prisma.renovation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const renovationWithIdOnly = await prisma.renovation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RenovationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RenovationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Renovation.
     * @param {RenovationCreateArgs} args - Arguments to create a Renovation.
     * @example
     * // Create one Renovation
     * const Renovation = await prisma.renovation.create({
     *   data: {
     *     // ... data to create a Renovation
     *   }
     * })
     * 
    **/
    create<T extends RenovationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RenovationCreateArgs<ExtArgs>>
    ): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Renovations.
     *     @param {RenovationCreateManyArgs} args - Arguments to create many Renovations.
     *     @example
     *     // Create many Renovations
     *     const renovation = await prisma.renovation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RenovationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RenovationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Renovation.
     * @param {RenovationDeleteArgs} args - Arguments to delete one Renovation.
     * @example
     * // Delete one Renovation
     * const Renovation = await prisma.renovation.delete({
     *   where: {
     *     // ... filter to delete one Renovation
     *   }
     * })
     * 
    **/
    delete<T extends RenovationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RenovationDeleteArgs<ExtArgs>>
    ): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Renovation.
     * @param {RenovationUpdateArgs} args - Arguments to update one Renovation.
     * @example
     * // Update one Renovation
     * const renovation = await prisma.renovation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RenovationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RenovationUpdateArgs<ExtArgs>>
    ): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Renovations.
     * @param {RenovationDeleteManyArgs} args - Arguments to filter Renovations to delete.
     * @example
     * // Delete a few Renovations
     * const { count } = await prisma.renovation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RenovationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RenovationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Renovations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenovationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Renovations
     * const renovation = await prisma.renovation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RenovationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RenovationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Renovation.
     * @param {RenovationUpsertArgs} args - Arguments to update or create a Renovation.
     * @example
     * // Update or create a Renovation
     * const renovation = await prisma.renovation.upsert({
     *   create: {
     *     // ... data to create a Renovation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Renovation we want to update
     *   }
     * })
    **/
    upsert<T extends RenovationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RenovationUpsertArgs<ExtArgs>>
    ): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Renovations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenovationCountArgs} args - Arguments to filter Renovations to count.
     * @example
     * // Count the number of Renovations
     * const count = await prisma.renovation.count({
     *   where: {
     *     // ... the filter for the Renovations we want to count
     *   }
     * })
    **/
    count<T extends RenovationCountArgs>(
      args?: Subset<T, RenovationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RenovationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Renovation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenovationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RenovationAggregateArgs>(args: Subset<T, RenovationAggregateArgs>): Prisma.PrismaPromise<GetRenovationAggregateType<T>>

    /**
     * Group by Renovation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RenovationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RenovationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RenovationGroupByArgs['orderBy'] }
        : { orderBy?: RenovationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RenovationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRenovationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Renovation model
   */
  readonly fields: RenovationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Renovation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RenovationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends Renovation$objectArgs<ExtArgs> = {}>(args?: Subset<T, Renovation$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Renovation model
   */ 
  interface RenovationFieldRefs {
    readonly id: FieldRef<"Renovation", 'Int'>
    readonly name: FieldRef<"Renovation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Renovation findUnique
   */
  export type RenovationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * Filter, which Renovation to fetch.
     */
    where: RenovationWhereUniqueInput
  }

  /**
   * Renovation findUniqueOrThrow
   */
  export type RenovationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * Filter, which Renovation to fetch.
     */
    where: RenovationWhereUniqueInput
  }

  /**
   * Renovation findFirst
   */
  export type RenovationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * Filter, which Renovation to fetch.
     */
    where?: RenovationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Renovations to fetch.
     */
    orderBy?: RenovationOrderByWithRelationInput | RenovationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Renovations.
     */
    cursor?: RenovationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Renovations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Renovations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Renovations.
     */
    distinct?: RenovationScalarFieldEnum | RenovationScalarFieldEnum[]
  }

  /**
   * Renovation findFirstOrThrow
   */
  export type RenovationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * Filter, which Renovation to fetch.
     */
    where?: RenovationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Renovations to fetch.
     */
    orderBy?: RenovationOrderByWithRelationInput | RenovationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Renovations.
     */
    cursor?: RenovationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Renovations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Renovations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Renovations.
     */
    distinct?: RenovationScalarFieldEnum | RenovationScalarFieldEnum[]
  }

  /**
   * Renovation findMany
   */
  export type RenovationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * Filter, which Renovations to fetch.
     */
    where?: RenovationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Renovations to fetch.
     */
    orderBy?: RenovationOrderByWithRelationInput | RenovationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Renovations.
     */
    cursor?: RenovationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Renovations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Renovations.
     */
    skip?: number
    distinct?: RenovationScalarFieldEnum | RenovationScalarFieldEnum[]
  }

  /**
   * Renovation create
   */
  export type RenovationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * The data needed to create a Renovation.
     */
    data: XOR<RenovationCreateInput, RenovationUncheckedCreateInput>
  }

  /**
   * Renovation createMany
   */
  export type RenovationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Renovations.
     */
    data: RenovationCreateManyInput | RenovationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Renovation update
   */
  export type RenovationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * The data needed to update a Renovation.
     */
    data: XOR<RenovationUpdateInput, RenovationUncheckedUpdateInput>
    /**
     * Choose, which Renovation to update.
     */
    where: RenovationWhereUniqueInput
  }

  /**
   * Renovation updateMany
   */
  export type RenovationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Renovations.
     */
    data: XOR<RenovationUpdateManyMutationInput, RenovationUncheckedUpdateManyInput>
    /**
     * Filter which Renovations to update
     */
    where?: RenovationWhereInput
  }

  /**
   * Renovation upsert
   */
  export type RenovationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * The filter to search for the Renovation to update in case it exists.
     */
    where: RenovationWhereUniqueInput
    /**
     * In case the Renovation found by the `where` argument doesn't exist, create a new Renovation with this data.
     */
    create: XOR<RenovationCreateInput, RenovationUncheckedCreateInput>
    /**
     * In case the Renovation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RenovationUpdateInput, RenovationUncheckedUpdateInput>
  }

  /**
   * Renovation delete
   */
  export type RenovationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    /**
     * Filter which Renovation to delete.
     */
    where: RenovationWhereUniqueInput
  }

  /**
   * Renovation deleteMany
   */
  export type RenovationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Renovations to delete
     */
    where?: RenovationWhereInput
  }

  /**
   * Renovation.object
   */
  export type Renovation$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Renovation without action
   */
  export type RenovationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
  }


  /**
   * Model WindowSide
   */

  export type AggregateWindowSide = {
    _count: WindowSideCountAggregateOutputType | null
    _avg: WindowSideAvgAggregateOutputType | null
    _sum: WindowSideSumAggregateOutputType | null
    _min: WindowSideMinAggregateOutputType | null
    _max: WindowSideMaxAggregateOutputType | null
  }

  export type WindowSideAvgAggregateOutputType = {
    id: number | null
  }

  export type WindowSideSumAggregateOutputType = {
    id: number | null
  }

  export type WindowSideMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type WindowSideMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type WindowSideCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type WindowSideAvgAggregateInputType = {
    id?: true
  }

  export type WindowSideSumAggregateInputType = {
    id?: true
  }

  export type WindowSideMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type WindowSideMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type WindowSideCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type WindowSideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WindowSide to aggregate.
     */
    where?: WindowSideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WindowSides to fetch.
     */
    orderBy?: WindowSideOrderByWithRelationInput | WindowSideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WindowSideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WindowSides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WindowSides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WindowSides
    **/
    _count?: true | WindowSideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WindowSideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WindowSideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WindowSideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WindowSideMaxAggregateInputType
  }

  export type GetWindowSideAggregateType<T extends WindowSideAggregateArgs> = {
        [P in keyof T & keyof AggregateWindowSide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWindowSide[P]>
      : GetScalarType<T[P], AggregateWindowSide[P]>
  }




  export type WindowSideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WindowSideWhereInput
    orderBy?: WindowSideOrderByWithAggregationInput | WindowSideOrderByWithAggregationInput[]
    by: WindowSideScalarFieldEnum[] | WindowSideScalarFieldEnum
    having?: WindowSideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WindowSideCountAggregateInputType | true
    _avg?: WindowSideAvgAggregateInputType
    _sum?: WindowSideSumAggregateInputType
    _min?: WindowSideMinAggregateInputType
    _max?: WindowSideMaxAggregateInputType
  }

  export type WindowSideGroupByOutputType = {
    id: number
    name: string
    _count: WindowSideCountAggregateOutputType | null
    _avg: WindowSideAvgAggregateOutputType | null
    _sum: WindowSideSumAggregateOutputType | null
    _min: WindowSideMinAggregateOutputType | null
    _max: WindowSideMaxAggregateOutputType | null
  }

  type GetWindowSideGroupByPayload<T extends WindowSideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WindowSideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WindowSideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WindowSideGroupByOutputType[P]>
            : GetScalarType<T[P], WindowSideGroupByOutputType[P]>
        }
      >
    >


  export type WindowSideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    object?: boolean | WindowSide$objectArgs<ExtArgs>
    _count?: boolean | WindowSideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["windowSide"]>

  export type WindowSideSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type WindowSideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | WindowSide$objectArgs<ExtArgs>
    _count?: boolean | WindowSideCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WindowSidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WindowSide"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["windowSide"]>
    composites: {}
  }


  type WindowSideGetPayload<S extends boolean | null | undefined | WindowSideDefaultArgs> = $Result.GetResult<Prisma.$WindowSidePayload, S>

  type WindowSideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WindowSideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WindowSideCountAggregateInputType | true
    }

  export interface WindowSideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WindowSide'], meta: { name: 'WindowSide' } }
    /**
     * Find zero or one WindowSide that matches the filter.
     * @param {WindowSideFindUniqueArgs} args - Arguments to find a WindowSide
     * @example
     * // Get one WindowSide
     * const windowSide = await prisma.windowSide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WindowSideFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WindowSideFindUniqueArgs<ExtArgs>>
    ): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WindowSide that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WindowSideFindUniqueOrThrowArgs} args - Arguments to find a WindowSide
     * @example
     * // Get one WindowSide
     * const windowSide = await prisma.windowSide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WindowSideFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WindowSideFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WindowSide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WindowSideFindFirstArgs} args - Arguments to find a WindowSide
     * @example
     * // Get one WindowSide
     * const windowSide = await prisma.windowSide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WindowSideFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WindowSideFindFirstArgs<ExtArgs>>
    ): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WindowSide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WindowSideFindFirstOrThrowArgs} args - Arguments to find a WindowSide
     * @example
     * // Get one WindowSide
     * const windowSide = await prisma.windowSide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WindowSideFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WindowSideFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WindowSides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WindowSideFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WindowSides
     * const windowSides = await prisma.windowSide.findMany()
     * 
     * // Get first 10 WindowSides
     * const windowSides = await prisma.windowSide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const windowSideWithIdOnly = await prisma.windowSide.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WindowSideFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WindowSideFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WindowSide.
     * @param {WindowSideCreateArgs} args - Arguments to create a WindowSide.
     * @example
     * // Create one WindowSide
     * const WindowSide = await prisma.windowSide.create({
     *   data: {
     *     // ... data to create a WindowSide
     *   }
     * })
     * 
    **/
    create<T extends WindowSideCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WindowSideCreateArgs<ExtArgs>>
    ): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WindowSides.
     *     @param {WindowSideCreateManyArgs} args - Arguments to create many WindowSides.
     *     @example
     *     // Create many WindowSides
     *     const windowSide = await prisma.windowSide.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WindowSideCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WindowSideCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WindowSide.
     * @param {WindowSideDeleteArgs} args - Arguments to delete one WindowSide.
     * @example
     * // Delete one WindowSide
     * const WindowSide = await prisma.windowSide.delete({
     *   where: {
     *     // ... filter to delete one WindowSide
     *   }
     * })
     * 
    **/
    delete<T extends WindowSideDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WindowSideDeleteArgs<ExtArgs>>
    ): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WindowSide.
     * @param {WindowSideUpdateArgs} args - Arguments to update one WindowSide.
     * @example
     * // Update one WindowSide
     * const windowSide = await prisma.windowSide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WindowSideUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WindowSideUpdateArgs<ExtArgs>>
    ): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WindowSides.
     * @param {WindowSideDeleteManyArgs} args - Arguments to filter WindowSides to delete.
     * @example
     * // Delete a few WindowSides
     * const { count } = await prisma.windowSide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WindowSideDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WindowSideDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WindowSides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WindowSideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WindowSides
     * const windowSide = await prisma.windowSide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WindowSideUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WindowSideUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WindowSide.
     * @param {WindowSideUpsertArgs} args - Arguments to update or create a WindowSide.
     * @example
     * // Update or create a WindowSide
     * const windowSide = await prisma.windowSide.upsert({
     *   create: {
     *     // ... data to create a WindowSide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WindowSide we want to update
     *   }
     * })
    **/
    upsert<T extends WindowSideUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WindowSideUpsertArgs<ExtArgs>>
    ): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WindowSides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WindowSideCountArgs} args - Arguments to filter WindowSides to count.
     * @example
     * // Count the number of WindowSides
     * const count = await prisma.windowSide.count({
     *   where: {
     *     // ... the filter for the WindowSides we want to count
     *   }
     * })
    **/
    count<T extends WindowSideCountArgs>(
      args?: Subset<T, WindowSideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WindowSideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WindowSide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WindowSideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WindowSideAggregateArgs>(args: Subset<T, WindowSideAggregateArgs>): Prisma.PrismaPromise<GetWindowSideAggregateType<T>>

    /**
     * Group by WindowSide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WindowSideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WindowSideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WindowSideGroupByArgs['orderBy'] }
        : { orderBy?: WindowSideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WindowSideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWindowSideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WindowSide model
   */
  readonly fields: WindowSideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WindowSide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WindowSideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends WindowSide$objectArgs<ExtArgs> = {}>(args?: Subset<T, WindowSide$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WindowSide model
   */ 
  interface WindowSideFieldRefs {
    readonly id: FieldRef<"WindowSide", 'Int'>
    readonly name: FieldRef<"WindowSide", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WindowSide findUnique
   */
  export type WindowSideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * Filter, which WindowSide to fetch.
     */
    where: WindowSideWhereUniqueInput
  }

  /**
   * WindowSide findUniqueOrThrow
   */
  export type WindowSideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * Filter, which WindowSide to fetch.
     */
    where: WindowSideWhereUniqueInput
  }

  /**
   * WindowSide findFirst
   */
  export type WindowSideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * Filter, which WindowSide to fetch.
     */
    where?: WindowSideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WindowSides to fetch.
     */
    orderBy?: WindowSideOrderByWithRelationInput | WindowSideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WindowSides.
     */
    cursor?: WindowSideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WindowSides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WindowSides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WindowSides.
     */
    distinct?: WindowSideScalarFieldEnum | WindowSideScalarFieldEnum[]
  }

  /**
   * WindowSide findFirstOrThrow
   */
  export type WindowSideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * Filter, which WindowSide to fetch.
     */
    where?: WindowSideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WindowSides to fetch.
     */
    orderBy?: WindowSideOrderByWithRelationInput | WindowSideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WindowSides.
     */
    cursor?: WindowSideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WindowSides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WindowSides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WindowSides.
     */
    distinct?: WindowSideScalarFieldEnum | WindowSideScalarFieldEnum[]
  }

  /**
   * WindowSide findMany
   */
  export type WindowSideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * Filter, which WindowSides to fetch.
     */
    where?: WindowSideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WindowSides to fetch.
     */
    orderBy?: WindowSideOrderByWithRelationInput | WindowSideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WindowSides.
     */
    cursor?: WindowSideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WindowSides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WindowSides.
     */
    skip?: number
    distinct?: WindowSideScalarFieldEnum | WindowSideScalarFieldEnum[]
  }

  /**
   * WindowSide create
   */
  export type WindowSideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * The data needed to create a WindowSide.
     */
    data: XOR<WindowSideCreateInput, WindowSideUncheckedCreateInput>
  }

  /**
   * WindowSide createMany
   */
  export type WindowSideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WindowSides.
     */
    data: WindowSideCreateManyInput | WindowSideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WindowSide update
   */
  export type WindowSideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * The data needed to update a WindowSide.
     */
    data: XOR<WindowSideUpdateInput, WindowSideUncheckedUpdateInput>
    /**
     * Choose, which WindowSide to update.
     */
    where: WindowSideWhereUniqueInput
  }

  /**
   * WindowSide updateMany
   */
  export type WindowSideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WindowSides.
     */
    data: XOR<WindowSideUpdateManyMutationInput, WindowSideUncheckedUpdateManyInput>
    /**
     * Filter which WindowSides to update
     */
    where?: WindowSideWhereInput
  }

  /**
   * WindowSide upsert
   */
  export type WindowSideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * The filter to search for the WindowSide to update in case it exists.
     */
    where: WindowSideWhereUniqueInput
    /**
     * In case the WindowSide found by the `where` argument doesn't exist, create a new WindowSide with this data.
     */
    create: XOR<WindowSideCreateInput, WindowSideUncheckedCreateInput>
    /**
     * In case the WindowSide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WindowSideUpdateInput, WindowSideUncheckedUpdateInput>
  }

  /**
   * WindowSide delete
   */
  export type WindowSideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    /**
     * Filter which WindowSide to delete.
     */
    where: WindowSideWhereUniqueInput
  }

  /**
   * WindowSide deleteMany
   */
  export type WindowSideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WindowSides to delete
     */
    where?: WindowSideWhereInput
  }

  /**
   * WindowSide.object
   */
  export type WindowSide$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * WindowSide without action
   */
  export type WindowSideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
  }


  /**
   * Model RoomType
   */

  export type AggregateRoomType = {
    _count: RoomTypeCountAggregateOutputType | null
    _avg: RoomTypeAvgAggregateOutputType | null
    _sum: RoomTypeSumAggregateOutputType | null
    _min: RoomTypeMinAggregateOutputType | null
    _max: RoomTypeMaxAggregateOutputType | null
  }

  export type RoomTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type RoomTypeSumAggregateOutputType = {
    id: number | null
  }

  export type RoomTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoomTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoomTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoomTypeAvgAggregateInputType = {
    id?: true
  }

  export type RoomTypeSumAggregateInputType = {
    id?: true
  }

  export type RoomTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoomTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoomTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoomTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomType to aggregate.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomTypes
    **/
    _count?: true | RoomTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomTypeMaxAggregateInputType
  }

  export type GetRoomTypeAggregateType<T extends RoomTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomType[P]>
      : GetScalarType<T[P], AggregateRoomType[P]>
  }




  export type RoomTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeWhereInput
    orderBy?: RoomTypeOrderByWithAggregationInput | RoomTypeOrderByWithAggregationInput[]
    by: RoomTypeScalarFieldEnum[] | RoomTypeScalarFieldEnum
    having?: RoomTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomTypeCountAggregateInputType | true
    _avg?: RoomTypeAvgAggregateInputType
    _sum?: RoomTypeSumAggregateInputType
    _min?: RoomTypeMinAggregateInputType
    _max?: RoomTypeMaxAggregateInputType
  }

  export type RoomTypeGroupByOutputType = {
    id: number
    name: string
    _count: RoomTypeCountAggregateOutputType | null
    _avg: RoomTypeAvgAggregateOutputType | null
    _sum: RoomTypeSumAggregateOutputType | null
    _min: RoomTypeMinAggregateOutputType | null
    _max: RoomTypeMaxAggregateOutputType | null
  }

  type GetRoomTypeGroupByPayload<T extends RoomTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RoomTypeGroupByOutputType[P]>
        }
      >
    >


  export type RoomTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    object?: boolean | RoomType$objectArgs<ExtArgs>
    _count?: boolean | RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomType"]>

  export type RoomTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type RoomTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    object?: boolean | RoomType$objectArgs<ExtArgs>
    _count?: boolean | RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RoomTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomType"
    objects: {
      object: Prisma.$ObjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roomType"]>
    composites: {}
  }


  type RoomTypeGetPayload<S extends boolean | null | undefined | RoomTypeDefaultArgs> = $Result.GetResult<Prisma.$RoomTypePayload, S>

  type RoomTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomTypeCountAggregateInputType | true
    }

  export interface RoomTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomType'], meta: { name: 'RoomType' } }
    /**
     * Find zero or one RoomType that matches the filter.
     * @param {RoomTypeFindUniqueArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomTypeFindUniqueOrThrowArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindFirstArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypeFindFirstArgs<ExtArgs>>
    ): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindFirstOrThrowArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomTypes
     * const roomTypes = await prisma.roomType.findMany()
     * 
     * // Get first 10 RoomTypes
     * const roomTypes = await prisma.roomType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomTypeWithIdOnly = await prisma.roomType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomType.
     * @param {RoomTypeCreateArgs} args - Arguments to create a RoomType.
     * @example
     * // Create one RoomType
     * const RoomType = await prisma.roomType.create({
     *   data: {
     *     // ... data to create a RoomType
     *   }
     * })
     * 
    **/
    create<T extends RoomTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypeCreateArgs<ExtArgs>>
    ): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomTypes.
     *     @param {RoomTypeCreateManyArgs} args - Arguments to create many RoomTypes.
     *     @example
     *     // Create many RoomTypes
     *     const roomType = await prisma.roomType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomType.
     * @param {RoomTypeDeleteArgs} args - Arguments to delete one RoomType.
     * @example
     * // Delete one RoomType
     * const RoomType = await prisma.roomType.delete({
     *   where: {
     *     // ... filter to delete one RoomType
     *   }
     * })
     * 
    **/
    delete<T extends RoomTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypeDeleteArgs<ExtArgs>>
    ): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomType.
     * @param {RoomTypeUpdateArgs} args - Arguments to update one RoomType.
     * @example
     * // Update one RoomType
     * const roomType = await prisma.roomType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypeUpdateArgs<ExtArgs>>
    ): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomTypes.
     * @param {RoomTypeDeleteManyArgs} args - Arguments to filter RoomTypes to delete.
     * @example
     * // Delete a few RoomTypes
     * const { count } = await prisma.roomType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomTypes
     * const roomType = await prisma.roomType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomType.
     * @param {RoomTypeUpsertArgs} args - Arguments to update or create a RoomType.
     * @example
     * // Update or create a RoomType
     * const roomType = await prisma.roomType.upsert({
     *   create: {
     *     // ... data to create a RoomType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomType we want to update
     *   }
     * })
    **/
    upsert<T extends RoomTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomTypeUpsertArgs<ExtArgs>>
    ): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeCountArgs} args - Arguments to filter RoomTypes to count.
     * @example
     * // Count the number of RoomTypes
     * const count = await prisma.roomType.count({
     *   where: {
     *     // ... the filter for the RoomTypes we want to count
     *   }
     * })
    **/
    count<T extends RoomTypeCountArgs>(
      args?: Subset<T, RoomTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomTypeAggregateArgs>(args: Subset<T, RoomTypeAggregateArgs>): Prisma.PrismaPromise<GetRoomTypeAggregateType<T>>

    /**
     * Group by RoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomTypeGroupByArgs['orderBy'] }
        : { orderBy?: RoomTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomType model
   */
  readonly fields: RoomTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    object<T extends RoomType$objectArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$objectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomType model
   */ 
  interface RoomTypeFieldRefs {
    readonly id: FieldRef<"RoomType", 'Int'>
    readonly name: FieldRef<"RoomType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoomType findUnique
   */
  export type RoomTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType findUniqueOrThrow
   */
  export type RoomTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType findFirst
   */
  export type RoomTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType findFirstOrThrow
   */
  export type RoomTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType findMany
   */
  export type RoomTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType create
   */
  export type RoomTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomType.
     */
    data: XOR<RoomTypeCreateInput, RoomTypeUncheckedCreateInput>
  }

  /**
   * RoomType createMany
   */
  export type RoomTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomTypes.
     */
    data: RoomTypeCreateManyInput | RoomTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomType update
   */
  export type RoomTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomType.
     */
    data: XOR<RoomTypeUpdateInput, RoomTypeUncheckedUpdateInput>
    /**
     * Choose, which RoomType to update.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType updateMany
   */
  export type RoomTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomTypes.
     */
    data: XOR<RoomTypeUpdateManyMutationInput, RoomTypeUncheckedUpdateManyInput>
    /**
     * Filter which RoomTypes to update
     */
    where?: RoomTypeWhereInput
  }

  /**
   * RoomType upsert
   */
  export type RoomTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomType to update in case it exists.
     */
    where: RoomTypeWhereUniqueInput
    /**
     * In case the RoomType found by the `where` argument doesn't exist, create a new RoomType with this data.
     */
    create: XOR<RoomTypeCreateInput, RoomTypeUncheckedCreateInput>
    /**
     * In case the RoomType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomTypeUpdateInput, RoomTypeUncheckedUpdateInput>
  }

  /**
   * RoomType delete
   */
  export type RoomTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter which RoomType to delete.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType deleteMany
   */
  export type RoomTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTypes to delete
     */
    where?: RoomTypeWhereInput
  }

  /**
   * RoomType.object
   */
  export type RoomType$objectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    cursor?: ObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * RoomType without action
   */
  export type RoomTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
  }


  /**
   * Model Object
   */

  export type AggregateObject = {
    _count: ObjectCountAggregateOutputType | null
    _avg: ObjectAvgAggregateOutputType | null
    _sum: ObjectSumAggregateOutputType | null
    _min: ObjectMinAggregateOutputType | null
    _max: ObjectMaxAggregateOutputType | null
  }

  export type ObjectAvgAggregateOutputType = {
    id: number | null
    realtorId: number | null
    objectTypeId: number | null
    residenceTypeId: number | null
    objectCategoryId: number | null
    objectStatusId: number | null
    floor: number | null
    floors_in_building: number | null
    total_area: number | null
    live_area: number | null
    kitchen_area: number | null
    rooms_area: number | null
    price: number | null
    currencyId: number | null
    price_per_square: number | null
    price_type: number | null
    renovationId: number | null
    windowSideId: number | null
    roomTypeId: number | null
    ceiling_height: number | null
    combined_bath_count: number | null
    separate_bath_count: number | null
    loggia_count: number | null
    balcony_count: number | null
    cadastral_number: number | null
  }

  export type ObjectSumAggregateOutputType = {
    id: number | null
    realtorId: number | null
    objectTypeId: number | null
    residenceTypeId: number | null
    objectCategoryId: number | null
    objectStatusId: number | null
    floor: number | null
    floors_in_building: number | null
    total_area: number | null
    live_area: number | null
    kitchen_area: number | null
    rooms_area: number | null
    price: number | null
    currencyId: number | null
    price_per_square: number | null
    price_type: number | null
    renovationId: number | null
    windowSideId: number | null
    roomTypeId: number | null
    ceiling_height: number | null
    combined_bath_count: number | null
    separate_bath_count: number | null
    loggia_count: number | null
    balcony_count: number | null
    cadastral_number: number | null
  }

  export type ObjectMinAggregateOutputType = {
    id: number | null
    name: string | null
    realtorId: number | null
    objectTypeId: number | null
    residenceTypeId: number | null
    objectCategoryId: number | null
    objectStatusId: number | null
    is_studio: boolean | null
    floor: number | null
    floors_in_building: number | null
    total_area: number | null
    live_area: number | null
    kitchen_area: number | null
    rooms_area: number | null
    price: number | null
    currencyId: number | null
    price_per_square: number | null
    price_type: number | null
    renovationId: number | null
    windowSideId: number | null
    roomTypeId: number | null
    is_apartment: boolean | null
    is_luxury: boolean | null
    ceiling_height: number | null
    combined_bath_count: number | null
    separate_bath_count: number | null
    loggia_count: number | null
    loggia_description: string | null
    balcony_count: number | null
    balcony_description: string | null
    general_description: string | null
    cadastral_number: number | null
    document: string | null
    layout: string | null
    fotos: string | null
    online_show: boolean | null
    video: string | null
  }

  export type ObjectMaxAggregateOutputType = {
    id: number | null
    name: string | null
    realtorId: number | null
    objectTypeId: number | null
    residenceTypeId: number | null
    objectCategoryId: number | null
    objectStatusId: number | null
    is_studio: boolean | null
    floor: number | null
    floors_in_building: number | null
    total_area: number | null
    live_area: number | null
    kitchen_area: number | null
    rooms_area: number | null
    price: number | null
    currencyId: number | null
    price_per_square: number | null
    price_type: number | null
    renovationId: number | null
    windowSideId: number | null
    roomTypeId: number | null
    is_apartment: boolean | null
    is_luxury: boolean | null
    ceiling_height: number | null
    combined_bath_count: number | null
    separate_bath_count: number | null
    loggia_count: number | null
    loggia_description: string | null
    balcony_count: number | null
    balcony_description: string | null
    general_description: string | null
    cadastral_number: number | null
    document: string | null
    layout: string | null
    fotos: string | null
    online_show: boolean | null
    video: string | null
  }

  export type ObjectCountAggregateOutputType = {
    id: number
    name: number
    realtorId: number
    objectTypeId: number
    residenceTypeId: number
    objectCategoryId: number
    objectStatusId: number
    is_studio: number
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId: number
    price_per_square: number
    price_type: number
    renovationId: number
    windowSideId: number
    roomTypeId: number
    is_apartment: number
    is_luxury: number
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: number
    balcony_count: number
    balcony_description: number
    general_description: number
    cadastral_number: number
    document: number
    layout: number
    fotos: number
    online_show: number
    video: number
    _all: number
  }


  export type ObjectAvgAggregateInputType = {
    id?: true
    realtorId?: true
    objectTypeId?: true
    residenceTypeId?: true
    objectCategoryId?: true
    objectStatusId?: true
    floor?: true
    floors_in_building?: true
    total_area?: true
    live_area?: true
    kitchen_area?: true
    rooms_area?: true
    price?: true
    currencyId?: true
    price_per_square?: true
    price_type?: true
    renovationId?: true
    windowSideId?: true
    roomTypeId?: true
    ceiling_height?: true
    combined_bath_count?: true
    separate_bath_count?: true
    loggia_count?: true
    balcony_count?: true
    cadastral_number?: true
  }

  export type ObjectSumAggregateInputType = {
    id?: true
    realtorId?: true
    objectTypeId?: true
    residenceTypeId?: true
    objectCategoryId?: true
    objectStatusId?: true
    floor?: true
    floors_in_building?: true
    total_area?: true
    live_area?: true
    kitchen_area?: true
    rooms_area?: true
    price?: true
    currencyId?: true
    price_per_square?: true
    price_type?: true
    renovationId?: true
    windowSideId?: true
    roomTypeId?: true
    ceiling_height?: true
    combined_bath_count?: true
    separate_bath_count?: true
    loggia_count?: true
    balcony_count?: true
    cadastral_number?: true
  }

  export type ObjectMinAggregateInputType = {
    id?: true
    name?: true
    realtorId?: true
    objectTypeId?: true
    residenceTypeId?: true
    objectCategoryId?: true
    objectStatusId?: true
    is_studio?: true
    floor?: true
    floors_in_building?: true
    total_area?: true
    live_area?: true
    kitchen_area?: true
    rooms_area?: true
    price?: true
    currencyId?: true
    price_per_square?: true
    price_type?: true
    renovationId?: true
    windowSideId?: true
    roomTypeId?: true
    is_apartment?: true
    is_luxury?: true
    ceiling_height?: true
    combined_bath_count?: true
    separate_bath_count?: true
    loggia_count?: true
    loggia_description?: true
    balcony_count?: true
    balcony_description?: true
    general_description?: true
    cadastral_number?: true
    document?: true
    layout?: true
    fotos?: true
    online_show?: true
    video?: true
  }

  export type ObjectMaxAggregateInputType = {
    id?: true
    name?: true
    realtorId?: true
    objectTypeId?: true
    residenceTypeId?: true
    objectCategoryId?: true
    objectStatusId?: true
    is_studio?: true
    floor?: true
    floors_in_building?: true
    total_area?: true
    live_area?: true
    kitchen_area?: true
    rooms_area?: true
    price?: true
    currencyId?: true
    price_per_square?: true
    price_type?: true
    renovationId?: true
    windowSideId?: true
    roomTypeId?: true
    is_apartment?: true
    is_luxury?: true
    ceiling_height?: true
    combined_bath_count?: true
    separate_bath_count?: true
    loggia_count?: true
    loggia_description?: true
    balcony_count?: true
    balcony_description?: true
    general_description?: true
    cadastral_number?: true
    document?: true
    layout?: true
    fotos?: true
    online_show?: true
    video?: true
  }

  export type ObjectCountAggregateInputType = {
    id?: true
    name?: true
    realtorId?: true
    objectTypeId?: true
    residenceTypeId?: true
    objectCategoryId?: true
    objectStatusId?: true
    is_studio?: true
    floor?: true
    floors_in_building?: true
    total_area?: true
    live_area?: true
    kitchen_area?: true
    rooms_area?: true
    price?: true
    currencyId?: true
    price_per_square?: true
    price_type?: true
    renovationId?: true
    windowSideId?: true
    roomTypeId?: true
    is_apartment?: true
    is_luxury?: true
    ceiling_height?: true
    combined_bath_count?: true
    separate_bath_count?: true
    loggia_count?: true
    loggia_description?: true
    balcony_count?: true
    balcony_description?: true
    general_description?: true
    cadastral_number?: true
    document?: true
    layout?: true
    fotos?: true
    online_show?: true
    video?: true
    _all?: true
  }

  export type ObjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Object to aggregate.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Objects
    **/
    _count?: true | ObjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectMaxAggregateInputType
  }

  export type GetObjectAggregateType<T extends ObjectAggregateArgs> = {
        [P in keyof T & keyof AggregateObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObject[P]>
      : GetScalarType<T[P], AggregateObject[P]>
  }




  export type ObjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectWhereInput
    orderBy?: ObjectOrderByWithAggregationInput | ObjectOrderByWithAggregationInput[]
    by: ObjectScalarFieldEnum[] | ObjectScalarFieldEnum
    having?: ObjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectCountAggregateInputType | true
    _avg?: ObjectAvgAggregateInputType
    _sum?: ObjectSumAggregateInputType
    _min?: ObjectMinAggregateInputType
    _max?: ObjectMaxAggregateInputType
  }

  export type ObjectGroupByOutputType = {
    id: number
    name: string
    realtorId: number | null
    objectTypeId: number | null
    residenceTypeId: number | null
    objectCategoryId: number | null
    objectStatusId: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId: number | null
    price_per_square: number
    price_type: number
    renovationId: number | null
    windowSideId: number | null
    roomTypeId: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    _count: ObjectCountAggregateOutputType | null
    _avg: ObjectAvgAggregateOutputType | null
    _sum: ObjectSumAggregateOutputType | null
    _min: ObjectMinAggregateOutputType | null
    _max: ObjectMaxAggregateOutputType | null
  }

  type GetObjectGroupByPayload<T extends ObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectGroupByOutputType[P]>
        }
      >
    >


  export type ObjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    realtorId?: boolean
    objectTypeId?: boolean
    residenceTypeId?: boolean
    objectCategoryId?: boolean
    objectStatusId?: boolean
    is_studio?: boolean
    floor?: boolean
    floors_in_building?: boolean
    total_area?: boolean
    live_area?: boolean
    kitchen_area?: boolean
    rooms_area?: boolean
    price?: boolean
    currencyId?: boolean
    price_per_square?: boolean
    price_type?: boolean
    renovationId?: boolean
    windowSideId?: boolean
    roomTypeId?: boolean
    is_apartment?: boolean
    is_luxury?: boolean
    ceiling_height?: boolean
    combined_bath_count?: boolean
    separate_bath_count?: boolean
    loggia_count?: boolean
    loggia_description?: boolean
    balcony_count?: boolean
    balcony_description?: boolean
    general_description?: boolean
    cadastral_number?: boolean
    document?: boolean
    layout?: boolean
    fotos?: boolean
    online_show?: boolean
    video?: boolean
    Realtor?: boolean | Object$RealtorArgs<ExtArgs>
    ObjectType?: boolean | Object$ObjectTypeArgs<ExtArgs>
    ResidenceType?: boolean | Object$ResidenceTypeArgs<ExtArgs>
    ObjectCategory?: boolean | Object$ObjectCategoryArgs<ExtArgs>
    ObjectStatus?: boolean | Object$ObjectStatusArgs<ExtArgs>
    Currency?: boolean | Object$CurrencyArgs<ExtArgs>
    Renovation?: boolean | Object$RenovationArgs<ExtArgs>
    WindowSide?: boolean | Object$WindowSideArgs<ExtArgs>
    RoomType?: boolean | Object$RoomTypeArgs<ExtArgs>
  }, ExtArgs["result"]["object"]>

  export type ObjectSelectScalar = {
    id?: boolean
    name?: boolean
    realtorId?: boolean
    objectTypeId?: boolean
    residenceTypeId?: boolean
    objectCategoryId?: boolean
    objectStatusId?: boolean
    is_studio?: boolean
    floor?: boolean
    floors_in_building?: boolean
    total_area?: boolean
    live_area?: boolean
    kitchen_area?: boolean
    rooms_area?: boolean
    price?: boolean
    currencyId?: boolean
    price_per_square?: boolean
    price_type?: boolean
    renovationId?: boolean
    windowSideId?: boolean
    roomTypeId?: boolean
    is_apartment?: boolean
    is_luxury?: boolean
    ceiling_height?: boolean
    combined_bath_count?: boolean
    separate_bath_count?: boolean
    loggia_count?: boolean
    loggia_description?: boolean
    balcony_count?: boolean
    balcony_description?: boolean
    general_description?: boolean
    cadastral_number?: boolean
    document?: boolean
    layout?: boolean
    fotos?: boolean
    online_show?: boolean
    video?: boolean
  }


  export type ObjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Realtor?: boolean | Object$RealtorArgs<ExtArgs>
    ObjectType?: boolean | Object$ObjectTypeArgs<ExtArgs>
    ResidenceType?: boolean | Object$ResidenceTypeArgs<ExtArgs>
    ObjectCategory?: boolean | Object$ObjectCategoryArgs<ExtArgs>
    ObjectStatus?: boolean | Object$ObjectStatusArgs<ExtArgs>
    Currency?: boolean | Object$CurrencyArgs<ExtArgs>
    Renovation?: boolean | Object$RenovationArgs<ExtArgs>
    WindowSide?: boolean | Object$WindowSideArgs<ExtArgs>
    RoomType?: boolean | Object$RoomTypeArgs<ExtArgs>
  }


  export type $ObjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Object"
    objects: {
      Realtor: Prisma.$RealtorPayload<ExtArgs> | null
      ObjectType: Prisma.$ObjectTypePayload<ExtArgs> | null
      ResidenceType: Prisma.$ResidenceTypePayload<ExtArgs> | null
      ObjectCategory: Prisma.$ObjectCategoryPayload<ExtArgs> | null
      ObjectStatus: Prisma.$ObjectStatusPayload<ExtArgs> | null
      Currency: Prisma.$CurrencyPayload<ExtArgs> | null
      Renovation: Prisma.$RenovationPayload<ExtArgs> | null
      WindowSide: Prisma.$WindowSidePayload<ExtArgs> | null
      RoomType: Prisma.$RoomTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      realtorId: number | null
      objectTypeId: number | null
      residenceTypeId: number | null
      objectCategoryId: number | null
      objectStatusId: number | null
      is_studio: boolean
      floor: number
      floors_in_building: number
      total_area: number
      live_area: number
      kitchen_area: number
      rooms_area: number
      price: number
      currencyId: number | null
      price_per_square: number
      price_type: number
      renovationId: number | null
      windowSideId: number | null
      roomTypeId: number | null
      is_apartment: boolean
      is_luxury: boolean
      ceiling_height: number
      combined_bath_count: number
      separate_bath_count: number
      loggia_count: number
      loggia_description: string
      balcony_count: number
      balcony_description: string
      general_description: string
      cadastral_number: number
      document: string
      layout: string
      fotos: string
      online_show: boolean
      video: string
    }, ExtArgs["result"]["object"]>
    composites: {}
  }


  type ObjectGetPayload<S extends boolean | null | undefined | ObjectDefaultArgs> = $Result.GetResult<Prisma.$ObjectPayload, S>

  type ObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjectCountAggregateInputType | true
    }

  export interface ObjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Object'], meta: { name: 'Object' } }
    /**
     * Find zero or one Object that matches the filter.
     * @param {ObjectFindUniqueArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectFindUniqueArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Object that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectFindUniqueOrThrowArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Object that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindFirstArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindFirstArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Object that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindFirstOrThrowArgs} args - Arguments to find a Object
     * @example
     * // Get one Object
     * const object = await prisma.object.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Objects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objects
     * const objects = await prisma.object.findMany()
     * 
     * // Get first 10 Objects
     * const objects = await prisma.object.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectWithIdOnly = await prisma.object.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Object.
     * @param {ObjectCreateArgs} args - Arguments to create a Object.
     * @example
     * // Create one Object
     * const Object = await prisma.object.create({
     *   data: {
     *     // ... data to create a Object
     *   }
     * })
     * 
    **/
    create<T extends ObjectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectCreateArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Objects.
     *     @param {ObjectCreateManyArgs} args - Arguments to create many Objects.
     *     @example
     *     // Create many Objects
     *     const object = await prisma.object.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Object.
     * @param {ObjectDeleteArgs} args - Arguments to delete one Object.
     * @example
     * // Delete one Object
     * const Object = await prisma.object.delete({
     *   where: {
     *     // ... filter to delete one Object
     *   }
     * })
     * 
    **/
    delete<T extends ObjectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectDeleteArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Object.
     * @param {ObjectUpdateArgs} args - Arguments to update one Object.
     * @example
     * // Update one Object
     * const object = await prisma.object.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpdateArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Objects.
     * @param {ObjectDeleteManyArgs} args - Arguments to filter Objects to delete.
     * @example
     * // Delete a few Objects
     * const { count } = await prisma.object.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObjectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objects
     * const object = await prisma.object.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Object.
     * @param {ObjectUpsertArgs} args - Arguments to update or create a Object.
     * @example
     * // Update or create a Object
     * const object = await prisma.object.upsert({
     *   create: {
     *     // ... data to create a Object
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Object we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObjectUpsertArgs<ExtArgs>>
    ): Prisma__ObjectClient<$Result.GetResult<Prisma.$ObjectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Objects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectCountArgs} args - Arguments to filter Objects to count.
     * @example
     * // Count the number of Objects
     * const count = await prisma.object.count({
     *   where: {
     *     // ... the filter for the Objects we want to count
     *   }
     * })
    **/
    count<T extends ObjectCountArgs>(
      args?: Subset<T, ObjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Object.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectAggregateArgs>(args: Subset<T, ObjectAggregateArgs>): Prisma.PrismaPromise<GetObjectAggregateType<T>>

    /**
     * Group by Object.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectGroupByArgs['orderBy'] }
        : { orderBy?: ObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Object model
   */
  readonly fields: ObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Object.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Realtor<T extends Object$RealtorArgs<ExtArgs> = {}>(args?: Subset<T, Object$RealtorArgs<ExtArgs>>): Prisma__RealtorClient<$Result.GetResult<Prisma.$RealtorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ObjectType<T extends Object$ObjectTypeArgs<ExtArgs> = {}>(args?: Subset<T, Object$ObjectTypeArgs<ExtArgs>>): Prisma__ObjectTypeClient<$Result.GetResult<Prisma.$ObjectTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ResidenceType<T extends Object$ResidenceTypeArgs<ExtArgs> = {}>(args?: Subset<T, Object$ResidenceTypeArgs<ExtArgs>>): Prisma__ResidenceTypeClient<$Result.GetResult<Prisma.$ResidenceTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ObjectCategory<T extends Object$ObjectCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Object$ObjectCategoryArgs<ExtArgs>>): Prisma__ObjectCategoryClient<$Result.GetResult<Prisma.$ObjectCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ObjectStatus<T extends Object$ObjectStatusArgs<ExtArgs> = {}>(args?: Subset<T, Object$ObjectStatusArgs<ExtArgs>>): Prisma__ObjectStatusClient<$Result.GetResult<Prisma.$ObjectStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Currency<T extends Object$CurrencyArgs<ExtArgs> = {}>(args?: Subset<T, Object$CurrencyArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Renovation<T extends Object$RenovationArgs<ExtArgs> = {}>(args?: Subset<T, Object$RenovationArgs<ExtArgs>>): Prisma__RenovationClient<$Result.GetResult<Prisma.$RenovationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    WindowSide<T extends Object$WindowSideArgs<ExtArgs> = {}>(args?: Subset<T, Object$WindowSideArgs<ExtArgs>>): Prisma__WindowSideClient<$Result.GetResult<Prisma.$WindowSidePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    RoomType<T extends Object$RoomTypeArgs<ExtArgs> = {}>(args?: Subset<T, Object$RoomTypeArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Object model
   */ 
  interface ObjectFieldRefs {
    readonly id: FieldRef<"Object", 'Int'>
    readonly name: FieldRef<"Object", 'String'>
    readonly realtorId: FieldRef<"Object", 'Int'>
    readonly objectTypeId: FieldRef<"Object", 'Int'>
    readonly residenceTypeId: FieldRef<"Object", 'Int'>
    readonly objectCategoryId: FieldRef<"Object", 'Int'>
    readonly objectStatusId: FieldRef<"Object", 'Int'>
    readonly is_studio: FieldRef<"Object", 'Boolean'>
    readonly floor: FieldRef<"Object", 'Int'>
    readonly floors_in_building: FieldRef<"Object", 'Int'>
    readonly total_area: FieldRef<"Object", 'Float'>
    readonly live_area: FieldRef<"Object", 'Float'>
    readonly kitchen_area: FieldRef<"Object", 'Float'>
    readonly rooms_area: FieldRef<"Object", 'Float'>
    readonly price: FieldRef<"Object", 'Float'>
    readonly currencyId: FieldRef<"Object", 'Int'>
    readonly price_per_square: FieldRef<"Object", 'Float'>
    readonly price_type: FieldRef<"Object", 'Float'>
    readonly renovationId: FieldRef<"Object", 'Int'>
    readonly windowSideId: FieldRef<"Object", 'Int'>
    readonly roomTypeId: FieldRef<"Object", 'Int'>
    readonly is_apartment: FieldRef<"Object", 'Boolean'>
    readonly is_luxury: FieldRef<"Object", 'Boolean'>
    readonly ceiling_height: FieldRef<"Object", 'Float'>
    readonly combined_bath_count: FieldRef<"Object", 'Int'>
    readonly separate_bath_count: FieldRef<"Object", 'Int'>
    readonly loggia_count: FieldRef<"Object", 'Int'>
    readonly loggia_description: FieldRef<"Object", 'String'>
    readonly balcony_count: FieldRef<"Object", 'Int'>
    readonly balcony_description: FieldRef<"Object", 'String'>
    readonly general_description: FieldRef<"Object", 'String'>
    readonly cadastral_number: FieldRef<"Object", 'Int'>
    readonly document: FieldRef<"Object", 'String'>
    readonly layout: FieldRef<"Object", 'String'>
    readonly fotos: FieldRef<"Object", 'String'>
    readonly online_show: FieldRef<"Object", 'Boolean'>
    readonly video: FieldRef<"Object", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Object findUnique
   */
  export type ObjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object findUniqueOrThrow
   */
  export type ObjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object findFirst
   */
  export type ObjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objects.
     */
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object findFirstOrThrow
   */
  export type ObjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Object to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objects.
     */
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object findMany
   */
  export type ObjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter, which Objects to fetch.
     */
    where?: ObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objects to fetch.
     */
    orderBy?: ObjectOrderByWithRelationInput | ObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Objects.
     */
    cursor?: ObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objects.
     */
    skip?: number
    distinct?: ObjectScalarFieldEnum | ObjectScalarFieldEnum[]
  }

  /**
   * Object create
   */
  export type ObjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Object.
     */
    data: XOR<ObjectCreateInput, ObjectUncheckedCreateInput>
  }

  /**
   * Object createMany
   */
  export type ObjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Objects.
     */
    data: ObjectCreateManyInput | ObjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Object update
   */
  export type ObjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Object.
     */
    data: XOR<ObjectUpdateInput, ObjectUncheckedUpdateInput>
    /**
     * Choose, which Object to update.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object updateMany
   */
  export type ObjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Objects.
     */
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyInput>
    /**
     * Filter which Objects to update
     */
    where?: ObjectWhereInput
  }

  /**
   * Object upsert
   */
  export type ObjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Object to update in case it exists.
     */
    where: ObjectWhereUniqueInput
    /**
     * In case the Object found by the `where` argument doesn't exist, create a new Object with this data.
     */
    create: XOR<ObjectCreateInput, ObjectUncheckedCreateInput>
    /**
     * In case the Object was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectUpdateInput, ObjectUncheckedUpdateInput>
  }

  /**
   * Object delete
   */
  export type ObjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
    /**
     * Filter which Object to delete.
     */
    where: ObjectWhereUniqueInput
  }

  /**
   * Object deleteMany
   */
  export type ObjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Objects to delete
     */
    where?: ObjectWhereInput
  }

  /**
   * Object.Realtor
   */
  export type Object$RealtorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Realtor
     */
    select?: RealtorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealtorInclude<ExtArgs> | null
    where?: RealtorWhereInput
  }

  /**
   * Object.ObjectType
   */
  export type Object$ObjectTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectType
     */
    select?: ObjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectTypeInclude<ExtArgs> | null
    where?: ObjectTypeWhereInput
  }

  /**
   * Object.ResidenceType
   */
  export type Object$ResidenceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResidenceType
     */
    select?: ResidenceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResidenceTypeInclude<ExtArgs> | null
    where?: ResidenceTypeWhereInput
  }

  /**
   * Object.ObjectCategory
   */
  export type Object$ObjectCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectCategory
     */
    select?: ObjectCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectCategoryInclude<ExtArgs> | null
    where?: ObjectCategoryWhereInput
  }

  /**
   * Object.ObjectStatus
   */
  export type Object$ObjectStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectStatus
     */
    select?: ObjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectStatusInclude<ExtArgs> | null
    where?: ObjectStatusWhereInput
  }

  /**
   * Object.Currency
   */
  export type Object$CurrencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
  }

  /**
   * Object.Renovation
   */
  export type Object$RenovationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Renovation
     */
    select?: RenovationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RenovationInclude<ExtArgs> | null
    where?: RenovationWhereInput
  }

  /**
   * Object.WindowSide
   */
  export type Object$WindowSideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WindowSide
     */
    select?: WindowSideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WindowSideInclude<ExtArgs> | null
    where?: WindowSideWhereInput
  }

  /**
   * Object.RoomType
   */
  export type Object$RoomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    where?: RoomTypeWhereInput
  }

  /**
   * Object without action
   */
  export type ObjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Object
     */
    select?: ObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectInclude<ExtArgs> | null
  }


  /**
   * Model OwnerShip
   */

  export type AggregateOwnerShip = {
    _count: OwnerShipCountAggregateOutputType | null
    _avg: OwnerShipAvgAggregateOutputType | null
    _sum: OwnerShipSumAggregateOutputType | null
    _min: OwnerShipMinAggregateOutputType | null
    _max: OwnerShipMaxAggregateOutputType | null
  }

  export type OwnerShipAvgAggregateOutputType = {
    id: number | null
  }

  export type OwnerShipSumAggregateOutputType = {
    id: number | null
  }

  export type OwnerShipMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type OwnerShipMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type OwnerShipCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type OwnerShipAvgAggregateInputType = {
    id?: true
  }

  export type OwnerShipSumAggregateInputType = {
    id?: true
  }

  export type OwnerShipMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type OwnerShipMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type OwnerShipCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type OwnerShipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerShip to aggregate.
     */
    where?: OwnerShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerShips to fetch.
     */
    orderBy?: OwnerShipOrderByWithRelationInput | OwnerShipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerShips
    **/
    _count?: true | OwnerShipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerShipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerShipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerShipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerShipMaxAggregateInputType
  }

  export type GetOwnerShipAggregateType<T extends OwnerShipAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerShip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerShip[P]>
      : GetScalarType<T[P], AggregateOwnerShip[P]>
  }




  export type OwnerShipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerShipWhereInput
    orderBy?: OwnerShipOrderByWithAggregationInput | OwnerShipOrderByWithAggregationInput[]
    by: OwnerShipScalarFieldEnum[] | OwnerShipScalarFieldEnum
    having?: OwnerShipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerShipCountAggregateInputType | true
    _avg?: OwnerShipAvgAggregateInputType
    _sum?: OwnerShipSumAggregateInputType
    _min?: OwnerShipMinAggregateInputType
    _max?: OwnerShipMaxAggregateInputType
  }

  export type OwnerShipGroupByOutputType = {
    id: number
    name: string
    _count: OwnerShipCountAggregateOutputType | null
    _avg: OwnerShipAvgAggregateOutputType | null
    _sum: OwnerShipSumAggregateOutputType | null
    _min: OwnerShipMinAggregateOutputType | null
    _max: OwnerShipMaxAggregateOutputType | null
  }

  type GetOwnerShipGroupByPayload<T extends OwnerShipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerShipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerShipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerShipGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerShipGroupByOutputType[P]>
        }
      >
    >


  export type OwnerShipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerRelation?: boolean | OwnerShip$ownerRelationArgs<ExtArgs>
    _count?: boolean | OwnerShipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerShip"]>

  export type OwnerShipSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type OwnerShipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerRelation?: boolean | OwnerShip$ownerRelationArgs<ExtArgs>
    _count?: boolean | OwnerShipCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OwnerShipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerShip"
    objects: {
      ownerRelation: Prisma.$OwnerRelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["ownerShip"]>
    composites: {}
  }


  type OwnerShipGetPayload<S extends boolean | null | undefined | OwnerShipDefaultArgs> = $Result.GetResult<Prisma.$OwnerShipPayload, S>

  type OwnerShipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerShipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerShipCountAggregateInputType | true
    }

  export interface OwnerShipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerShip'], meta: { name: 'OwnerShip' } }
    /**
     * Find zero or one OwnerShip that matches the filter.
     * @param {OwnerShipFindUniqueArgs} args - Arguments to find a OwnerShip
     * @example
     * // Get one OwnerShip
     * const ownerShip = await prisma.ownerShip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OwnerShipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerShipFindUniqueArgs<ExtArgs>>
    ): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OwnerShip that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OwnerShipFindUniqueOrThrowArgs} args - Arguments to find a OwnerShip
     * @example
     * // Get one OwnerShip
     * const ownerShip = await prisma.ownerShip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OwnerShipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerShipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OwnerShip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerShipFindFirstArgs} args - Arguments to find a OwnerShip
     * @example
     * // Get one OwnerShip
     * const ownerShip = await prisma.ownerShip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OwnerShipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerShipFindFirstArgs<ExtArgs>>
    ): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OwnerShip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerShipFindFirstOrThrowArgs} args - Arguments to find a OwnerShip
     * @example
     * // Get one OwnerShip
     * const ownerShip = await prisma.ownerShip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OwnerShipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerShipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OwnerShips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerShipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerShips
     * const ownerShips = await prisma.ownerShip.findMany()
     * 
     * // Get first 10 OwnerShips
     * const ownerShips = await prisma.ownerShip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerShipWithIdOnly = await prisma.ownerShip.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OwnerShipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerShipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OwnerShip.
     * @param {OwnerShipCreateArgs} args - Arguments to create a OwnerShip.
     * @example
     * // Create one OwnerShip
     * const OwnerShip = await prisma.ownerShip.create({
     *   data: {
     *     // ... data to create a OwnerShip
     *   }
     * })
     * 
    **/
    create<T extends OwnerShipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerShipCreateArgs<ExtArgs>>
    ): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OwnerShips.
     *     @param {OwnerShipCreateManyArgs} args - Arguments to create many OwnerShips.
     *     @example
     *     // Create many OwnerShips
     *     const ownerShip = await prisma.ownerShip.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OwnerShipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerShipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OwnerShip.
     * @param {OwnerShipDeleteArgs} args - Arguments to delete one OwnerShip.
     * @example
     * // Delete one OwnerShip
     * const OwnerShip = await prisma.ownerShip.delete({
     *   where: {
     *     // ... filter to delete one OwnerShip
     *   }
     * })
     * 
    **/
    delete<T extends OwnerShipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerShipDeleteArgs<ExtArgs>>
    ): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OwnerShip.
     * @param {OwnerShipUpdateArgs} args - Arguments to update one OwnerShip.
     * @example
     * // Update one OwnerShip
     * const ownerShip = await prisma.ownerShip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OwnerShipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerShipUpdateArgs<ExtArgs>>
    ): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OwnerShips.
     * @param {OwnerShipDeleteManyArgs} args - Arguments to filter OwnerShips to delete.
     * @example
     * // Delete a few OwnerShips
     * const { count } = await prisma.ownerShip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OwnerShipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerShipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerShipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerShips
     * const ownerShip = await prisma.ownerShip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OwnerShipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerShipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OwnerShip.
     * @param {OwnerShipUpsertArgs} args - Arguments to update or create a OwnerShip.
     * @example
     * // Update or create a OwnerShip
     * const ownerShip = await prisma.ownerShip.upsert({
     *   create: {
     *     // ... data to create a OwnerShip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerShip we want to update
     *   }
     * })
    **/
    upsert<T extends OwnerShipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerShipUpsertArgs<ExtArgs>>
    ): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OwnerShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerShipCountArgs} args - Arguments to filter OwnerShips to count.
     * @example
     * // Count the number of OwnerShips
     * const count = await prisma.ownerShip.count({
     *   where: {
     *     // ... the filter for the OwnerShips we want to count
     *   }
     * })
    **/
    count<T extends OwnerShipCountArgs>(
      args?: Subset<T, OwnerShipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerShipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerShipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerShipAggregateArgs>(args: Subset<T, OwnerShipAggregateArgs>): Prisma.PrismaPromise<GetOwnerShipAggregateType<T>>

    /**
     * Group by OwnerShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerShipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerShipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerShipGroupByArgs['orderBy'] }
        : { orderBy?: OwnerShipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerShipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerShipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerShip model
   */
  readonly fields: OwnerShipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerShip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerShipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ownerRelation<T extends OwnerShip$ownerRelationArgs<ExtArgs> = {}>(args?: Subset<T, OwnerShip$ownerRelationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OwnerShip model
   */ 
  interface OwnerShipFieldRefs {
    readonly id: FieldRef<"OwnerShip", 'Int'>
    readonly name: FieldRef<"OwnerShip", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OwnerShip findUnique
   */
  export type OwnerShipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * Filter, which OwnerShip to fetch.
     */
    where: OwnerShipWhereUniqueInput
  }

  /**
   * OwnerShip findUniqueOrThrow
   */
  export type OwnerShipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * Filter, which OwnerShip to fetch.
     */
    where: OwnerShipWhereUniqueInput
  }

  /**
   * OwnerShip findFirst
   */
  export type OwnerShipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * Filter, which OwnerShip to fetch.
     */
    where?: OwnerShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerShips to fetch.
     */
    orderBy?: OwnerShipOrderByWithRelationInput | OwnerShipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerShips.
     */
    cursor?: OwnerShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerShips.
     */
    distinct?: OwnerShipScalarFieldEnum | OwnerShipScalarFieldEnum[]
  }

  /**
   * OwnerShip findFirstOrThrow
   */
  export type OwnerShipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * Filter, which OwnerShip to fetch.
     */
    where?: OwnerShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerShips to fetch.
     */
    orderBy?: OwnerShipOrderByWithRelationInput | OwnerShipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerShips.
     */
    cursor?: OwnerShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerShips.
     */
    distinct?: OwnerShipScalarFieldEnum | OwnerShipScalarFieldEnum[]
  }

  /**
   * OwnerShip findMany
   */
  export type OwnerShipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * Filter, which OwnerShips to fetch.
     */
    where?: OwnerShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerShips to fetch.
     */
    orderBy?: OwnerShipOrderByWithRelationInput | OwnerShipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerShips.
     */
    cursor?: OwnerShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerShips.
     */
    skip?: number
    distinct?: OwnerShipScalarFieldEnum | OwnerShipScalarFieldEnum[]
  }

  /**
   * OwnerShip create
   */
  export type OwnerShipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerShip.
     */
    data: XOR<OwnerShipCreateInput, OwnerShipUncheckedCreateInput>
  }

  /**
   * OwnerShip createMany
   */
  export type OwnerShipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerShips.
     */
    data: OwnerShipCreateManyInput | OwnerShipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerShip update
   */
  export type OwnerShipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerShip.
     */
    data: XOR<OwnerShipUpdateInput, OwnerShipUncheckedUpdateInput>
    /**
     * Choose, which OwnerShip to update.
     */
    where: OwnerShipWhereUniqueInput
  }

  /**
   * OwnerShip updateMany
   */
  export type OwnerShipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerShips.
     */
    data: XOR<OwnerShipUpdateManyMutationInput, OwnerShipUncheckedUpdateManyInput>
    /**
     * Filter which OwnerShips to update
     */
    where?: OwnerShipWhereInput
  }

  /**
   * OwnerShip upsert
   */
  export type OwnerShipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerShip to update in case it exists.
     */
    where: OwnerShipWhereUniqueInput
    /**
     * In case the OwnerShip found by the `where` argument doesn't exist, create a new OwnerShip with this data.
     */
    create: XOR<OwnerShipCreateInput, OwnerShipUncheckedCreateInput>
    /**
     * In case the OwnerShip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerShipUpdateInput, OwnerShipUncheckedUpdateInput>
  }

  /**
   * OwnerShip delete
   */
  export type OwnerShipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    /**
     * Filter which OwnerShip to delete.
     */
    where: OwnerShipWhereUniqueInput
  }

  /**
   * OwnerShip deleteMany
   */
  export type OwnerShipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerShips to delete
     */
    where?: OwnerShipWhereInput
  }

  /**
   * OwnerShip.ownerRelation
   */
  export type OwnerShip$ownerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    where?: OwnerRelationWhereInput
    orderBy?: OwnerRelationOrderByWithRelationInput | OwnerRelationOrderByWithRelationInput[]
    cursor?: OwnerRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerRelationScalarFieldEnum | OwnerRelationScalarFieldEnum[]
  }

  /**
   * OwnerShip without action
   */
  export type OwnerShipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
  }


  /**
   * Model ReasonDeleting
   */

  export type AggregateReasonDeleting = {
    _count: ReasonDeletingCountAggregateOutputType | null
    _avg: ReasonDeletingAvgAggregateOutputType | null
    _sum: ReasonDeletingSumAggregateOutputType | null
    _min: ReasonDeletingMinAggregateOutputType | null
    _max: ReasonDeletingMaxAggregateOutputType | null
  }

  export type ReasonDeletingAvgAggregateOutputType = {
    id: number | null
  }

  export type ReasonDeletingSumAggregateOutputType = {
    id: number | null
  }

  export type ReasonDeletingMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ReasonDeletingMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ReasonDeletingCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ReasonDeletingAvgAggregateInputType = {
    id?: true
  }

  export type ReasonDeletingSumAggregateInputType = {
    id?: true
  }

  export type ReasonDeletingMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ReasonDeletingMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ReasonDeletingCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ReasonDeletingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReasonDeleting to aggregate.
     */
    where?: ReasonDeletingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonDeletings to fetch.
     */
    orderBy?: ReasonDeletingOrderByWithRelationInput | ReasonDeletingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReasonDeletingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonDeletings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonDeletings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReasonDeletings
    **/
    _count?: true | ReasonDeletingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReasonDeletingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReasonDeletingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReasonDeletingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReasonDeletingMaxAggregateInputType
  }

  export type GetReasonDeletingAggregateType<T extends ReasonDeletingAggregateArgs> = {
        [P in keyof T & keyof AggregateReasonDeleting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReasonDeleting[P]>
      : GetScalarType<T[P], AggregateReasonDeleting[P]>
  }




  export type ReasonDeletingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReasonDeletingWhereInput
    orderBy?: ReasonDeletingOrderByWithAggregationInput | ReasonDeletingOrderByWithAggregationInput[]
    by: ReasonDeletingScalarFieldEnum[] | ReasonDeletingScalarFieldEnum
    having?: ReasonDeletingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReasonDeletingCountAggregateInputType | true
    _avg?: ReasonDeletingAvgAggregateInputType
    _sum?: ReasonDeletingSumAggregateInputType
    _min?: ReasonDeletingMinAggregateInputType
    _max?: ReasonDeletingMaxAggregateInputType
  }

  export type ReasonDeletingGroupByOutputType = {
    id: number
    name: string
    _count: ReasonDeletingCountAggregateOutputType | null
    _avg: ReasonDeletingAvgAggregateOutputType | null
    _sum: ReasonDeletingSumAggregateOutputType | null
    _min: ReasonDeletingMinAggregateOutputType | null
    _max: ReasonDeletingMaxAggregateOutputType | null
  }

  type GetReasonDeletingGroupByPayload<T extends ReasonDeletingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReasonDeletingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReasonDeletingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReasonDeletingGroupByOutputType[P]>
            : GetScalarType<T[P], ReasonDeletingGroupByOutputType[P]>
        }
      >
    >


  export type ReasonDeletingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerRelation?: boolean | ReasonDeleting$ownerRelationArgs<ExtArgs>
    _count?: boolean | ReasonDeletingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reasonDeleting"]>

  export type ReasonDeletingSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type ReasonDeletingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerRelation?: boolean | ReasonDeleting$ownerRelationArgs<ExtArgs>
    _count?: boolean | ReasonDeletingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ReasonDeletingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReasonDeleting"
    objects: {
      ownerRelation: Prisma.$OwnerRelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["reasonDeleting"]>
    composites: {}
  }


  type ReasonDeletingGetPayload<S extends boolean | null | undefined | ReasonDeletingDefaultArgs> = $Result.GetResult<Prisma.$ReasonDeletingPayload, S>

  type ReasonDeletingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReasonDeletingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReasonDeletingCountAggregateInputType | true
    }

  export interface ReasonDeletingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReasonDeleting'], meta: { name: 'ReasonDeleting' } }
    /**
     * Find zero or one ReasonDeleting that matches the filter.
     * @param {ReasonDeletingFindUniqueArgs} args - Arguments to find a ReasonDeleting
     * @example
     * // Get one ReasonDeleting
     * const reasonDeleting = await prisma.reasonDeleting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReasonDeletingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReasonDeletingFindUniqueArgs<ExtArgs>>
    ): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ReasonDeleting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReasonDeletingFindUniqueOrThrowArgs} args - Arguments to find a ReasonDeleting
     * @example
     * // Get one ReasonDeleting
     * const reasonDeleting = await prisma.reasonDeleting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReasonDeletingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReasonDeletingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ReasonDeleting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDeletingFindFirstArgs} args - Arguments to find a ReasonDeleting
     * @example
     * // Get one ReasonDeleting
     * const reasonDeleting = await prisma.reasonDeleting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReasonDeletingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReasonDeletingFindFirstArgs<ExtArgs>>
    ): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ReasonDeleting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDeletingFindFirstOrThrowArgs} args - Arguments to find a ReasonDeleting
     * @example
     * // Get one ReasonDeleting
     * const reasonDeleting = await prisma.reasonDeleting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReasonDeletingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReasonDeletingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ReasonDeletings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDeletingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReasonDeletings
     * const reasonDeletings = await prisma.reasonDeleting.findMany()
     * 
     * // Get first 10 ReasonDeletings
     * const reasonDeletings = await prisma.reasonDeleting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reasonDeletingWithIdOnly = await prisma.reasonDeleting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReasonDeletingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReasonDeletingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ReasonDeleting.
     * @param {ReasonDeletingCreateArgs} args - Arguments to create a ReasonDeleting.
     * @example
     * // Create one ReasonDeleting
     * const ReasonDeleting = await prisma.reasonDeleting.create({
     *   data: {
     *     // ... data to create a ReasonDeleting
     *   }
     * })
     * 
    **/
    create<T extends ReasonDeletingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReasonDeletingCreateArgs<ExtArgs>>
    ): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ReasonDeletings.
     *     @param {ReasonDeletingCreateManyArgs} args - Arguments to create many ReasonDeletings.
     *     @example
     *     // Create many ReasonDeletings
     *     const reasonDeleting = await prisma.reasonDeleting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReasonDeletingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReasonDeletingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReasonDeleting.
     * @param {ReasonDeletingDeleteArgs} args - Arguments to delete one ReasonDeleting.
     * @example
     * // Delete one ReasonDeleting
     * const ReasonDeleting = await prisma.reasonDeleting.delete({
     *   where: {
     *     // ... filter to delete one ReasonDeleting
     *   }
     * })
     * 
    **/
    delete<T extends ReasonDeletingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReasonDeletingDeleteArgs<ExtArgs>>
    ): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ReasonDeleting.
     * @param {ReasonDeletingUpdateArgs} args - Arguments to update one ReasonDeleting.
     * @example
     * // Update one ReasonDeleting
     * const reasonDeleting = await prisma.reasonDeleting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReasonDeletingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReasonDeletingUpdateArgs<ExtArgs>>
    ): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ReasonDeletings.
     * @param {ReasonDeletingDeleteManyArgs} args - Arguments to filter ReasonDeletings to delete.
     * @example
     * // Delete a few ReasonDeletings
     * const { count } = await prisma.reasonDeleting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReasonDeletingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReasonDeletingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReasonDeletings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDeletingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReasonDeletings
     * const reasonDeleting = await prisma.reasonDeleting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReasonDeletingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReasonDeletingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReasonDeleting.
     * @param {ReasonDeletingUpsertArgs} args - Arguments to update or create a ReasonDeleting.
     * @example
     * // Update or create a ReasonDeleting
     * const reasonDeleting = await prisma.reasonDeleting.upsert({
     *   create: {
     *     // ... data to create a ReasonDeleting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReasonDeleting we want to update
     *   }
     * })
    **/
    upsert<T extends ReasonDeletingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReasonDeletingUpsertArgs<ExtArgs>>
    ): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ReasonDeletings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDeletingCountArgs} args - Arguments to filter ReasonDeletings to count.
     * @example
     * // Count the number of ReasonDeletings
     * const count = await prisma.reasonDeleting.count({
     *   where: {
     *     // ... the filter for the ReasonDeletings we want to count
     *   }
     * })
    **/
    count<T extends ReasonDeletingCountArgs>(
      args?: Subset<T, ReasonDeletingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReasonDeletingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReasonDeleting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDeletingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReasonDeletingAggregateArgs>(args: Subset<T, ReasonDeletingAggregateArgs>): Prisma.PrismaPromise<GetReasonDeletingAggregateType<T>>

    /**
     * Group by ReasonDeleting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReasonDeletingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReasonDeletingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReasonDeletingGroupByArgs['orderBy'] }
        : { orderBy?: ReasonDeletingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReasonDeletingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReasonDeletingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReasonDeleting model
   */
  readonly fields: ReasonDeletingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReasonDeleting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReasonDeletingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ownerRelation<T extends ReasonDeleting$ownerRelationArgs<ExtArgs> = {}>(args?: Subset<T, ReasonDeleting$ownerRelationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ReasonDeleting model
   */ 
  interface ReasonDeletingFieldRefs {
    readonly id: FieldRef<"ReasonDeleting", 'Int'>
    readonly name: FieldRef<"ReasonDeleting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReasonDeleting findUnique
   */
  export type ReasonDeletingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDeleting to fetch.
     */
    where: ReasonDeletingWhereUniqueInput
  }

  /**
   * ReasonDeleting findUniqueOrThrow
   */
  export type ReasonDeletingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDeleting to fetch.
     */
    where: ReasonDeletingWhereUniqueInput
  }

  /**
   * ReasonDeleting findFirst
   */
  export type ReasonDeletingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDeleting to fetch.
     */
    where?: ReasonDeletingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonDeletings to fetch.
     */
    orderBy?: ReasonDeletingOrderByWithRelationInput | ReasonDeletingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReasonDeletings.
     */
    cursor?: ReasonDeletingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonDeletings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonDeletings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReasonDeletings.
     */
    distinct?: ReasonDeletingScalarFieldEnum | ReasonDeletingScalarFieldEnum[]
  }

  /**
   * ReasonDeleting findFirstOrThrow
   */
  export type ReasonDeletingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDeleting to fetch.
     */
    where?: ReasonDeletingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonDeletings to fetch.
     */
    orderBy?: ReasonDeletingOrderByWithRelationInput | ReasonDeletingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReasonDeletings.
     */
    cursor?: ReasonDeletingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonDeletings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonDeletings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReasonDeletings.
     */
    distinct?: ReasonDeletingScalarFieldEnum | ReasonDeletingScalarFieldEnum[]
  }

  /**
   * ReasonDeleting findMany
   */
  export type ReasonDeletingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * Filter, which ReasonDeletings to fetch.
     */
    where?: ReasonDeletingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReasonDeletings to fetch.
     */
    orderBy?: ReasonDeletingOrderByWithRelationInput | ReasonDeletingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReasonDeletings.
     */
    cursor?: ReasonDeletingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReasonDeletings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReasonDeletings.
     */
    skip?: number
    distinct?: ReasonDeletingScalarFieldEnum | ReasonDeletingScalarFieldEnum[]
  }

  /**
   * ReasonDeleting create
   */
  export type ReasonDeletingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * The data needed to create a ReasonDeleting.
     */
    data: XOR<ReasonDeletingCreateInput, ReasonDeletingUncheckedCreateInput>
  }

  /**
   * ReasonDeleting createMany
   */
  export type ReasonDeletingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReasonDeletings.
     */
    data: ReasonDeletingCreateManyInput | ReasonDeletingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReasonDeleting update
   */
  export type ReasonDeletingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * The data needed to update a ReasonDeleting.
     */
    data: XOR<ReasonDeletingUpdateInput, ReasonDeletingUncheckedUpdateInput>
    /**
     * Choose, which ReasonDeleting to update.
     */
    where: ReasonDeletingWhereUniqueInput
  }

  /**
   * ReasonDeleting updateMany
   */
  export type ReasonDeletingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReasonDeletings.
     */
    data: XOR<ReasonDeletingUpdateManyMutationInput, ReasonDeletingUncheckedUpdateManyInput>
    /**
     * Filter which ReasonDeletings to update
     */
    where?: ReasonDeletingWhereInput
  }

  /**
   * ReasonDeleting upsert
   */
  export type ReasonDeletingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * The filter to search for the ReasonDeleting to update in case it exists.
     */
    where: ReasonDeletingWhereUniqueInput
    /**
     * In case the ReasonDeleting found by the `where` argument doesn't exist, create a new ReasonDeleting with this data.
     */
    create: XOR<ReasonDeletingCreateInput, ReasonDeletingUncheckedCreateInput>
    /**
     * In case the ReasonDeleting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReasonDeletingUpdateInput, ReasonDeletingUncheckedUpdateInput>
  }

  /**
   * ReasonDeleting delete
   */
  export type ReasonDeletingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    /**
     * Filter which ReasonDeleting to delete.
     */
    where: ReasonDeletingWhereUniqueInput
  }

  /**
   * ReasonDeleting deleteMany
   */
  export type ReasonDeletingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReasonDeletings to delete
     */
    where?: ReasonDeletingWhereInput
  }

  /**
   * ReasonDeleting.ownerRelation
   */
  export type ReasonDeleting$ownerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    where?: OwnerRelationWhereInput
    orderBy?: OwnerRelationOrderByWithRelationInput | OwnerRelationOrderByWithRelationInput[]
    cursor?: OwnerRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerRelationScalarFieldEnum | OwnerRelationScalarFieldEnum[]
  }

  /**
   * ReasonDeleting without action
   */
  export type ReasonDeletingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
  }


  /**
   * Model OwnerCooperation
   */

  export type AggregateOwnerCooperation = {
    _count: OwnerCooperationCountAggregateOutputType | null
    _avg: OwnerCooperationAvgAggregateOutputType | null
    _sum: OwnerCooperationSumAggregateOutputType | null
    _min: OwnerCooperationMinAggregateOutputType | null
    _max: OwnerCooperationMaxAggregateOutputType | null
  }

  export type OwnerCooperationAvgAggregateOutputType = {
    id: number | null
  }

  export type OwnerCooperationSumAggregateOutputType = {
    id: number | null
  }

  export type OwnerCooperationMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type OwnerCooperationMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type OwnerCooperationCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type OwnerCooperationAvgAggregateInputType = {
    id?: true
  }

  export type OwnerCooperationSumAggregateInputType = {
    id?: true
  }

  export type OwnerCooperationMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type OwnerCooperationMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type OwnerCooperationCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type OwnerCooperationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerCooperation to aggregate.
     */
    where?: OwnerCooperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerCooperations to fetch.
     */
    orderBy?: OwnerCooperationOrderByWithRelationInput | OwnerCooperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerCooperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerCooperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerCooperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerCooperations
    **/
    _count?: true | OwnerCooperationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerCooperationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerCooperationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerCooperationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerCooperationMaxAggregateInputType
  }

  export type GetOwnerCooperationAggregateType<T extends OwnerCooperationAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerCooperation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerCooperation[P]>
      : GetScalarType<T[P], AggregateOwnerCooperation[P]>
  }




  export type OwnerCooperationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerCooperationWhereInput
    orderBy?: OwnerCooperationOrderByWithAggregationInput | OwnerCooperationOrderByWithAggregationInput[]
    by: OwnerCooperationScalarFieldEnum[] | OwnerCooperationScalarFieldEnum
    having?: OwnerCooperationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerCooperationCountAggregateInputType | true
    _avg?: OwnerCooperationAvgAggregateInputType
    _sum?: OwnerCooperationSumAggregateInputType
    _min?: OwnerCooperationMinAggregateInputType
    _max?: OwnerCooperationMaxAggregateInputType
  }

  export type OwnerCooperationGroupByOutputType = {
    id: number
    name: string
    _count: OwnerCooperationCountAggregateOutputType | null
    _avg: OwnerCooperationAvgAggregateOutputType | null
    _sum: OwnerCooperationSumAggregateOutputType | null
    _min: OwnerCooperationMinAggregateOutputType | null
    _max: OwnerCooperationMaxAggregateOutputType | null
  }

  type GetOwnerCooperationGroupByPayload<T extends OwnerCooperationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerCooperationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerCooperationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerCooperationGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerCooperationGroupByOutputType[P]>
        }
      >
    >


  export type OwnerCooperationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerRelation?: boolean | OwnerCooperation$ownerRelationArgs<ExtArgs>
    _count?: boolean | OwnerCooperationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerCooperation"]>

  export type OwnerCooperationSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type OwnerCooperationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerRelation?: boolean | OwnerCooperation$ownerRelationArgs<ExtArgs>
    _count?: boolean | OwnerCooperationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OwnerCooperationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerCooperation"
    objects: {
      ownerRelation: Prisma.$OwnerRelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["ownerCooperation"]>
    composites: {}
  }


  type OwnerCooperationGetPayload<S extends boolean | null | undefined | OwnerCooperationDefaultArgs> = $Result.GetResult<Prisma.$OwnerCooperationPayload, S>

  type OwnerCooperationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerCooperationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerCooperationCountAggregateInputType | true
    }

  export interface OwnerCooperationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerCooperation'], meta: { name: 'OwnerCooperation' } }
    /**
     * Find zero or one OwnerCooperation that matches the filter.
     * @param {OwnerCooperationFindUniqueArgs} args - Arguments to find a OwnerCooperation
     * @example
     * // Get one OwnerCooperation
     * const ownerCooperation = await prisma.ownerCooperation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OwnerCooperationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerCooperationFindUniqueArgs<ExtArgs>>
    ): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OwnerCooperation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OwnerCooperationFindUniqueOrThrowArgs} args - Arguments to find a OwnerCooperation
     * @example
     * // Get one OwnerCooperation
     * const ownerCooperation = await prisma.ownerCooperation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OwnerCooperationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerCooperationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OwnerCooperation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCooperationFindFirstArgs} args - Arguments to find a OwnerCooperation
     * @example
     * // Get one OwnerCooperation
     * const ownerCooperation = await prisma.ownerCooperation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OwnerCooperationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerCooperationFindFirstArgs<ExtArgs>>
    ): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OwnerCooperation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCooperationFindFirstOrThrowArgs} args - Arguments to find a OwnerCooperation
     * @example
     * // Get one OwnerCooperation
     * const ownerCooperation = await prisma.ownerCooperation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OwnerCooperationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerCooperationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OwnerCooperations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCooperationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerCooperations
     * const ownerCooperations = await prisma.ownerCooperation.findMany()
     * 
     * // Get first 10 OwnerCooperations
     * const ownerCooperations = await prisma.ownerCooperation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerCooperationWithIdOnly = await prisma.ownerCooperation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OwnerCooperationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerCooperationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OwnerCooperation.
     * @param {OwnerCooperationCreateArgs} args - Arguments to create a OwnerCooperation.
     * @example
     * // Create one OwnerCooperation
     * const OwnerCooperation = await prisma.ownerCooperation.create({
     *   data: {
     *     // ... data to create a OwnerCooperation
     *   }
     * })
     * 
    **/
    create<T extends OwnerCooperationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerCooperationCreateArgs<ExtArgs>>
    ): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OwnerCooperations.
     *     @param {OwnerCooperationCreateManyArgs} args - Arguments to create many OwnerCooperations.
     *     @example
     *     // Create many OwnerCooperations
     *     const ownerCooperation = await prisma.ownerCooperation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OwnerCooperationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerCooperationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OwnerCooperation.
     * @param {OwnerCooperationDeleteArgs} args - Arguments to delete one OwnerCooperation.
     * @example
     * // Delete one OwnerCooperation
     * const OwnerCooperation = await prisma.ownerCooperation.delete({
     *   where: {
     *     // ... filter to delete one OwnerCooperation
     *   }
     * })
     * 
    **/
    delete<T extends OwnerCooperationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerCooperationDeleteArgs<ExtArgs>>
    ): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OwnerCooperation.
     * @param {OwnerCooperationUpdateArgs} args - Arguments to update one OwnerCooperation.
     * @example
     * // Update one OwnerCooperation
     * const ownerCooperation = await prisma.ownerCooperation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OwnerCooperationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerCooperationUpdateArgs<ExtArgs>>
    ): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OwnerCooperations.
     * @param {OwnerCooperationDeleteManyArgs} args - Arguments to filter OwnerCooperations to delete.
     * @example
     * // Delete a few OwnerCooperations
     * const { count } = await prisma.ownerCooperation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OwnerCooperationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerCooperationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerCooperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCooperationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerCooperations
     * const ownerCooperation = await prisma.ownerCooperation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OwnerCooperationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerCooperationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OwnerCooperation.
     * @param {OwnerCooperationUpsertArgs} args - Arguments to update or create a OwnerCooperation.
     * @example
     * // Update or create a OwnerCooperation
     * const ownerCooperation = await prisma.ownerCooperation.upsert({
     *   create: {
     *     // ... data to create a OwnerCooperation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerCooperation we want to update
     *   }
     * })
    **/
    upsert<T extends OwnerCooperationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerCooperationUpsertArgs<ExtArgs>>
    ): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OwnerCooperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCooperationCountArgs} args - Arguments to filter OwnerCooperations to count.
     * @example
     * // Count the number of OwnerCooperations
     * const count = await prisma.ownerCooperation.count({
     *   where: {
     *     // ... the filter for the OwnerCooperations we want to count
     *   }
     * })
    **/
    count<T extends OwnerCooperationCountArgs>(
      args?: Subset<T, OwnerCooperationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerCooperationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerCooperation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCooperationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerCooperationAggregateArgs>(args: Subset<T, OwnerCooperationAggregateArgs>): Prisma.PrismaPromise<GetOwnerCooperationAggregateType<T>>

    /**
     * Group by OwnerCooperation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCooperationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerCooperationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerCooperationGroupByArgs['orderBy'] }
        : { orderBy?: OwnerCooperationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerCooperationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerCooperationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerCooperation model
   */
  readonly fields: OwnerCooperationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerCooperation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerCooperationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ownerRelation<T extends OwnerCooperation$ownerRelationArgs<ExtArgs> = {}>(args?: Subset<T, OwnerCooperation$ownerRelationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OwnerCooperation model
   */ 
  interface OwnerCooperationFieldRefs {
    readonly id: FieldRef<"OwnerCooperation", 'Int'>
    readonly name: FieldRef<"OwnerCooperation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OwnerCooperation findUnique
   */
  export type OwnerCooperationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerCooperation to fetch.
     */
    where: OwnerCooperationWhereUniqueInput
  }

  /**
   * OwnerCooperation findUniqueOrThrow
   */
  export type OwnerCooperationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerCooperation to fetch.
     */
    where: OwnerCooperationWhereUniqueInput
  }

  /**
   * OwnerCooperation findFirst
   */
  export type OwnerCooperationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerCooperation to fetch.
     */
    where?: OwnerCooperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerCooperations to fetch.
     */
    orderBy?: OwnerCooperationOrderByWithRelationInput | OwnerCooperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerCooperations.
     */
    cursor?: OwnerCooperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerCooperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerCooperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerCooperations.
     */
    distinct?: OwnerCooperationScalarFieldEnum | OwnerCooperationScalarFieldEnum[]
  }

  /**
   * OwnerCooperation findFirstOrThrow
   */
  export type OwnerCooperationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerCooperation to fetch.
     */
    where?: OwnerCooperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerCooperations to fetch.
     */
    orderBy?: OwnerCooperationOrderByWithRelationInput | OwnerCooperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerCooperations.
     */
    cursor?: OwnerCooperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerCooperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerCooperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerCooperations.
     */
    distinct?: OwnerCooperationScalarFieldEnum | OwnerCooperationScalarFieldEnum[]
  }

  /**
   * OwnerCooperation findMany
   */
  export type OwnerCooperationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerCooperations to fetch.
     */
    where?: OwnerCooperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerCooperations to fetch.
     */
    orderBy?: OwnerCooperationOrderByWithRelationInput | OwnerCooperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerCooperations.
     */
    cursor?: OwnerCooperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerCooperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerCooperations.
     */
    skip?: number
    distinct?: OwnerCooperationScalarFieldEnum | OwnerCooperationScalarFieldEnum[]
  }

  /**
   * OwnerCooperation create
   */
  export type OwnerCooperationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerCooperation.
     */
    data: XOR<OwnerCooperationCreateInput, OwnerCooperationUncheckedCreateInput>
  }

  /**
   * OwnerCooperation createMany
   */
  export type OwnerCooperationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerCooperations.
     */
    data: OwnerCooperationCreateManyInput | OwnerCooperationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerCooperation update
   */
  export type OwnerCooperationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerCooperation.
     */
    data: XOR<OwnerCooperationUpdateInput, OwnerCooperationUncheckedUpdateInput>
    /**
     * Choose, which OwnerCooperation to update.
     */
    where: OwnerCooperationWhereUniqueInput
  }

  /**
   * OwnerCooperation updateMany
   */
  export type OwnerCooperationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerCooperations.
     */
    data: XOR<OwnerCooperationUpdateManyMutationInput, OwnerCooperationUncheckedUpdateManyInput>
    /**
     * Filter which OwnerCooperations to update
     */
    where?: OwnerCooperationWhereInput
  }

  /**
   * OwnerCooperation upsert
   */
  export type OwnerCooperationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerCooperation to update in case it exists.
     */
    where: OwnerCooperationWhereUniqueInput
    /**
     * In case the OwnerCooperation found by the `where` argument doesn't exist, create a new OwnerCooperation with this data.
     */
    create: XOR<OwnerCooperationCreateInput, OwnerCooperationUncheckedCreateInput>
    /**
     * In case the OwnerCooperation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerCooperationUpdateInput, OwnerCooperationUncheckedUpdateInput>
  }

  /**
   * OwnerCooperation delete
   */
  export type OwnerCooperationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    /**
     * Filter which OwnerCooperation to delete.
     */
    where: OwnerCooperationWhereUniqueInput
  }

  /**
   * OwnerCooperation deleteMany
   */
  export type OwnerCooperationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerCooperations to delete
     */
    where?: OwnerCooperationWhereInput
  }

  /**
   * OwnerCooperation.ownerRelation
   */
  export type OwnerCooperation$ownerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    where?: OwnerRelationWhereInput
    orderBy?: OwnerRelationOrderByWithRelationInput | OwnerRelationOrderByWithRelationInput[]
    cursor?: OwnerRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerRelationScalarFieldEnum | OwnerRelationScalarFieldEnum[]
  }

  /**
   * OwnerCooperation without action
   */
  export type OwnerCooperationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
  }


  /**
   * Model RelationshipType
   */

  export type AggregateRelationshipType = {
    _count: RelationshipTypeCountAggregateOutputType | null
    _avg: RelationshipTypeAvgAggregateOutputType | null
    _sum: RelationshipTypeSumAggregateOutputType | null
    _min: RelationshipTypeMinAggregateOutputType | null
    _max: RelationshipTypeMaxAggregateOutputType | null
  }

  export type RelationshipTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type RelationshipTypeSumAggregateOutputType = {
    id: number | null
  }

  export type RelationshipTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RelationshipTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RelationshipTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RelationshipTypeAvgAggregateInputType = {
    id?: true
  }

  export type RelationshipTypeSumAggregateInputType = {
    id?: true
  }

  export type RelationshipTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RelationshipTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RelationshipTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RelationshipTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationshipType to aggregate.
     */
    where?: RelationshipTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationshipTypes to fetch.
     */
    orderBy?: RelationshipTypeOrderByWithRelationInput | RelationshipTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationshipTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationshipTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationshipTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelationshipTypes
    **/
    _count?: true | RelationshipTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelationshipTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelationshipTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationshipTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationshipTypeMaxAggregateInputType
  }

  export type GetRelationshipTypeAggregateType<T extends RelationshipTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationshipType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationshipType[P]>
      : GetScalarType<T[P], AggregateRelationshipType[P]>
  }




  export type RelationshipTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipTypeWhereInput
    orderBy?: RelationshipTypeOrderByWithAggregationInput | RelationshipTypeOrderByWithAggregationInput[]
    by: RelationshipTypeScalarFieldEnum[] | RelationshipTypeScalarFieldEnum
    having?: RelationshipTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationshipTypeCountAggregateInputType | true
    _avg?: RelationshipTypeAvgAggregateInputType
    _sum?: RelationshipTypeSumAggregateInputType
    _min?: RelationshipTypeMinAggregateInputType
    _max?: RelationshipTypeMaxAggregateInputType
  }

  export type RelationshipTypeGroupByOutputType = {
    id: number
    name: string
    _count: RelationshipTypeCountAggregateOutputType | null
    _avg: RelationshipTypeAvgAggregateOutputType | null
    _sum: RelationshipTypeSumAggregateOutputType | null
    _min: RelationshipTypeMinAggregateOutputType | null
    _max: RelationshipTypeMaxAggregateOutputType | null
  }

  type GetRelationshipTypeGroupByPayload<T extends RelationshipTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationshipTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationshipTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationshipTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RelationshipTypeGroupByOutputType[P]>
        }
      >
    >


  export type RelationshipTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerRelation?: boolean | RelationshipType$ownerRelationArgs<ExtArgs>
    _count?: boolean | RelationshipTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationshipType"]>

  export type RelationshipTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type RelationshipTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownerRelation?: boolean | RelationshipType$ownerRelationArgs<ExtArgs>
    _count?: boolean | RelationshipTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RelationshipTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelationshipType"
    objects: {
      ownerRelation: Prisma.$OwnerRelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["relationshipType"]>
    composites: {}
  }


  type RelationshipTypeGetPayload<S extends boolean | null | undefined | RelationshipTypeDefaultArgs> = $Result.GetResult<Prisma.$RelationshipTypePayload, S>

  type RelationshipTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationshipTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationshipTypeCountAggregateInputType | true
    }

  export interface RelationshipTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelationshipType'], meta: { name: 'RelationshipType' } }
    /**
     * Find zero or one RelationshipType that matches the filter.
     * @param {RelationshipTypeFindUniqueArgs} args - Arguments to find a RelationshipType
     * @example
     * // Get one RelationshipType
     * const relationshipType = await prisma.relationshipType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RelationshipTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RelationshipType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RelationshipTypeFindUniqueOrThrowArgs} args - Arguments to find a RelationshipType
     * @example
     * // Get one RelationshipType
     * const relationshipType = await prisma.relationshipType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RelationshipTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RelationshipType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipTypeFindFirstArgs} args - Arguments to find a RelationshipType
     * @example
     * // Get one RelationshipType
     * const relationshipType = await prisma.relationshipType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RelationshipTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipTypeFindFirstArgs<ExtArgs>>
    ): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RelationshipType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipTypeFindFirstOrThrowArgs} args - Arguments to find a RelationshipType
     * @example
     * // Get one RelationshipType
     * const relationshipType = await prisma.relationshipType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RelationshipTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RelationshipTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelationshipTypes
     * const relationshipTypes = await prisma.relationshipType.findMany()
     * 
     * // Get first 10 RelationshipTypes
     * const relationshipTypes = await prisma.relationshipType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationshipTypeWithIdOnly = await prisma.relationshipType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RelationshipTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RelationshipType.
     * @param {RelationshipTypeCreateArgs} args - Arguments to create a RelationshipType.
     * @example
     * // Create one RelationshipType
     * const RelationshipType = await prisma.relationshipType.create({
     *   data: {
     *     // ... data to create a RelationshipType
     *   }
     * })
     * 
    **/
    create<T extends RelationshipTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipTypeCreateArgs<ExtArgs>>
    ): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RelationshipTypes.
     *     @param {RelationshipTypeCreateManyArgs} args - Arguments to create many RelationshipTypes.
     *     @example
     *     // Create many RelationshipTypes
     *     const relationshipType = await prisma.relationshipType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RelationshipTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RelationshipType.
     * @param {RelationshipTypeDeleteArgs} args - Arguments to delete one RelationshipType.
     * @example
     * // Delete one RelationshipType
     * const RelationshipType = await prisma.relationshipType.delete({
     *   where: {
     *     // ... filter to delete one RelationshipType
     *   }
     * })
     * 
    **/
    delete<T extends RelationshipTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipTypeDeleteArgs<ExtArgs>>
    ): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RelationshipType.
     * @param {RelationshipTypeUpdateArgs} args - Arguments to update one RelationshipType.
     * @example
     * // Update one RelationshipType
     * const relationshipType = await prisma.relationshipType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RelationshipTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipTypeUpdateArgs<ExtArgs>>
    ): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RelationshipTypes.
     * @param {RelationshipTypeDeleteManyArgs} args - Arguments to filter RelationshipTypes to delete.
     * @example
     * // Delete a few RelationshipTypes
     * const { count } = await prisma.relationshipType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RelationshipTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RelationshipTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelationshipTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelationshipTypes
     * const relationshipType = await prisma.relationshipType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RelationshipTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RelationshipType.
     * @param {RelationshipTypeUpsertArgs} args - Arguments to update or create a RelationshipType.
     * @example
     * // Update or create a RelationshipType
     * const relationshipType = await prisma.relationshipType.upsert({
     *   create: {
     *     // ... data to create a RelationshipType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelationshipType we want to update
     *   }
     * })
    **/
    upsert<T extends RelationshipTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RelationshipTypeUpsertArgs<ExtArgs>>
    ): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RelationshipTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipTypeCountArgs} args - Arguments to filter RelationshipTypes to count.
     * @example
     * // Count the number of RelationshipTypes
     * const count = await prisma.relationshipType.count({
     *   where: {
     *     // ... the filter for the RelationshipTypes we want to count
     *   }
     * })
    **/
    count<T extends RelationshipTypeCountArgs>(
      args?: Subset<T, RelationshipTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationshipTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelationshipType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationshipTypeAggregateArgs>(args: Subset<T, RelationshipTypeAggregateArgs>): Prisma.PrismaPromise<GetRelationshipTypeAggregateType<T>>

    /**
     * Group by RelationshipType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationshipTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationshipTypeGroupByArgs['orderBy'] }
        : { orderBy?: RelationshipTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationshipTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationshipTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelationshipType model
   */
  readonly fields: RelationshipTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelationshipType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationshipTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ownerRelation<T extends RelationshipType$ownerRelationArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipType$ownerRelationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RelationshipType model
   */ 
  interface RelationshipTypeFieldRefs {
    readonly id: FieldRef<"RelationshipType", 'Int'>
    readonly name: FieldRef<"RelationshipType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RelationshipType findUnique
   */
  export type RelationshipTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipType to fetch.
     */
    where: RelationshipTypeWhereUniqueInput
  }

  /**
   * RelationshipType findUniqueOrThrow
   */
  export type RelationshipTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipType to fetch.
     */
    where: RelationshipTypeWhereUniqueInput
  }

  /**
   * RelationshipType findFirst
   */
  export type RelationshipTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipType to fetch.
     */
    where?: RelationshipTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationshipTypes to fetch.
     */
    orderBy?: RelationshipTypeOrderByWithRelationInput | RelationshipTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationshipTypes.
     */
    cursor?: RelationshipTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationshipTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationshipTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationshipTypes.
     */
    distinct?: RelationshipTypeScalarFieldEnum | RelationshipTypeScalarFieldEnum[]
  }

  /**
   * RelationshipType findFirstOrThrow
   */
  export type RelationshipTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipType to fetch.
     */
    where?: RelationshipTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationshipTypes to fetch.
     */
    orderBy?: RelationshipTypeOrderByWithRelationInput | RelationshipTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationshipTypes.
     */
    cursor?: RelationshipTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationshipTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationshipTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationshipTypes.
     */
    distinct?: RelationshipTypeScalarFieldEnum | RelationshipTypeScalarFieldEnum[]
  }

  /**
   * RelationshipType findMany
   */
  export type RelationshipTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipTypes to fetch.
     */
    where?: RelationshipTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationshipTypes to fetch.
     */
    orderBy?: RelationshipTypeOrderByWithRelationInput | RelationshipTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelationshipTypes.
     */
    cursor?: RelationshipTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationshipTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationshipTypes.
     */
    skip?: number
    distinct?: RelationshipTypeScalarFieldEnum | RelationshipTypeScalarFieldEnum[]
  }

  /**
   * RelationshipType create
   */
  export type RelationshipTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RelationshipType.
     */
    data: XOR<RelationshipTypeCreateInput, RelationshipTypeUncheckedCreateInput>
  }

  /**
   * RelationshipType createMany
   */
  export type RelationshipTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelationshipTypes.
     */
    data: RelationshipTypeCreateManyInput | RelationshipTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelationshipType update
   */
  export type RelationshipTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RelationshipType.
     */
    data: XOR<RelationshipTypeUpdateInput, RelationshipTypeUncheckedUpdateInput>
    /**
     * Choose, which RelationshipType to update.
     */
    where: RelationshipTypeWhereUniqueInput
  }

  /**
   * RelationshipType updateMany
   */
  export type RelationshipTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelationshipTypes.
     */
    data: XOR<RelationshipTypeUpdateManyMutationInput, RelationshipTypeUncheckedUpdateManyInput>
    /**
     * Filter which RelationshipTypes to update
     */
    where?: RelationshipTypeWhereInput
  }

  /**
   * RelationshipType upsert
   */
  export type RelationshipTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RelationshipType to update in case it exists.
     */
    where: RelationshipTypeWhereUniqueInput
    /**
     * In case the RelationshipType found by the `where` argument doesn't exist, create a new RelationshipType with this data.
     */
    create: XOR<RelationshipTypeCreateInput, RelationshipTypeUncheckedCreateInput>
    /**
     * In case the RelationshipType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationshipTypeUpdateInput, RelationshipTypeUncheckedUpdateInput>
  }

  /**
   * RelationshipType delete
   */
  export type RelationshipTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    /**
     * Filter which RelationshipType to delete.
     */
    where: RelationshipTypeWhereUniqueInput
  }

  /**
   * RelationshipType deleteMany
   */
  export type RelationshipTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationshipTypes to delete
     */
    where?: RelationshipTypeWhereInput
  }

  /**
   * RelationshipType.ownerRelation
   */
  export type RelationshipType$ownerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    where?: OwnerRelationWhereInput
    orderBy?: OwnerRelationOrderByWithRelationInput | OwnerRelationOrderByWithRelationInput[]
    cursor?: OwnerRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerRelationScalarFieldEnum | OwnerRelationScalarFieldEnum[]
  }

  /**
   * RelationshipType without action
   */
  export type RelationshipTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
  }


  /**
   * Model OwnerRelation
   */

  export type AggregateOwnerRelation = {
    _count: OwnerRelationCountAggregateOutputType | null
    _avg: OwnerRelationAvgAggregateOutputType | null
    _sum: OwnerRelationSumAggregateOutputType | null
    _min: OwnerRelationMinAggregateOutputType | null
    _max: OwnerRelationMaxAggregateOutputType | null
  }

  export type OwnerRelationAvgAggregateOutputType = {
    id: number | null
    ownerShipId: number | null
    reasonDeletingId: number | null
    ownerCooperationId: number | null
    relationshipTypeId: number | null
    commission_amount: number | null
    deposit_amount: number | null
    deposit_paid: number | null
    owner_price_ideal: number | null
    owner_price_real: number | null
    owner_price_minimal: number | null
  }

  export type OwnerRelationSumAggregateOutputType = {
    id: number | null
    ownerShipId: number | null
    reasonDeletingId: number | null
    ownerCooperationId: number | null
    relationshipTypeId: number | null
    commission_amount: number | null
    deposit_amount: number | null
    deposit_paid: number | null
    owner_price_ideal: number | null
    owner_price_real: number | null
    owner_price_minimal: number | null
  }

  export type OwnerRelationMinAggregateOutputType = {
    id: number | null
    ownerShipId: number | null
    reasonDeletingId: number | null
    ownerCooperationId: number | null
    relationshipTypeId: number | null
    commission_amount: number | null
    commission_comment: string | null
    deposit_amount: number | null
    deposit_paid: number | null
    owner_price_ideal: number | null
    owner_price_real: number | null
    owner_price_minimal: number | null
  }

  export type OwnerRelationMaxAggregateOutputType = {
    id: number | null
    ownerShipId: number | null
    reasonDeletingId: number | null
    ownerCooperationId: number | null
    relationshipTypeId: number | null
    commission_amount: number | null
    commission_comment: string | null
    deposit_amount: number | null
    deposit_paid: number | null
    owner_price_ideal: number | null
    owner_price_real: number | null
    owner_price_minimal: number | null
  }

  export type OwnerRelationCountAggregateOutputType = {
    id: number
    ownerShipId: number
    reasonDeletingId: number
    ownerCooperationId: number
    relationshipTypeId: number
    commission_amount: number
    commission_comment: number
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
    _all: number
  }


  export type OwnerRelationAvgAggregateInputType = {
    id?: true
    ownerShipId?: true
    reasonDeletingId?: true
    ownerCooperationId?: true
    relationshipTypeId?: true
    commission_amount?: true
    deposit_amount?: true
    deposit_paid?: true
    owner_price_ideal?: true
    owner_price_real?: true
    owner_price_minimal?: true
  }

  export type OwnerRelationSumAggregateInputType = {
    id?: true
    ownerShipId?: true
    reasonDeletingId?: true
    ownerCooperationId?: true
    relationshipTypeId?: true
    commission_amount?: true
    deposit_amount?: true
    deposit_paid?: true
    owner_price_ideal?: true
    owner_price_real?: true
    owner_price_minimal?: true
  }

  export type OwnerRelationMinAggregateInputType = {
    id?: true
    ownerShipId?: true
    reasonDeletingId?: true
    ownerCooperationId?: true
    relationshipTypeId?: true
    commission_amount?: true
    commission_comment?: true
    deposit_amount?: true
    deposit_paid?: true
    owner_price_ideal?: true
    owner_price_real?: true
    owner_price_minimal?: true
  }

  export type OwnerRelationMaxAggregateInputType = {
    id?: true
    ownerShipId?: true
    reasonDeletingId?: true
    ownerCooperationId?: true
    relationshipTypeId?: true
    commission_amount?: true
    commission_comment?: true
    deposit_amount?: true
    deposit_paid?: true
    owner_price_ideal?: true
    owner_price_real?: true
    owner_price_minimal?: true
  }

  export type OwnerRelationCountAggregateInputType = {
    id?: true
    ownerShipId?: true
    reasonDeletingId?: true
    ownerCooperationId?: true
    relationshipTypeId?: true
    commission_amount?: true
    commission_comment?: true
    deposit_amount?: true
    deposit_paid?: true
    owner_price_ideal?: true
    owner_price_real?: true
    owner_price_minimal?: true
    _all?: true
  }

  export type OwnerRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerRelation to aggregate.
     */
    where?: OwnerRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerRelations to fetch.
     */
    orderBy?: OwnerRelationOrderByWithRelationInput | OwnerRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerRelations
    **/
    _count?: true | OwnerRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerRelationMaxAggregateInputType
  }

  export type GetOwnerRelationAggregateType<T extends OwnerRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerRelation[P]>
      : GetScalarType<T[P], AggregateOwnerRelation[P]>
  }




  export type OwnerRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerRelationWhereInput
    orderBy?: OwnerRelationOrderByWithAggregationInput | OwnerRelationOrderByWithAggregationInput[]
    by: OwnerRelationScalarFieldEnum[] | OwnerRelationScalarFieldEnum
    having?: OwnerRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerRelationCountAggregateInputType | true
    _avg?: OwnerRelationAvgAggregateInputType
    _sum?: OwnerRelationSumAggregateInputType
    _min?: OwnerRelationMinAggregateInputType
    _max?: OwnerRelationMaxAggregateInputType
  }

  export type OwnerRelationGroupByOutputType = {
    id: number
    ownerShipId: number | null
    reasonDeletingId: number | null
    ownerCooperationId: number | null
    relationshipTypeId: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
    _count: OwnerRelationCountAggregateOutputType | null
    _avg: OwnerRelationAvgAggregateOutputType | null
    _sum: OwnerRelationSumAggregateOutputType | null
    _min: OwnerRelationMinAggregateOutputType | null
    _max: OwnerRelationMaxAggregateOutputType | null
  }

  type GetOwnerRelationGroupByPayload<T extends OwnerRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerRelationGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerRelationGroupByOutputType[P]>
        }
      >
    >


  export type OwnerRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerShipId?: boolean
    reasonDeletingId?: boolean
    ownerCooperationId?: boolean
    relationshipTypeId?: boolean
    commission_amount?: boolean
    commission_comment?: boolean
    deposit_amount?: boolean
    deposit_paid?: boolean
    owner_price_ideal?: boolean
    owner_price_real?: boolean
    owner_price_minimal?: boolean
    OwnerShip?: boolean | OwnerRelation$OwnerShipArgs<ExtArgs>
    ReasonDeleting?: boolean | OwnerRelation$ReasonDeletingArgs<ExtArgs>
    OwnerCooperation?: boolean | OwnerRelation$OwnerCooperationArgs<ExtArgs>
    RelationshipType?: boolean | OwnerRelation$RelationshipTypeArgs<ExtArgs>
  }, ExtArgs["result"]["ownerRelation"]>

  export type OwnerRelationSelectScalar = {
    id?: boolean
    ownerShipId?: boolean
    reasonDeletingId?: boolean
    ownerCooperationId?: boolean
    relationshipTypeId?: boolean
    commission_amount?: boolean
    commission_comment?: boolean
    deposit_amount?: boolean
    deposit_paid?: boolean
    owner_price_ideal?: boolean
    owner_price_real?: boolean
    owner_price_minimal?: boolean
  }


  export type OwnerRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OwnerShip?: boolean | OwnerRelation$OwnerShipArgs<ExtArgs>
    ReasonDeleting?: boolean | OwnerRelation$ReasonDeletingArgs<ExtArgs>
    OwnerCooperation?: boolean | OwnerRelation$OwnerCooperationArgs<ExtArgs>
    RelationshipType?: boolean | OwnerRelation$RelationshipTypeArgs<ExtArgs>
  }


  export type $OwnerRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerRelation"
    objects: {
      OwnerShip: Prisma.$OwnerShipPayload<ExtArgs> | null
      ReasonDeleting: Prisma.$ReasonDeletingPayload<ExtArgs> | null
      OwnerCooperation: Prisma.$OwnerCooperationPayload<ExtArgs> | null
      RelationshipType: Prisma.$RelationshipTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ownerShipId: number | null
      reasonDeletingId: number | null
      ownerCooperationId: number | null
      relationshipTypeId: number | null
      commission_amount: number
      commission_comment: string
      deposit_amount: number
      deposit_paid: number
      owner_price_ideal: number
      owner_price_real: number
      owner_price_minimal: number
    }, ExtArgs["result"]["ownerRelation"]>
    composites: {}
  }


  type OwnerRelationGetPayload<S extends boolean | null | undefined | OwnerRelationDefaultArgs> = $Result.GetResult<Prisma.$OwnerRelationPayload, S>

  type OwnerRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerRelationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerRelationCountAggregateInputType | true
    }

  export interface OwnerRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerRelation'], meta: { name: 'OwnerRelation' } }
    /**
     * Find zero or one OwnerRelation that matches the filter.
     * @param {OwnerRelationFindUniqueArgs} args - Arguments to find a OwnerRelation
     * @example
     * // Get one OwnerRelation
     * const ownerRelation = await prisma.ownerRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OwnerRelationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerRelationFindUniqueArgs<ExtArgs>>
    ): Prisma__OwnerRelationClient<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OwnerRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OwnerRelationFindUniqueOrThrowArgs} args - Arguments to find a OwnerRelation
     * @example
     * // Get one OwnerRelation
     * const ownerRelation = await prisma.ownerRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OwnerRelationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerRelationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OwnerRelationClient<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OwnerRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerRelationFindFirstArgs} args - Arguments to find a OwnerRelation
     * @example
     * // Get one OwnerRelation
     * const ownerRelation = await prisma.ownerRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OwnerRelationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerRelationFindFirstArgs<ExtArgs>>
    ): Prisma__OwnerRelationClient<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OwnerRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerRelationFindFirstOrThrowArgs} args - Arguments to find a OwnerRelation
     * @example
     * // Get one OwnerRelation
     * const ownerRelation = await prisma.ownerRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OwnerRelationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerRelationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OwnerRelationClient<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OwnerRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerRelations
     * const ownerRelations = await prisma.ownerRelation.findMany()
     * 
     * // Get first 10 OwnerRelations
     * const ownerRelations = await prisma.ownerRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerRelationWithIdOnly = await prisma.ownerRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OwnerRelationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerRelationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OwnerRelation.
     * @param {OwnerRelationCreateArgs} args - Arguments to create a OwnerRelation.
     * @example
     * // Create one OwnerRelation
     * const OwnerRelation = await prisma.ownerRelation.create({
     *   data: {
     *     // ... data to create a OwnerRelation
     *   }
     * })
     * 
    **/
    create<T extends OwnerRelationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerRelationCreateArgs<ExtArgs>>
    ): Prisma__OwnerRelationClient<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OwnerRelations.
     *     @param {OwnerRelationCreateManyArgs} args - Arguments to create many OwnerRelations.
     *     @example
     *     // Create many OwnerRelations
     *     const ownerRelation = await prisma.ownerRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OwnerRelationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerRelationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OwnerRelation.
     * @param {OwnerRelationDeleteArgs} args - Arguments to delete one OwnerRelation.
     * @example
     * // Delete one OwnerRelation
     * const OwnerRelation = await prisma.ownerRelation.delete({
     *   where: {
     *     // ... filter to delete one OwnerRelation
     *   }
     * })
     * 
    **/
    delete<T extends OwnerRelationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerRelationDeleteArgs<ExtArgs>>
    ): Prisma__OwnerRelationClient<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OwnerRelation.
     * @param {OwnerRelationUpdateArgs} args - Arguments to update one OwnerRelation.
     * @example
     * // Update one OwnerRelation
     * const ownerRelation = await prisma.ownerRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OwnerRelationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerRelationUpdateArgs<ExtArgs>>
    ): Prisma__OwnerRelationClient<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OwnerRelations.
     * @param {OwnerRelationDeleteManyArgs} args - Arguments to filter OwnerRelations to delete.
     * @example
     * // Delete a few OwnerRelations
     * const { count } = await prisma.ownerRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OwnerRelationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OwnerRelationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerRelations
     * const ownerRelation = await prisma.ownerRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OwnerRelationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerRelationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OwnerRelation.
     * @param {OwnerRelationUpsertArgs} args - Arguments to update or create a OwnerRelation.
     * @example
     * // Update or create a OwnerRelation
     * const ownerRelation = await prisma.ownerRelation.upsert({
     *   create: {
     *     // ... data to create a OwnerRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerRelation we want to update
     *   }
     * })
    **/
    upsert<T extends OwnerRelationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OwnerRelationUpsertArgs<ExtArgs>>
    ): Prisma__OwnerRelationClient<$Result.GetResult<Prisma.$OwnerRelationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OwnerRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerRelationCountArgs} args - Arguments to filter OwnerRelations to count.
     * @example
     * // Count the number of OwnerRelations
     * const count = await prisma.ownerRelation.count({
     *   where: {
     *     // ... the filter for the OwnerRelations we want to count
     *   }
     * })
    **/
    count<T extends OwnerRelationCountArgs>(
      args?: Subset<T, OwnerRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerRelationAggregateArgs>(args: Subset<T, OwnerRelationAggregateArgs>): Prisma.PrismaPromise<GetOwnerRelationAggregateType<T>>

    /**
     * Group by OwnerRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerRelationGroupByArgs['orderBy'] }
        : { orderBy?: OwnerRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerRelation model
   */
  readonly fields: OwnerRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    OwnerShip<T extends OwnerRelation$OwnerShipArgs<ExtArgs> = {}>(args?: Subset<T, OwnerRelation$OwnerShipArgs<ExtArgs>>): Prisma__OwnerShipClient<$Result.GetResult<Prisma.$OwnerShipPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ReasonDeleting<T extends OwnerRelation$ReasonDeletingArgs<ExtArgs> = {}>(args?: Subset<T, OwnerRelation$ReasonDeletingArgs<ExtArgs>>): Prisma__ReasonDeletingClient<$Result.GetResult<Prisma.$ReasonDeletingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    OwnerCooperation<T extends OwnerRelation$OwnerCooperationArgs<ExtArgs> = {}>(args?: Subset<T, OwnerRelation$OwnerCooperationArgs<ExtArgs>>): Prisma__OwnerCooperationClient<$Result.GetResult<Prisma.$OwnerCooperationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    RelationshipType<T extends OwnerRelation$RelationshipTypeArgs<ExtArgs> = {}>(args?: Subset<T, OwnerRelation$RelationshipTypeArgs<ExtArgs>>): Prisma__RelationshipTypeClient<$Result.GetResult<Prisma.$RelationshipTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OwnerRelation model
   */ 
  interface OwnerRelationFieldRefs {
    readonly id: FieldRef<"OwnerRelation", 'Int'>
    readonly ownerShipId: FieldRef<"OwnerRelation", 'Int'>
    readonly reasonDeletingId: FieldRef<"OwnerRelation", 'Int'>
    readonly ownerCooperationId: FieldRef<"OwnerRelation", 'Int'>
    readonly relationshipTypeId: FieldRef<"OwnerRelation", 'Int'>
    readonly commission_amount: FieldRef<"OwnerRelation", 'Float'>
    readonly commission_comment: FieldRef<"OwnerRelation", 'String'>
    readonly deposit_amount: FieldRef<"OwnerRelation", 'Float'>
    readonly deposit_paid: FieldRef<"OwnerRelation", 'Float'>
    readonly owner_price_ideal: FieldRef<"OwnerRelation", 'Float'>
    readonly owner_price_real: FieldRef<"OwnerRelation", 'Float'>
    readonly owner_price_minimal: FieldRef<"OwnerRelation", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OwnerRelation findUnique
   */
  export type OwnerRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerRelation to fetch.
     */
    where: OwnerRelationWhereUniqueInput
  }

  /**
   * OwnerRelation findUniqueOrThrow
   */
  export type OwnerRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerRelation to fetch.
     */
    where: OwnerRelationWhereUniqueInput
  }

  /**
   * OwnerRelation findFirst
   */
  export type OwnerRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerRelation to fetch.
     */
    where?: OwnerRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerRelations to fetch.
     */
    orderBy?: OwnerRelationOrderByWithRelationInput | OwnerRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerRelations.
     */
    cursor?: OwnerRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerRelations.
     */
    distinct?: OwnerRelationScalarFieldEnum | OwnerRelationScalarFieldEnum[]
  }

  /**
   * OwnerRelation findFirstOrThrow
   */
  export type OwnerRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerRelation to fetch.
     */
    where?: OwnerRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerRelations to fetch.
     */
    orderBy?: OwnerRelationOrderByWithRelationInput | OwnerRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerRelations.
     */
    cursor?: OwnerRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerRelations.
     */
    distinct?: OwnerRelationScalarFieldEnum | OwnerRelationScalarFieldEnum[]
  }

  /**
   * OwnerRelation findMany
   */
  export type OwnerRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * Filter, which OwnerRelations to fetch.
     */
    where?: OwnerRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerRelations to fetch.
     */
    orderBy?: OwnerRelationOrderByWithRelationInput | OwnerRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerRelations.
     */
    cursor?: OwnerRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerRelations.
     */
    skip?: number
    distinct?: OwnerRelationScalarFieldEnum | OwnerRelationScalarFieldEnum[]
  }

  /**
   * OwnerRelation create
   */
  export type OwnerRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerRelation.
     */
    data: XOR<OwnerRelationCreateInput, OwnerRelationUncheckedCreateInput>
  }

  /**
   * OwnerRelation createMany
   */
  export type OwnerRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerRelations.
     */
    data: OwnerRelationCreateManyInput | OwnerRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerRelation update
   */
  export type OwnerRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerRelation.
     */
    data: XOR<OwnerRelationUpdateInput, OwnerRelationUncheckedUpdateInput>
    /**
     * Choose, which OwnerRelation to update.
     */
    where: OwnerRelationWhereUniqueInput
  }

  /**
   * OwnerRelation updateMany
   */
  export type OwnerRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerRelations.
     */
    data: XOR<OwnerRelationUpdateManyMutationInput, OwnerRelationUncheckedUpdateManyInput>
    /**
     * Filter which OwnerRelations to update
     */
    where?: OwnerRelationWhereInput
  }

  /**
   * OwnerRelation upsert
   */
  export type OwnerRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerRelation to update in case it exists.
     */
    where: OwnerRelationWhereUniqueInput
    /**
     * In case the OwnerRelation found by the `where` argument doesn't exist, create a new OwnerRelation with this data.
     */
    create: XOR<OwnerRelationCreateInput, OwnerRelationUncheckedCreateInput>
    /**
     * In case the OwnerRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerRelationUpdateInput, OwnerRelationUncheckedUpdateInput>
  }

  /**
   * OwnerRelation delete
   */
  export type OwnerRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
    /**
     * Filter which OwnerRelation to delete.
     */
    where: OwnerRelationWhereUniqueInput
  }

  /**
   * OwnerRelation deleteMany
   */
  export type OwnerRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerRelations to delete
     */
    where?: OwnerRelationWhereInput
  }

  /**
   * OwnerRelation.OwnerShip
   */
  export type OwnerRelation$OwnerShipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerShip
     */
    select?: OwnerShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerShipInclude<ExtArgs> | null
    where?: OwnerShipWhereInput
  }

  /**
   * OwnerRelation.ReasonDeleting
   */
  export type OwnerRelation$ReasonDeletingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReasonDeleting
     */
    select?: ReasonDeletingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReasonDeletingInclude<ExtArgs> | null
    where?: ReasonDeletingWhereInput
  }

  /**
   * OwnerRelation.OwnerCooperation
   */
  export type OwnerRelation$OwnerCooperationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCooperation
     */
    select?: OwnerCooperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerCooperationInclude<ExtArgs> | null
    where?: OwnerCooperationWhereInput
  }

  /**
   * OwnerRelation.RelationshipType
   */
  export type OwnerRelation$RelationshipTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipType
     */
    select?: RelationshipTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipTypeInclude<ExtArgs> | null
    where?: RelationshipTypeWhereInput
  }

  /**
   * OwnerRelation without action
   */
  export type OwnerRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerRelation
     */
    select?: OwnerRelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerRelationInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: number
    name: string
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean | Region$addressArgs<ExtArgs>
    district?: boolean | Region$districtArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Region$addressArgs<ExtArgs>
    district?: boolean | Region$districtArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>[]
      district: Prisma.$DistrictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["region"]>
    composites: {}
  }


  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Region that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
    **/
    create<T extends RegionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RegionCreateArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Regions.
     *     @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const region = await prisma.region.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
    **/
    delete<T extends RegionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
    **/
    upsert<T extends RegionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends Region$addressArgs<ExtArgs> = {}>(args?: Subset<T, Region$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'> | Null>;

    district<T extends Region$districtArgs<ExtArgs> = {}>(args?: Subset<T, Region$districtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Region model
   */ 
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'Int'>
    readonly name: FieldRef<"Region", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
  }

  /**
   * Region.address
   */
  export type Region$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Region.district
   */
  export type Region$districtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    cursor?: DistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model District
   */

  export type AggregateDistrict = {
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  export type DistrictAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
  }

  export type DistrictSumAggregateOutputType = {
    id: number | null
    regionId: number | null
  }

  export type DistrictMinAggregateOutputType = {
    id: number | null
    name: string | null
    regionId: number | null
  }

  export type DistrictMaxAggregateOutputType = {
    id: number | null
    name: string | null
    regionId: number | null
  }

  export type DistrictCountAggregateOutputType = {
    id: number
    name: number
    regionId: number
    _all: number
  }


  export type DistrictAvgAggregateInputType = {
    id?: true
    regionId?: true
  }

  export type DistrictSumAggregateInputType = {
    id?: true
    regionId?: true
  }

  export type DistrictMinAggregateInputType = {
    id?: true
    name?: true
    regionId?: true
  }

  export type DistrictMaxAggregateInputType = {
    id?: true
    name?: true
    regionId?: true
  }

  export type DistrictCountAggregateInputType = {
    id?: true
    name?: true
    regionId?: true
    _all?: true
  }

  export type DistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which District to aggregate.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Districts
    **/
    _count?: true | DistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistrictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistrictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictMaxAggregateInputType
  }

  export type GetDistrictAggregateType<T extends DistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrict[P]>
      : GetScalarType<T[P], AggregateDistrict[P]>
  }




  export type DistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithAggregationInput | DistrictOrderByWithAggregationInput[]
    by: DistrictScalarFieldEnum[] | DistrictScalarFieldEnum
    having?: DistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictCountAggregateInputType | true
    _avg?: DistrictAvgAggregateInputType
    _sum?: DistrictSumAggregateInputType
    _min?: DistrictMinAggregateInputType
    _max?: DistrictMaxAggregateInputType
  }

  export type DistrictGroupByOutputType = {
    id: number
    name: string
    regionId: number | null
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  type GetDistrictGroupByPayload<T extends DistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictGroupByOutputType[P]>
        }
      >
    >


  export type DistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    regionId?: boolean
    address?: boolean | District$addressArgs<ExtArgs>
    Region?: boolean | District$RegionArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectScalar = {
    id?: boolean
    name?: boolean
    regionId?: boolean
  }


  export type DistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | District$addressArgs<ExtArgs>
    Region?: boolean | District$RegionArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "District"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>[]
      Region: Prisma.$RegionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      regionId: number | null
    }, ExtArgs["result"]["district"]>
    composites: {}
  }


  type DistrictGetPayload<S extends boolean | null | undefined | DistrictDefaultArgs> = $Result.GetResult<Prisma.$DistrictPayload, S>

  type DistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistrictFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistrictCountAggregateInputType | true
    }

  export interface DistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['District'], meta: { name: 'District' } }
    /**
     * Find zero or one District that matches the filter.
     * @param {DistrictFindUniqueArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DistrictFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DistrictFindUniqueArgs<ExtArgs>>
    ): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one District that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DistrictFindUniqueOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DistrictFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DistrictFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first District that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DistrictFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DistrictFindFirstArgs<ExtArgs>>
    ): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first District that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DistrictFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DistrictFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.district.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.district.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtWithIdOnly = await prisma.district.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DistrictFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistrictFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a District.
     * @param {DistrictCreateArgs} args - Arguments to create a District.
     * @example
     * // Create one District
     * const District = await prisma.district.create({
     *   data: {
     *     // ... data to create a District
     *   }
     * })
     * 
    **/
    create<T extends DistrictCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DistrictCreateArgs<ExtArgs>>
    ): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Districts.
     *     @param {DistrictCreateManyArgs} args - Arguments to create many Districts.
     *     @example
     *     // Create many Districts
     *     const district = await prisma.district.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DistrictCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistrictCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a District.
     * @param {DistrictDeleteArgs} args - Arguments to delete one District.
     * @example
     * // Delete one District
     * const District = await prisma.district.delete({
     *   where: {
     *     // ... filter to delete one District
     *   }
     * })
     * 
    **/
    delete<T extends DistrictDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DistrictDeleteArgs<ExtArgs>>
    ): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one District.
     * @param {DistrictUpdateArgs} args - Arguments to update one District.
     * @example
     * // Update one District
     * const district = await prisma.district.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DistrictUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DistrictUpdateArgs<ExtArgs>>
    ): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Districts.
     * @param {DistrictDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.district.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DistrictDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistrictDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DistrictUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DistrictUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one District.
     * @param {DistrictUpsertArgs} args - Arguments to update or create a District.
     * @example
     * // Update or create a District
     * const district = await prisma.district.upsert({
     *   create: {
     *     // ... data to create a District
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the District we want to update
     *   }
     * })
    **/
    upsert<T extends DistrictUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DistrictUpsertArgs<ExtArgs>>
    ): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.district.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends DistrictCountArgs>(
      args?: Subset<T, DistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictAggregateArgs>(args: Subset<T, DistrictAggregateArgs>): Prisma.PrismaPromise<GetDistrictAggregateType<T>>

    /**
     * Group by District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistrictGroupByArgs['orderBy'] }
        : { orderBy?: DistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the District model
   */
  readonly fields: DistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for District.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends District$addressArgs<ExtArgs> = {}>(args?: Subset<T, District$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'> | Null>;

    Region<T extends District$RegionArgs<ExtArgs> = {}>(args?: Subset<T, District$RegionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the District model
   */ 
  interface DistrictFieldRefs {
    readonly id: FieldRef<"District", 'Int'>
    readonly name: FieldRef<"District", 'String'>
    readonly regionId: FieldRef<"District", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * District findUnique
   */
  export type DistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findUniqueOrThrow
   */
  export type DistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findFirst
   */
  export type DistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findFirstOrThrow
   */
  export type DistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findMany
   */
  export type DistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which Districts to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District create
   */
  export type DistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a District.
     */
    data: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
  }

  /**
   * District createMany
   */
  export type DistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District update
   */
  export type DistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a District.
     */
    data: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
    /**
     * Choose, which District to update.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District updateMany
   */
  export type DistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
  }

  /**
   * District upsert
   */
  export type DistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the District to update in case it exists.
     */
    where: DistrictWhereUniqueInput
    /**
     * In case the District found by the `where` argument doesn't exist, create a new District with this data.
     */
    create: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
    /**
     * In case the District was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
  }

  /**
   * District delete
   */
  export type DistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter which District to delete.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District deleteMany
   */
  export type DistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Districts to delete
     */
    where?: DistrictWhereInput
  }

  /**
   * District.address
   */
  export type District$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * District.Region
   */
  export type District$RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * District without action
   */
  export type DistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
  }


  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaAvgAggregateOutputType = {
    id: number | null
  }

  export type AreaSumAggregateOutputType = {
    id: number | null
  }

  export type AreaMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type AreaMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type AreaAvgAggregateInputType = {
    id?: true
  }

  export type AreaSumAggregateInputType = {
    id?: true
  }

  export type AreaMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _avg?: AreaAvgAggregateInputType
    _sum?: AreaSumAggregateInputType
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: number
    name: string
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean | Area$addressArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Area$addressArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["area"]>
    composites: {}
  }


  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AreaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Area that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AreaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AreaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
    **/
    create<T extends AreaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AreaCreateArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Areas.
     *     @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     *     @example
     *     // Create many Areas
     *     const area = await prisma.area.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AreaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
    **/
    delete<T extends AreaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AreaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AreaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AreaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
    **/
    upsert<T extends AreaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>
    ): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends Area$addressArgs<ExtArgs> = {}>(args?: Subset<T, Area$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Area model
   */ 
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'Int'>
    readonly name: FieldRef<"Area", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }

  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
  }

  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }

  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
  }

  /**
   * Area.address
   */
  export type Area$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
  }


  /**
   * Model Mahalla
   */

  export type AggregateMahalla = {
    _count: MahallaCountAggregateOutputType | null
    _avg: MahallaAvgAggregateOutputType | null
    _sum: MahallaSumAggregateOutputType | null
    _min: MahallaMinAggregateOutputType | null
    _max: MahallaMaxAggregateOutputType | null
  }

  export type MahallaAvgAggregateOutputType = {
    id: number | null
  }

  export type MahallaSumAggregateOutputType = {
    id: number | null
  }

  export type MahallaMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MahallaMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MahallaCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type MahallaAvgAggregateInputType = {
    id?: true
  }

  export type MahallaSumAggregateInputType = {
    id?: true
  }

  export type MahallaMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type MahallaMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type MahallaCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type MahallaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mahalla to aggregate.
     */
    where?: MahallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahallas to fetch.
     */
    orderBy?: MahallaOrderByWithRelationInput | MahallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MahallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mahallas
    **/
    _count?: true | MahallaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MahallaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MahallaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MahallaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MahallaMaxAggregateInputType
  }

  export type GetMahallaAggregateType<T extends MahallaAggregateArgs> = {
        [P in keyof T & keyof AggregateMahalla]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMahalla[P]>
      : GetScalarType<T[P], AggregateMahalla[P]>
  }




  export type MahallaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MahallaWhereInput
    orderBy?: MahallaOrderByWithAggregationInput | MahallaOrderByWithAggregationInput[]
    by: MahallaScalarFieldEnum[] | MahallaScalarFieldEnum
    having?: MahallaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MahallaCountAggregateInputType | true
    _avg?: MahallaAvgAggregateInputType
    _sum?: MahallaSumAggregateInputType
    _min?: MahallaMinAggregateInputType
    _max?: MahallaMaxAggregateInputType
  }

  export type MahallaGroupByOutputType = {
    id: number
    name: string
    _count: MahallaCountAggregateOutputType | null
    _avg: MahallaAvgAggregateOutputType | null
    _sum: MahallaSumAggregateOutputType | null
    _min: MahallaMinAggregateOutputType | null
    _max: MahallaMaxAggregateOutputType | null
  }

  type GetMahallaGroupByPayload<T extends MahallaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MahallaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MahallaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MahallaGroupByOutputType[P]>
            : GetScalarType<T[P], MahallaGroupByOutputType[P]>
        }
      >
    >


  export type MahallaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean | Mahalla$addressArgs<ExtArgs>
    _count?: boolean | MahallaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mahalla"]>

  export type MahallaSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type MahallaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Mahalla$addressArgs<ExtArgs>
    _count?: boolean | MahallaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MahallaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mahalla"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["mahalla"]>
    composites: {}
  }


  type MahallaGetPayload<S extends boolean | null | undefined | MahallaDefaultArgs> = $Result.GetResult<Prisma.$MahallaPayload, S>

  type MahallaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MahallaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MahallaCountAggregateInputType | true
    }

  export interface MahallaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mahalla'], meta: { name: 'Mahalla' } }
    /**
     * Find zero or one Mahalla that matches the filter.
     * @param {MahallaFindUniqueArgs} args - Arguments to find a Mahalla
     * @example
     * // Get one Mahalla
     * const mahalla = await prisma.mahalla.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MahallaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MahallaFindUniqueArgs<ExtArgs>>
    ): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Mahalla that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MahallaFindUniqueOrThrowArgs} args - Arguments to find a Mahalla
     * @example
     * // Get one Mahalla
     * const mahalla = await prisma.mahalla.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MahallaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MahallaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Mahalla that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahallaFindFirstArgs} args - Arguments to find a Mahalla
     * @example
     * // Get one Mahalla
     * const mahalla = await prisma.mahalla.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MahallaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MahallaFindFirstArgs<ExtArgs>>
    ): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Mahalla that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahallaFindFirstOrThrowArgs} args - Arguments to find a Mahalla
     * @example
     * // Get one Mahalla
     * const mahalla = await prisma.mahalla.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MahallaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MahallaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Mahallas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahallaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mahallas
     * const mahallas = await prisma.mahalla.findMany()
     * 
     * // Get first 10 Mahallas
     * const mahallas = await prisma.mahalla.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mahallaWithIdOnly = await prisma.mahalla.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MahallaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MahallaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Mahalla.
     * @param {MahallaCreateArgs} args - Arguments to create a Mahalla.
     * @example
     * // Create one Mahalla
     * const Mahalla = await prisma.mahalla.create({
     *   data: {
     *     // ... data to create a Mahalla
     *   }
     * })
     * 
    **/
    create<T extends MahallaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MahallaCreateArgs<ExtArgs>>
    ): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Mahallas.
     *     @param {MahallaCreateManyArgs} args - Arguments to create many Mahallas.
     *     @example
     *     // Create many Mahallas
     *     const mahalla = await prisma.mahalla.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MahallaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MahallaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mahalla.
     * @param {MahallaDeleteArgs} args - Arguments to delete one Mahalla.
     * @example
     * // Delete one Mahalla
     * const Mahalla = await prisma.mahalla.delete({
     *   where: {
     *     // ... filter to delete one Mahalla
     *   }
     * })
     * 
    **/
    delete<T extends MahallaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MahallaDeleteArgs<ExtArgs>>
    ): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Mahalla.
     * @param {MahallaUpdateArgs} args - Arguments to update one Mahalla.
     * @example
     * // Update one Mahalla
     * const mahalla = await prisma.mahalla.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MahallaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MahallaUpdateArgs<ExtArgs>>
    ): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Mahallas.
     * @param {MahallaDeleteManyArgs} args - Arguments to filter Mahallas to delete.
     * @example
     * // Delete a few Mahallas
     * const { count } = await prisma.mahalla.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MahallaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MahallaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mahallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahallaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mahallas
     * const mahalla = await prisma.mahalla.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MahallaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MahallaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mahalla.
     * @param {MahallaUpsertArgs} args - Arguments to update or create a Mahalla.
     * @example
     * // Update or create a Mahalla
     * const mahalla = await prisma.mahalla.upsert({
     *   create: {
     *     // ... data to create a Mahalla
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mahalla we want to update
     *   }
     * })
    **/
    upsert<T extends MahallaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MahallaUpsertArgs<ExtArgs>>
    ): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Mahallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahallaCountArgs} args - Arguments to filter Mahallas to count.
     * @example
     * // Count the number of Mahallas
     * const count = await prisma.mahalla.count({
     *   where: {
     *     // ... the filter for the Mahallas we want to count
     *   }
     * })
    **/
    count<T extends MahallaCountArgs>(
      args?: Subset<T, MahallaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MahallaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mahalla.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahallaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MahallaAggregateArgs>(args: Subset<T, MahallaAggregateArgs>): Prisma.PrismaPromise<GetMahallaAggregateType<T>>

    /**
     * Group by Mahalla.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahallaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MahallaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MahallaGroupByArgs['orderBy'] }
        : { orderBy?: MahallaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MahallaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMahallaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mahalla model
   */
  readonly fields: MahallaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mahalla.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MahallaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends Mahalla$addressArgs<ExtArgs> = {}>(args?: Subset<T, Mahalla$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Mahalla model
   */ 
  interface MahallaFieldRefs {
    readonly id: FieldRef<"Mahalla", 'Int'>
    readonly name: FieldRef<"Mahalla", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Mahalla findUnique
   */
  export type MahallaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * Filter, which Mahalla to fetch.
     */
    where: MahallaWhereUniqueInput
  }

  /**
   * Mahalla findUniqueOrThrow
   */
  export type MahallaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * Filter, which Mahalla to fetch.
     */
    where: MahallaWhereUniqueInput
  }

  /**
   * Mahalla findFirst
   */
  export type MahallaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * Filter, which Mahalla to fetch.
     */
    where?: MahallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahallas to fetch.
     */
    orderBy?: MahallaOrderByWithRelationInput | MahallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mahallas.
     */
    cursor?: MahallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mahallas.
     */
    distinct?: MahallaScalarFieldEnum | MahallaScalarFieldEnum[]
  }

  /**
   * Mahalla findFirstOrThrow
   */
  export type MahallaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * Filter, which Mahalla to fetch.
     */
    where?: MahallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahallas to fetch.
     */
    orderBy?: MahallaOrderByWithRelationInput | MahallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mahallas.
     */
    cursor?: MahallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mahallas.
     */
    distinct?: MahallaScalarFieldEnum | MahallaScalarFieldEnum[]
  }

  /**
   * Mahalla findMany
   */
  export type MahallaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * Filter, which Mahallas to fetch.
     */
    where?: MahallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahallas to fetch.
     */
    orderBy?: MahallaOrderByWithRelationInput | MahallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mahallas.
     */
    cursor?: MahallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahallas.
     */
    skip?: number
    distinct?: MahallaScalarFieldEnum | MahallaScalarFieldEnum[]
  }

  /**
   * Mahalla create
   */
  export type MahallaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * The data needed to create a Mahalla.
     */
    data: XOR<MahallaCreateInput, MahallaUncheckedCreateInput>
  }

  /**
   * Mahalla createMany
   */
  export type MahallaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mahallas.
     */
    data: MahallaCreateManyInput | MahallaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mahalla update
   */
  export type MahallaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * The data needed to update a Mahalla.
     */
    data: XOR<MahallaUpdateInput, MahallaUncheckedUpdateInput>
    /**
     * Choose, which Mahalla to update.
     */
    where: MahallaWhereUniqueInput
  }

  /**
   * Mahalla updateMany
   */
  export type MahallaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mahallas.
     */
    data: XOR<MahallaUpdateManyMutationInput, MahallaUncheckedUpdateManyInput>
    /**
     * Filter which Mahallas to update
     */
    where?: MahallaWhereInput
  }

  /**
   * Mahalla upsert
   */
  export type MahallaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * The filter to search for the Mahalla to update in case it exists.
     */
    where: MahallaWhereUniqueInput
    /**
     * In case the Mahalla found by the `where` argument doesn't exist, create a new Mahalla with this data.
     */
    create: XOR<MahallaCreateInput, MahallaUncheckedCreateInput>
    /**
     * In case the Mahalla was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MahallaUpdateInput, MahallaUncheckedUpdateInput>
  }

  /**
   * Mahalla delete
   */
  export type MahallaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    /**
     * Filter which Mahalla to delete.
     */
    where: MahallaWhereUniqueInput
  }

  /**
   * Mahalla deleteMany
   */
  export type MahallaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mahallas to delete
     */
    where?: MahallaWhereInput
  }

  /**
   * Mahalla.address
   */
  export type Mahalla$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Mahalla without action
   */
  export type MahallaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
  }


  /**
   * Model Street
   */

  export type AggregateStreet = {
    _count: StreetCountAggregateOutputType | null
    _avg: StreetAvgAggregateOutputType | null
    _sum: StreetSumAggregateOutputType | null
    _min: StreetMinAggregateOutputType | null
    _max: StreetMaxAggregateOutputType | null
  }

  export type StreetAvgAggregateOutputType = {
    id: number | null
  }

  export type StreetSumAggregateOutputType = {
    id: number | null
  }

  export type StreetMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type StreetMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type StreetCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type StreetAvgAggregateInputType = {
    id?: true
  }

  export type StreetSumAggregateInputType = {
    id?: true
  }

  export type StreetMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type StreetMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type StreetCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type StreetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Street to aggregate.
     */
    where?: StreetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streets to fetch.
     */
    orderBy?: StreetOrderByWithRelationInput | StreetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Streets
    **/
    _count?: true | StreetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StreetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StreetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreetMaxAggregateInputType
  }

  export type GetStreetAggregateType<T extends StreetAggregateArgs> = {
        [P in keyof T & keyof AggregateStreet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStreet[P]>
      : GetScalarType<T[P], AggregateStreet[P]>
  }




  export type StreetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreetWhereInput
    orderBy?: StreetOrderByWithAggregationInput | StreetOrderByWithAggregationInput[]
    by: StreetScalarFieldEnum[] | StreetScalarFieldEnum
    having?: StreetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreetCountAggregateInputType | true
    _avg?: StreetAvgAggregateInputType
    _sum?: StreetSumAggregateInputType
    _min?: StreetMinAggregateInputType
    _max?: StreetMaxAggregateInputType
  }

  export type StreetGroupByOutputType = {
    id: number
    name: string
    _count: StreetCountAggregateOutputType | null
    _avg: StreetAvgAggregateOutputType | null
    _sum: StreetSumAggregateOutputType | null
    _min: StreetMinAggregateOutputType | null
    _max: StreetMaxAggregateOutputType | null
  }

  type GetStreetGroupByPayload<T extends StreetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreetGroupByOutputType[P]>
            : GetScalarType<T[P], StreetGroupByOutputType[P]>
        }
      >
    >


  export type StreetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean | Street$addressArgs<ExtArgs>
    _count?: boolean | StreetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["street"]>

  export type StreetSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type StreetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Street$addressArgs<ExtArgs>
    _count?: boolean | StreetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StreetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Street"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["street"]>
    composites: {}
  }


  type StreetGetPayload<S extends boolean | null | undefined | StreetDefaultArgs> = $Result.GetResult<Prisma.$StreetPayload, S>

  type StreetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StreetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StreetCountAggregateInputType | true
    }

  export interface StreetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Street'], meta: { name: 'Street' } }
    /**
     * Find zero or one Street that matches the filter.
     * @param {StreetFindUniqueArgs} args - Arguments to find a Street
     * @example
     * // Get one Street
     * const street = await prisma.street.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StreetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StreetFindUniqueArgs<ExtArgs>>
    ): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Street that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StreetFindUniqueOrThrowArgs} args - Arguments to find a Street
     * @example
     * // Get one Street
     * const street = await prisma.street.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StreetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StreetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Street that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreetFindFirstArgs} args - Arguments to find a Street
     * @example
     * // Get one Street
     * const street = await prisma.street.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StreetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StreetFindFirstArgs<ExtArgs>>
    ): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Street that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreetFindFirstOrThrowArgs} args - Arguments to find a Street
     * @example
     * // Get one Street
     * const street = await prisma.street.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StreetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StreetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Streets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Streets
     * const streets = await prisma.street.findMany()
     * 
     * // Get first 10 Streets
     * const streets = await prisma.street.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const streetWithIdOnly = await prisma.street.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StreetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StreetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Street.
     * @param {StreetCreateArgs} args - Arguments to create a Street.
     * @example
     * // Create one Street
     * const Street = await prisma.street.create({
     *   data: {
     *     // ... data to create a Street
     *   }
     * })
     * 
    **/
    create<T extends StreetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StreetCreateArgs<ExtArgs>>
    ): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Streets.
     *     @param {StreetCreateManyArgs} args - Arguments to create many Streets.
     *     @example
     *     // Create many Streets
     *     const street = await prisma.street.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StreetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StreetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Street.
     * @param {StreetDeleteArgs} args - Arguments to delete one Street.
     * @example
     * // Delete one Street
     * const Street = await prisma.street.delete({
     *   where: {
     *     // ... filter to delete one Street
     *   }
     * })
     * 
    **/
    delete<T extends StreetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StreetDeleteArgs<ExtArgs>>
    ): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Street.
     * @param {StreetUpdateArgs} args - Arguments to update one Street.
     * @example
     * // Update one Street
     * const street = await prisma.street.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StreetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StreetUpdateArgs<ExtArgs>>
    ): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Streets.
     * @param {StreetDeleteManyArgs} args - Arguments to filter Streets to delete.
     * @example
     * // Delete a few Streets
     * const { count } = await prisma.street.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StreetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StreetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Streets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Streets
     * const street = await prisma.street.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StreetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StreetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Street.
     * @param {StreetUpsertArgs} args - Arguments to update or create a Street.
     * @example
     * // Update or create a Street
     * const street = await prisma.street.upsert({
     *   create: {
     *     // ... data to create a Street
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Street we want to update
     *   }
     * })
    **/
    upsert<T extends StreetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StreetUpsertArgs<ExtArgs>>
    ): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Streets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreetCountArgs} args - Arguments to filter Streets to count.
     * @example
     * // Count the number of Streets
     * const count = await prisma.street.count({
     *   where: {
     *     // ... the filter for the Streets we want to count
     *   }
     * })
    **/
    count<T extends StreetCountArgs>(
      args?: Subset<T, StreetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Street.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreetAggregateArgs>(args: Subset<T, StreetAggregateArgs>): Prisma.PrismaPromise<GetStreetAggregateType<T>>

    /**
     * Group by Street.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreetGroupByArgs['orderBy'] }
        : { orderBy?: StreetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Street model
   */
  readonly fields: StreetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Street.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends Street$addressArgs<ExtArgs> = {}>(args?: Subset<T, Street$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Street model
   */ 
  interface StreetFieldRefs {
    readonly id: FieldRef<"Street", 'Int'>
    readonly name: FieldRef<"Street", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Street findUnique
   */
  export type StreetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * Filter, which Street to fetch.
     */
    where: StreetWhereUniqueInput
  }

  /**
   * Street findUniqueOrThrow
   */
  export type StreetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * Filter, which Street to fetch.
     */
    where: StreetWhereUniqueInput
  }

  /**
   * Street findFirst
   */
  export type StreetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * Filter, which Street to fetch.
     */
    where?: StreetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streets to fetch.
     */
    orderBy?: StreetOrderByWithRelationInput | StreetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streets.
     */
    cursor?: StreetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streets.
     */
    distinct?: StreetScalarFieldEnum | StreetScalarFieldEnum[]
  }

  /**
   * Street findFirstOrThrow
   */
  export type StreetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * Filter, which Street to fetch.
     */
    where?: StreetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streets to fetch.
     */
    orderBy?: StreetOrderByWithRelationInput | StreetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streets.
     */
    cursor?: StreetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streets.
     */
    distinct?: StreetScalarFieldEnum | StreetScalarFieldEnum[]
  }

  /**
   * Street findMany
   */
  export type StreetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * Filter, which Streets to fetch.
     */
    where?: StreetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streets to fetch.
     */
    orderBy?: StreetOrderByWithRelationInput | StreetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Streets.
     */
    cursor?: StreetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streets.
     */
    skip?: number
    distinct?: StreetScalarFieldEnum | StreetScalarFieldEnum[]
  }

  /**
   * Street create
   */
  export type StreetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * The data needed to create a Street.
     */
    data: XOR<StreetCreateInput, StreetUncheckedCreateInput>
  }

  /**
   * Street createMany
   */
  export type StreetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Streets.
     */
    data: StreetCreateManyInput | StreetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Street update
   */
  export type StreetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * The data needed to update a Street.
     */
    data: XOR<StreetUpdateInput, StreetUncheckedUpdateInput>
    /**
     * Choose, which Street to update.
     */
    where: StreetWhereUniqueInput
  }

  /**
   * Street updateMany
   */
  export type StreetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Streets.
     */
    data: XOR<StreetUpdateManyMutationInput, StreetUncheckedUpdateManyInput>
    /**
     * Filter which Streets to update
     */
    where?: StreetWhereInput
  }

  /**
   * Street upsert
   */
  export type StreetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * The filter to search for the Street to update in case it exists.
     */
    where: StreetWhereUniqueInput
    /**
     * In case the Street found by the `where` argument doesn't exist, create a new Street with this data.
     */
    create: XOR<StreetCreateInput, StreetUncheckedCreateInput>
    /**
     * In case the Street was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreetUpdateInput, StreetUncheckedUpdateInput>
  }

  /**
   * Street delete
   */
  export type StreetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    /**
     * Filter which Street to delete.
     */
    where: StreetWhereUniqueInput
  }

  /**
   * Street deleteMany
   */
  export type StreetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Streets to delete
     */
    where?: StreetWhereInput
  }

  /**
   * Street.address
   */
  export type Street$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Street without action
   */
  export type StreetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
  }


  /**
   * Model Metro
   */

  export type AggregateMetro = {
    _count: MetroCountAggregateOutputType | null
    _avg: MetroAvgAggregateOutputType | null
    _sum: MetroSumAggregateOutputType | null
    _min: MetroMinAggregateOutputType | null
    _max: MetroMaxAggregateOutputType | null
  }

  export type MetroAvgAggregateOutputType = {
    id: number | null
  }

  export type MetroSumAggregateOutputType = {
    id: number | null
  }

  export type MetroMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MetroMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MetroCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type MetroAvgAggregateInputType = {
    id?: true
  }

  export type MetroSumAggregateInputType = {
    id?: true
  }

  export type MetroMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type MetroMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type MetroCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type MetroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metro to aggregate.
     */
    where?: MetroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metros to fetch.
     */
    orderBy?: MetroOrderByWithRelationInput | MetroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metros
    **/
    _count?: true | MetroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetroMaxAggregateInputType
  }

  export type GetMetroAggregateType<T extends MetroAggregateArgs> = {
        [P in keyof T & keyof AggregateMetro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetro[P]>
      : GetScalarType<T[P], AggregateMetro[P]>
  }




  export type MetroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetroWhereInput
    orderBy?: MetroOrderByWithAggregationInput | MetroOrderByWithAggregationInput[]
    by: MetroScalarFieldEnum[] | MetroScalarFieldEnum
    having?: MetroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetroCountAggregateInputType | true
    _avg?: MetroAvgAggregateInputType
    _sum?: MetroSumAggregateInputType
    _min?: MetroMinAggregateInputType
    _max?: MetroMaxAggregateInputType
  }

  export type MetroGroupByOutputType = {
    id: number
    name: string
    _count: MetroCountAggregateOutputType | null
    _avg: MetroAvgAggregateOutputType | null
    _sum: MetroSumAggregateOutputType | null
    _min: MetroMinAggregateOutputType | null
    _max: MetroMaxAggregateOutputType | null
  }

  type GetMetroGroupByPayload<T extends MetroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetroGroupByOutputType[P]>
            : GetScalarType<T[P], MetroGroupByOutputType[P]>
        }
      >
    >


  export type MetroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean | Metro$addressArgs<ExtArgs>
    _count?: boolean | MetroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metro"]>

  export type MetroSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type MetroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Metro$addressArgs<ExtArgs>
    _count?: boolean | MetroCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MetroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metro"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["metro"]>
    composites: {}
  }


  type MetroGetPayload<S extends boolean | null | undefined | MetroDefaultArgs> = $Result.GetResult<Prisma.$MetroPayload, S>

  type MetroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MetroFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MetroCountAggregateInputType | true
    }

  export interface MetroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metro'], meta: { name: 'Metro' } }
    /**
     * Find zero or one Metro that matches the filter.
     * @param {MetroFindUniqueArgs} args - Arguments to find a Metro
     * @example
     * // Get one Metro
     * const metro = await prisma.metro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MetroFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MetroFindUniqueArgs<ExtArgs>>
    ): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Metro that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MetroFindUniqueOrThrowArgs} args - Arguments to find a Metro
     * @example
     * // Get one Metro
     * const metro = await prisma.metro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MetroFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MetroFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Metro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetroFindFirstArgs} args - Arguments to find a Metro
     * @example
     * // Get one Metro
     * const metro = await prisma.metro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MetroFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MetroFindFirstArgs<ExtArgs>>
    ): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Metro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetroFindFirstOrThrowArgs} args - Arguments to find a Metro
     * @example
     * // Get one Metro
     * const metro = await prisma.metro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MetroFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MetroFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Metros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetroFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metros
     * const metros = await prisma.metro.findMany()
     * 
     * // Get first 10 Metros
     * const metros = await prisma.metro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metroWithIdOnly = await prisma.metro.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MetroFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MetroFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Metro.
     * @param {MetroCreateArgs} args - Arguments to create a Metro.
     * @example
     * // Create one Metro
     * const Metro = await prisma.metro.create({
     *   data: {
     *     // ... data to create a Metro
     *   }
     * })
     * 
    **/
    create<T extends MetroCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MetroCreateArgs<ExtArgs>>
    ): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Metros.
     *     @param {MetroCreateManyArgs} args - Arguments to create many Metros.
     *     @example
     *     // Create many Metros
     *     const metro = await prisma.metro.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MetroCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MetroCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Metro.
     * @param {MetroDeleteArgs} args - Arguments to delete one Metro.
     * @example
     * // Delete one Metro
     * const Metro = await prisma.metro.delete({
     *   where: {
     *     // ... filter to delete one Metro
     *   }
     * })
     * 
    **/
    delete<T extends MetroDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MetroDeleteArgs<ExtArgs>>
    ): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Metro.
     * @param {MetroUpdateArgs} args - Arguments to update one Metro.
     * @example
     * // Update one Metro
     * const metro = await prisma.metro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MetroUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MetroUpdateArgs<ExtArgs>>
    ): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Metros.
     * @param {MetroDeleteManyArgs} args - Arguments to filter Metros to delete.
     * @example
     * // Delete a few Metros
     * const { count } = await prisma.metro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MetroDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MetroDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metros
     * const metro = await prisma.metro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MetroUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MetroUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Metro.
     * @param {MetroUpsertArgs} args - Arguments to update or create a Metro.
     * @example
     * // Update or create a Metro
     * const metro = await prisma.metro.upsert({
     *   create: {
     *     // ... data to create a Metro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metro we want to update
     *   }
     * })
    **/
    upsert<T extends MetroUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MetroUpsertArgs<ExtArgs>>
    ): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Metros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetroCountArgs} args - Arguments to filter Metros to count.
     * @example
     * // Count the number of Metros
     * const count = await prisma.metro.count({
     *   where: {
     *     // ... the filter for the Metros we want to count
     *   }
     * })
    **/
    count<T extends MetroCountArgs>(
      args?: Subset<T, MetroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetroAggregateArgs>(args: Subset<T, MetroAggregateArgs>): Prisma.PrismaPromise<GetMetroAggregateType<T>>

    /**
     * Group by Metro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetroGroupByArgs['orderBy'] }
        : { orderBy?: MetroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metro model
   */
  readonly fields: MetroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends Metro$addressArgs<ExtArgs> = {}>(args?: Subset<T, Metro$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Metro model
   */ 
  interface MetroFieldRefs {
    readonly id: FieldRef<"Metro", 'Int'>
    readonly name: FieldRef<"Metro", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Metro findUnique
   */
  export type MetroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * Filter, which Metro to fetch.
     */
    where: MetroWhereUniqueInput
  }

  /**
   * Metro findUniqueOrThrow
   */
  export type MetroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * Filter, which Metro to fetch.
     */
    where: MetroWhereUniqueInput
  }

  /**
   * Metro findFirst
   */
  export type MetroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * Filter, which Metro to fetch.
     */
    where?: MetroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metros to fetch.
     */
    orderBy?: MetroOrderByWithRelationInput | MetroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metros.
     */
    cursor?: MetroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metros.
     */
    distinct?: MetroScalarFieldEnum | MetroScalarFieldEnum[]
  }

  /**
   * Metro findFirstOrThrow
   */
  export type MetroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * Filter, which Metro to fetch.
     */
    where?: MetroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metros to fetch.
     */
    orderBy?: MetroOrderByWithRelationInput | MetroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metros.
     */
    cursor?: MetroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metros.
     */
    distinct?: MetroScalarFieldEnum | MetroScalarFieldEnum[]
  }

  /**
   * Metro findMany
   */
  export type MetroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * Filter, which Metros to fetch.
     */
    where?: MetroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metros to fetch.
     */
    orderBy?: MetroOrderByWithRelationInput | MetroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metros.
     */
    cursor?: MetroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metros.
     */
    skip?: number
    distinct?: MetroScalarFieldEnum | MetroScalarFieldEnum[]
  }

  /**
   * Metro create
   */
  export type MetroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * The data needed to create a Metro.
     */
    data: XOR<MetroCreateInput, MetroUncheckedCreateInput>
  }

  /**
   * Metro createMany
   */
  export type MetroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metros.
     */
    data: MetroCreateManyInput | MetroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metro update
   */
  export type MetroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * The data needed to update a Metro.
     */
    data: XOR<MetroUpdateInput, MetroUncheckedUpdateInput>
    /**
     * Choose, which Metro to update.
     */
    where: MetroWhereUniqueInput
  }

  /**
   * Metro updateMany
   */
  export type MetroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metros.
     */
    data: XOR<MetroUpdateManyMutationInput, MetroUncheckedUpdateManyInput>
    /**
     * Filter which Metros to update
     */
    where?: MetroWhereInput
  }

  /**
   * Metro upsert
   */
  export type MetroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * The filter to search for the Metro to update in case it exists.
     */
    where: MetroWhereUniqueInput
    /**
     * In case the Metro found by the `where` argument doesn't exist, create a new Metro with this data.
     */
    create: XOR<MetroCreateInput, MetroUncheckedCreateInput>
    /**
     * In case the Metro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetroUpdateInput, MetroUncheckedUpdateInput>
  }

  /**
   * Metro delete
   */
  export type MetroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    /**
     * Filter which Metro to delete.
     */
    where: MetroWhereUniqueInput
  }

  /**
   * Metro deleteMany
   */
  export type MetroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metros to delete
     */
    where?: MetroWhereInput
  }

  /**
   * Metro.address
   */
  export type Metro$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Metro without action
   */
  export type MetroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
    districtId: number | null
    areaId: number | null
    mahallaId: number | null
    streetId: number | null
    house_number: number | null
    apartment_number: number | null
    metroId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    regionId: number | null
    districtId: number | null
    areaId: number | null
    mahallaId: number | null
    streetId: number | null
    house_number: number | null
    apartment_number: number | null
    metroId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    regionId: number | null
    districtId: number | null
    areaId: number | null
    mahallaId: number | null
    streetId: number | null
    house_number: number | null
    apartment_number: number | null
    location: string | null
    landmark: boolean | null
    metroId: number | null
    location_description: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    regionId: number | null
    districtId: number | null
    areaId: number | null
    mahallaId: number | null
    streetId: number | null
    house_number: number | null
    apartment_number: number | null
    location: string | null
    landmark: boolean | null
    metroId: number | null
    location_description: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    regionId: number
    districtId: number
    areaId: number
    mahallaId: number
    streetId: number
    house_number: number
    apartment_number: number
    location: number
    landmark: number
    metroId: number
    location_description: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    regionId?: true
    districtId?: true
    areaId?: true
    mahallaId?: true
    streetId?: true
    house_number?: true
    apartment_number?: true
    metroId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    regionId?: true
    districtId?: true
    areaId?: true
    mahallaId?: true
    streetId?: true
    house_number?: true
    apartment_number?: true
    metroId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    regionId?: true
    districtId?: true
    areaId?: true
    mahallaId?: true
    streetId?: true
    house_number?: true
    apartment_number?: true
    location?: true
    landmark?: true
    metroId?: true
    location_description?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    regionId?: true
    districtId?: true
    areaId?: true
    mahallaId?: true
    streetId?: true
    house_number?: true
    apartment_number?: true
    location?: true
    landmark?: true
    metroId?: true
    location_description?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    regionId?: true
    districtId?: true
    areaId?: true
    mahallaId?: true
    streetId?: true
    house_number?: true
    apartment_number?: true
    location?: true
    landmark?: true
    metroId?: true
    location_description?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    regionId: number | null
    districtId: number | null
    areaId: number | null
    mahallaId: number | null
    streetId: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId: number | null
    location_description: string
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    districtId?: boolean
    areaId?: boolean
    mahallaId?: boolean
    streetId?: boolean
    house_number?: boolean
    apartment_number?: boolean
    location?: boolean
    landmark?: boolean
    metroId?: boolean
    location_description?: boolean
    Region?: boolean | Address$RegionArgs<ExtArgs>
    District?: boolean | Address$DistrictArgs<ExtArgs>
    Area?: boolean | Address$AreaArgs<ExtArgs>
    Mahalla?: boolean | Address$MahallaArgs<ExtArgs>
    Street?: boolean | Address$StreetArgs<ExtArgs>
    Metro?: boolean | Address$MetroArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    regionId?: boolean
    districtId?: boolean
    areaId?: boolean
    mahallaId?: boolean
    streetId?: boolean
    house_number?: boolean
    apartment_number?: boolean
    location?: boolean
    landmark?: boolean
    metroId?: boolean
    location_description?: boolean
  }


  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Region?: boolean | Address$RegionArgs<ExtArgs>
    District?: boolean | Address$DistrictArgs<ExtArgs>
    Area?: boolean | Address$AreaArgs<ExtArgs>
    Mahalla?: boolean | Address$MahallaArgs<ExtArgs>
    Street?: boolean | Address$StreetArgs<ExtArgs>
    Metro?: boolean | Address$MetroArgs<ExtArgs>
  }


  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      Region: Prisma.$RegionPayload<ExtArgs> | null
      District: Prisma.$DistrictPayload<ExtArgs> | null
      Area: Prisma.$AreaPayload<ExtArgs> | null
      Mahalla: Prisma.$MahallaPayload<ExtArgs> | null
      Street: Prisma.$StreetPayload<ExtArgs> | null
      Metro: Prisma.$MetroPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionId: number | null
      districtId: number | null
      areaId: number | null
      mahallaId: number | null
      streetId: number | null
      house_number: number
      apartment_number: number
      location: string
      landmark: boolean
      metroId: number | null
      location_description: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }


  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressCreateArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Region<T extends Address$RegionArgs<ExtArgs> = {}>(args?: Subset<T, Address$RegionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    District<T extends Address$DistrictArgs<ExtArgs> = {}>(args?: Subset<T, Address$DistrictArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Area<T extends Address$AreaArgs<ExtArgs> = {}>(args?: Subset<T, Address$AreaArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Mahalla<T extends Address$MahallaArgs<ExtArgs> = {}>(args?: Subset<T, Address$MahallaArgs<ExtArgs>>): Prisma__MahallaClient<$Result.GetResult<Prisma.$MahallaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Street<T extends Address$StreetArgs<ExtArgs> = {}>(args?: Subset<T, Address$StreetArgs<ExtArgs>>): Prisma__StreetClient<$Result.GetResult<Prisma.$StreetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Metro<T extends Address$MetroArgs<ExtArgs> = {}>(args?: Subset<T, Address$MetroArgs<ExtArgs>>): Prisma__MetroClient<$Result.GetResult<Prisma.$MetroPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly regionId: FieldRef<"Address", 'Int'>
    readonly districtId: FieldRef<"Address", 'Int'>
    readonly areaId: FieldRef<"Address", 'Int'>
    readonly mahallaId: FieldRef<"Address", 'Int'>
    readonly streetId: FieldRef<"Address", 'Int'>
    readonly house_number: FieldRef<"Address", 'Int'>
    readonly apartment_number: FieldRef<"Address", 'Int'>
    readonly location: FieldRef<"Address", 'String'>
    readonly landmark: FieldRef<"Address", 'Boolean'>
    readonly metroId: FieldRef<"Address", 'Int'>
    readonly location_description: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }

  /**
   * Address.Region
   */
  export type Address$RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * Address.District
   */
  export type Address$DistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    where?: DistrictWhereInput
  }

  /**
   * Address.Area
   */
  export type Address$AreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
  }

  /**
   * Address.Mahalla
   */
  export type Address$MahallaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahalla
     */
    select?: MahallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahallaInclude<ExtArgs> | null
    where?: MahallaWhereInput
  }

  /**
   * Address.Street
   */
  export type Address$StreetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Street
     */
    select?: StreetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreetInclude<ExtArgs> | null
    where?: StreetWhereInput
  }

  /**
   * Address.Metro
   */
  export type Address$MetroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metro
     */
    select?: MetroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetroInclude<ExtArgs> | null
    where?: MetroWhereInput
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model BuildingCondition
   */

  export type AggregateBuildingCondition = {
    _count: BuildingConditionCountAggregateOutputType | null
    _avg: BuildingConditionAvgAggregateOutputType | null
    _sum: BuildingConditionSumAggregateOutputType | null
    _min: BuildingConditionMinAggregateOutputType | null
    _max: BuildingConditionMaxAggregateOutputType | null
  }

  export type BuildingConditionAvgAggregateOutputType = {
    id: number | null
  }

  export type BuildingConditionSumAggregateOutputType = {
    id: number | null
  }

  export type BuildingConditionMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BuildingConditionMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BuildingConditionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type BuildingConditionAvgAggregateInputType = {
    id?: true
  }

  export type BuildingConditionSumAggregateInputType = {
    id?: true
  }

  export type BuildingConditionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type BuildingConditionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type BuildingConditionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type BuildingConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildingCondition to aggregate.
     */
    where?: BuildingConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingConditions to fetch.
     */
    orderBy?: BuildingConditionOrderByWithRelationInput | BuildingConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildingConditions
    **/
    _count?: true | BuildingConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildingConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildingConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingConditionMaxAggregateInputType
  }

  export type GetBuildingConditionAggregateType<T extends BuildingConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildingCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildingCondition[P]>
      : GetScalarType<T[P], AggregateBuildingCondition[P]>
  }




  export type BuildingConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingConditionWhereInput
    orderBy?: BuildingConditionOrderByWithAggregationInput | BuildingConditionOrderByWithAggregationInput[]
    by: BuildingConditionScalarFieldEnum[] | BuildingConditionScalarFieldEnum
    having?: BuildingConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingConditionCountAggregateInputType | true
    _avg?: BuildingConditionAvgAggregateInputType
    _sum?: BuildingConditionSumAggregateInputType
    _min?: BuildingConditionMinAggregateInputType
    _max?: BuildingConditionMaxAggregateInputType
  }

  export type BuildingConditionGroupByOutputType = {
    id: number
    name: string
    _count: BuildingConditionCountAggregateOutputType | null
    _avg: BuildingConditionAvgAggregateOutputType | null
    _sum: BuildingConditionSumAggregateOutputType | null
    _min: BuildingConditionMinAggregateOutputType | null
    _max: BuildingConditionMaxAggregateOutputType | null
  }

  type GetBuildingConditionGroupByPayload<T extends BuildingConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingConditionGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingConditionGroupByOutputType[P]>
        }
      >
    >


  export type BuildingConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buildingCharacter?: boolean | BuildingCondition$buildingCharacterArgs<ExtArgs>
    _count?: boolean | BuildingConditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buildingCondition"]>

  export type BuildingConditionSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type BuildingConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | BuildingCondition$buildingCharacterArgs<ExtArgs>
    _count?: boolean | BuildingConditionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BuildingConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildingCondition"
    objects: {
      buildingCharacter: Prisma.$BuildingCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["buildingCondition"]>
    composites: {}
  }


  type BuildingConditionGetPayload<S extends boolean | null | undefined | BuildingConditionDefaultArgs> = $Result.GetResult<Prisma.$BuildingConditionPayload, S>

  type BuildingConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildingConditionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildingConditionCountAggregateInputType | true
    }

  export interface BuildingConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildingCondition'], meta: { name: 'BuildingCondition' } }
    /**
     * Find zero or one BuildingCondition that matches the filter.
     * @param {BuildingConditionFindUniqueArgs} args - Arguments to find a BuildingCondition
     * @example
     * // Get one BuildingCondition
     * const buildingCondition = await prisma.buildingCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildingConditionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingConditionFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BuildingCondition that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildingConditionFindUniqueOrThrowArgs} args - Arguments to find a BuildingCondition
     * @example
     * // Get one BuildingCondition
     * const buildingCondition = await prisma.buildingCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildingConditionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingConditionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BuildingCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingConditionFindFirstArgs} args - Arguments to find a BuildingCondition
     * @example
     * // Get one BuildingCondition
     * const buildingCondition = await prisma.buildingCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildingConditionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingConditionFindFirstArgs<ExtArgs>>
    ): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BuildingCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingConditionFindFirstOrThrowArgs} args - Arguments to find a BuildingCondition
     * @example
     * // Get one BuildingCondition
     * const buildingCondition = await prisma.buildingCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildingConditionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingConditionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BuildingConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingConditionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildingConditions
     * const buildingConditions = await prisma.buildingCondition.findMany()
     * 
     * // Get first 10 BuildingConditions
     * const buildingConditions = await prisma.buildingCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingConditionWithIdOnly = await prisma.buildingCondition.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildingConditionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingConditionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BuildingCondition.
     * @param {BuildingConditionCreateArgs} args - Arguments to create a BuildingCondition.
     * @example
     * // Create one BuildingCondition
     * const BuildingCondition = await prisma.buildingCondition.create({
     *   data: {
     *     // ... data to create a BuildingCondition
     *   }
     * })
     * 
    **/
    create<T extends BuildingConditionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingConditionCreateArgs<ExtArgs>>
    ): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BuildingConditions.
     *     @param {BuildingConditionCreateManyArgs} args - Arguments to create many BuildingConditions.
     *     @example
     *     // Create many BuildingConditions
     *     const buildingCondition = await prisma.buildingCondition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildingConditionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingConditionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuildingCondition.
     * @param {BuildingConditionDeleteArgs} args - Arguments to delete one BuildingCondition.
     * @example
     * // Delete one BuildingCondition
     * const BuildingCondition = await prisma.buildingCondition.delete({
     *   where: {
     *     // ... filter to delete one BuildingCondition
     *   }
     * })
     * 
    **/
    delete<T extends BuildingConditionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingConditionDeleteArgs<ExtArgs>>
    ): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BuildingCondition.
     * @param {BuildingConditionUpdateArgs} args - Arguments to update one BuildingCondition.
     * @example
     * // Update one BuildingCondition
     * const buildingCondition = await prisma.buildingCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildingConditionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingConditionUpdateArgs<ExtArgs>>
    ): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BuildingConditions.
     * @param {BuildingConditionDeleteManyArgs} args - Arguments to filter BuildingConditions to delete.
     * @example
     * // Delete a few BuildingConditions
     * const { count } = await prisma.buildingCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildingConditionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingConditionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildingConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildingConditions
     * const buildingCondition = await prisma.buildingCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildingConditionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingConditionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildingCondition.
     * @param {BuildingConditionUpsertArgs} args - Arguments to update or create a BuildingCondition.
     * @example
     * // Update or create a BuildingCondition
     * const buildingCondition = await prisma.buildingCondition.upsert({
     *   create: {
     *     // ... data to create a BuildingCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildingCondition we want to update
     *   }
     * })
    **/
    upsert<T extends BuildingConditionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingConditionUpsertArgs<ExtArgs>>
    ): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BuildingConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingConditionCountArgs} args - Arguments to filter BuildingConditions to count.
     * @example
     * // Count the number of BuildingConditions
     * const count = await prisma.buildingCondition.count({
     *   where: {
     *     // ... the filter for the BuildingConditions we want to count
     *   }
     * })
    **/
    count<T extends BuildingConditionCountArgs>(
      args?: Subset<T, BuildingConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildingCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingConditionAggregateArgs>(args: Subset<T, BuildingConditionAggregateArgs>): Prisma.PrismaPromise<GetBuildingConditionAggregateType<T>>

    /**
     * Group by BuildingCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingConditionGroupByArgs['orderBy'] }
        : { orderBy?: BuildingConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildingCondition model
   */
  readonly fields: BuildingConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildingCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingCharacter<T extends BuildingCondition$buildingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, BuildingCondition$buildingCharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BuildingCondition model
   */ 
  interface BuildingConditionFieldRefs {
    readonly id: FieldRef<"BuildingCondition", 'Int'>
    readonly name: FieldRef<"BuildingCondition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BuildingCondition findUnique
   */
  export type BuildingConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCondition to fetch.
     */
    where: BuildingConditionWhereUniqueInput
  }

  /**
   * BuildingCondition findUniqueOrThrow
   */
  export type BuildingConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCondition to fetch.
     */
    where: BuildingConditionWhereUniqueInput
  }

  /**
   * BuildingCondition findFirst
   */
  export type BuildingConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCondition to fetch.
     */
    where?: BuildingConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingConditions to fetch.
     */
    orderBy?: BuildingConditionOrderByWithRelationInput | BuildingConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildingConditions.
     */
    cursor?: BuildingConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildingConditions.
     */
    distinct?: BuildingConditionScalarFieldEnum | BuildingConditionScalarFieldEnum[]
  }

  /**
   * BuildingCondition findFirstOrThrow
   */
  export type BuildingConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCondition to fetch.
     */
    where?: BuildingConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingConditions to fetch.
     */
    orderBy?: BuildingConditionOrderByWithRelationInput | BuildingConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildingConditions.
     */
    cursor?: BuildingConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildingConditions.
     */
    distinct?: BuildingConditionScalarFieldEnum | BuildingConditionScalarFieldEnum[]
  }

  /**
   * BuildingCondition findMany
   */
  export type BuildingConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * Filter, which BuildingConditions to fetch.
     */
    where?: BuildingConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingConditions to fetch.
     */
    orderBy?: BuildingConditionOrderByWithRelationInput | BuildingConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildingConditions.
     */
    cursor?: BuildingConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingConditions.
     */
    skip?: number
    distinct?: BuildingConditionScalarFieldEnum | BuildingConditionScalarFieldEnum[]
  }

  /**
   * BuildingCondition create
   */
  export type BuildingConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildingCondition.
     */
    data: XOR<BuildingConditionCreateInput, BuildingConditionUncheckedCreateInput>
  }

  /**
   * BuildingCondition createMany
   */
  export type BuildingConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildingConditions.
     */
    data: BuildingConditionCreateManyInput | BuildingConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuildingCondition update
   */
  export type BuildingConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildingCondition.
     */
    data: XOR<BuildingConditionUpdateInput, BuildingConditionUncheckedUpdateInput>
    /**
     * Choose, which BuildingCondition to update.
     */
    where: BuildingConditionWhereUniqueInput
  }

  /**
   * BuildingCondition updateMany
   */
  export type BuildingConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildingConditions.
     */
    data: XOR<BuildingConditionUpdateManyMutationInput, BuildingConditionUncheckedUpdateManyInput>
    /**
     * Filter which BuildingConditions to update
     */
    where?: BuildingConditionWhereInput
  }

  /**
   * BuildingCondition upsert
   */
  export type BuildingConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildingCondition to update in case it exists.
     */
    where: BuildingConditionWhereUniqueInput
    /**
     * In case the BuildingCondition found by the `where` argument doesn't exist, create a new BuildingCondition with this data.
     */
    create: XOR<BuildingConditionCreateInput, BuildingConditionUncheckedCreateInput>
    /**
     * In case the BuildingCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingConditionUpdateInput, BuildingConditionUncheckedUpdateInput>
  }

  /**
   * BuildingCondition delete
   */
  export type BuildingConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    /**
     * Filter which BuildingCondition to delete.
     */
    where: BuildingConditionWhereUniqueInput
  }

  /**
   * BuildingCondition deleteMany
   */
  export type BuildingConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildingConditions to delete
     */
    where?: BuildingConditionWhereInput
  }

  /**
   * BuildingCondition.buildingCharacter
   */
  export type BuildingCondition$buildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    where?: BuildingCharacterWhereInput
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    cursor?: BuildingCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * BuildingCondition without action
   */
  export type BuildingConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
  }


  /**
   * Model BuildingSeria
   */

  export type AggregateBuildingSeria = {
    _count: BuildingSeriaCountAggregateOutputType | null
    _avg: BuildingSeriaAvgAggregateOutputType | null
    _sum: BuildingSeriaSumAggregateOutputType | null
    _min: BuildingSeriaMinAggregateOutputType | null
    _max: BuildingSeriaMaxAggregateOutputType | null
  }

  export type BuildingSeriaAvgAggregateOutputType = {
    id: number | null
  }

  export type BuildingSeriaSumAggregateOutputType = {
    id: number | null
  }

  export type BuildingSeriaMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BuildingSeriaMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BuildingSeriaCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type BuildingSeriaAvgAggregateInputType = {
    id?: true
  }

  export type BuildingSeriaSumAggregateInputType = {
    id?: true
  }

  export type BuildingSeriaMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type BuildingSeriaMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type BuildingSeriaCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type BuildingSeriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildingSeria to aggregate.
     */
    where?: BuildingSeriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingSerias to fetch.
     */
    orderBy?: BuildingSeriaOrderByWithRelationInput | BuildingSeriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingSeriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingSerias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingSerias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildingSerias
    **/
    _count?: true | BuildingSeriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildingSeriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildingSeriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingSeriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingSeriaMaxAggregateInputType
  }

  export type GetBuildingSeriaAggregateType<T extends BuildingSeriaAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildingSeria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildingSeria[P]>
      : GetScalarType<T[P], AggregateBuildingSeria[P]>
  }




  export type BuildingSeriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingSeriaWhereInput
    orderBy?: BuildingSeriaOrderByWithAggregationInput | BuildingSeriaOrderByWithAggregationInput[]
    by: BuildingSeriaScalarFieldEnum[] | BuildingSeriaScalarFieldEnum
    having?: BuildingSeriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingSeriaCountAggregateInputType | true
    _avg?: BuildingSeriaAvgAggregateInputType
    _sum?: BuildingSeriaSumAggregateInputType
    _min?: BuildingSeriaMinAggregateInputType
    _max?: BuildingSeriaMaxAggregateInputType
  }

  export type BuildingSeriaGroupByOutputType = {
    id: number
    name: string
    _count: BuildingSeriaCountAggregateOutputType | null
    _avg: BuildingSeriaAvgAggregateOutputType | null
    _sum: BuildingSeriaSumAggregateOutputType | null
    _min: BuildingSeriaMinAggregateOutputType | null
    _max: BuildingSeriaMaxAggregateOutputType | null
  }

  type GetBuildingSeriaGroupByPayload<T extends BuildingSeriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingSeriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingSeriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingSeriaGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingSeriaGroupByOutputType[P]>
        }
      >
    >


  export type BuildingSeriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buildingCharacter?: boolean | BuildingSeria$buildingCharacterArgs<ExtArgs>
    _count?: boolean | BuildingSeriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buildingSeria"]>

  export type BuildingSeriaSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type BuildingSeriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | BuildingSeria$buildingCharacterArgs<ExtArgs>
    _count?: boolean | BuildingSeriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BuildingSeriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildingSeria"
    objects: {
      buildingCharacter: Prisma.$BuildingCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["buildingSeria"]>
    composites: {}
  }


  type BuildingSeriaGetPayload<S extends boolean | null | undefined | BuildingSeriaDefaultArgs> = $Result.GetResult<Prisma.$BuildingSeriaPayload, S>

  type BuildingSeriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildingSeriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildingSeriaCountAggregateInputType | true
    }

  export interface BuildingSeriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildingSeria'], meta: { name: 'BuildingSeria' } }
    /**
     * Find zero or one BuildingSeria that matches the filter.
     * @param {BuildingSeriaFindUniqueArgs} args - Arguments to find a BuildingSeria
     * @example
     * // Get one BuildingSeria
     * const buildingSeria = await prisma.buildingSeria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildingSeriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingSeriaFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BuildingSeria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildingSeriaFindUniqueOrThrowArgs} args - Arguments to find a BuildingSeria
     * @example
     * // Get one BuildingSeria
     * const buildingSeria = await prisma.buildingSeria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildingSeriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingSeriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BuildingSeria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingSeriaFindFirstArgs} args - Arguments to find a BuildingSeria
     * @example
     * // Get one BuildingSeria
     * const buildingSeria = await prisma.buildingSeria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildingSeriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingSeriaFindFirstArgs<ExtArgs>>
    ): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BuildingSeria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingSeriaFindFirstOrThrowArgs} args - Arguments to find a BuildingSeria
     * @example
     * // Get one BuildingSeria
     * const buildingSeria = await prisma.buildingSeria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildingSeriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingSeriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BuildingSerias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingSeriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildingSerias
     * const buildingSerias = await prisma.buildingSeria.findMany()
     * 
     * // Get first 10 BuildingSerias
     * const buildingSerias = await prisma.buildingSeria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingSeriaWithIdOnly = await prisma.buildingSeria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildingSeriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingSeriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BuildingSeria.
     * @param {BuildingSeriaCreateArgs} args - Arguments to create a BuildingSeria.
     * @example
     * // Create one BuildingSeria
     * const BuildingSeria = await prisma.buildingSeria.create({
     *   data: {
     *     // ... data to create a BuildingSeria
     *   }
     * })
     * 
    **/
    create<T extends BuildingSeriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingSeriaCreateArgs<ExtArgs>>
    ): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BuildingSerias.
     *     @param {BuildingSeriaCreateManyArgs} args - Arguments to create many BuildingSerias.
     *     @example
     *     // Create many BuildingSerias
     *     const buildingSeria = await prisma.buildingSeria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildingSeriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingSeriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuildingSeria.
     * @param {BuildingSeriaDeleteArgs} args - Arguments to delete one BuildingSeria.
     * @example
     * // Delete one BuildingSeria
     * const BuildingSeria = await prisma.buildingSeria.delete({
     *   where: {
     *     // ... filter to delete one BuildingSeria
     *   }
     * })
     * 
    **/
    delete<T extends BuildingSeriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingSeriaDeleteArgs<ExtArgs>>
    ): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BuildingSeria.
     * @param {BuildingSeriaUpdateArgs} args - Arguments to update one BuildingSeria.
     * @example
     * // Update one BuildingSeria
     * const buildingSeria = await prisma.buildingSeria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildingSeriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingSeriaUpdateArgs<ExtArgs>>
    ): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BuildingSerias.
     * @param {BuildingSeriaDeleteManyArgs} args - Arguments to filter BuildingSerias to delete.
     * @example
     * // Delete a few BuildingSerias
     * const { count } = await prisma.buildingSeria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildingSeriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingSeriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildingSerias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingSeriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildingSerias
     * const buildingSeria = await prisma.buildingSeria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildingSeriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingSeriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildingSeria.
     * @param {BuildingSeriaUpsertArgs} args - Arguments to update or create a BuildingSeria.
     * @example
     * // Update or create a BuildingSeria
     * const buildingSeria = await prisma.buildingSeria.upsert({
     *   create: {
     *     // ... data to create a BuildingSeria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildingSeria we want to update
     *   }
     * })
    **/
    upsert<T extends BuildingSeriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingSeriaUpsertArgs<ExtArgs>>
    ): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BuildingSerias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingSeriaCountArgs} args - Arguments to filter BuildingSerias to count.
     * @example
     * // Count the number of BuildingSerias
     * const count = await prisma.buildingSeria.count({
     *   where: {
     *     // ... the filter for the BuildingSerias we want to count
     *   }
     * })
    **/
    count<T extends BuildingSeriaCountArgs>(
      args?: Subset<T, BuildingSeriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingSeriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildingSeria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingSeriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingSeriaAggregateArgs>(args: Subset<T, BuildingSeriaAggregateArgs>): Prisma.PrismaPromise<GetBuildingSeriaAggregateType<T>>

    /**
     * Group by BuildingSeria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingSeriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingSeriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingSeriaGroupByArgs['orderBy'] }
        : { orderBy?: BuildingSeriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingSeriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingSeriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildingSeria model
   */
  readonly fields: BuildingSeriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildingSeria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingSeriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingCharacter<T extends BuildingSeria$buildingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, BuildingSeria$buildingCharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BuildingSeria model
   */ 
  interface BuildingSeriaFieldRefs {
    readonly id: FieldRef<"BuildingSeria", 'Int'>
    readonly name: FieldRef<"BuildingSeria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BuildingSeria findUnique
   */
  export type BuildingSeriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * Filter, which BuildingSeria to fetch.
     */
    where: BuildingSeriaWhereUniqueInput
  }

  /**
   * BuildingSeria findUniqueOrThrow
   */
  export type BuildingSeriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * Filter, which BuildingSeria to fetch.
     */
    where: BuildingSeriaWhereUniqueInput
  }

  /**
   * BuildingSeria findFirst
   */
  export type BuildingSeriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * Filter, which BuildingSeria to fetch.
     */
    where?: BuildingSeriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingSerias to fetch.
     */
    orderBy?: BuildingSeriaOrderByWithRelationInput | BuildingSeriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildingSerias.
     */
    cursor?: BuildingSeriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingSerias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingSerias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildingSerias.
     */
    distinct?: BuildingSeriaScalarFieldEnum | BuildingSeriaScalarFieldEnum[]
  }

  /**
   * BuildingSeria findFirstOrThrow
   */
  export type BuildingSeriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * Filter, which BuildingSeria to fetch.
     */
    where?: BuildingSeriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingSerias to fetch.
     */
    orderBy?: BuildingSeriaOrderByWithRelationInput | BuildingSeriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildingSerias.
     */
    cursor?: BuildingSeriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingSerias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingSerias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildingSerias.
     */
    distinct?: BuildingSeriaScalarFieldEnum | BuildingSeriaScalarFieldEnum[]
  }

  /**
   * BuildingSeria findMany
   */
  export type BuildingSeriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * Filter, which BuildingSerias to fetch.
     */
    where?: BuildingSeriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingSerias to fetch.
     */
    orderBy?: BuildingSeriaOrderByWithRelationInput | BuildingSeriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildingSerias.
     */
    cursor?: BuildingSeriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingSerias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingSerias.
     */
    skip?: number
    distinct?: BuildingSeriaScalarFieldEnum | BuildingSeriaScalarFieldEnum[]
  }

  /**
   * BuildingSeria create
   */
  export type BuildingSeriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildingSeria.
     */
    data: XOR<BuildingSeriaCreateInput, BuildingSeriaUncheckedCreateInput>
  }

  /**
   * BuildingSeria createMany
   */
  export type BuildingSeriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildingSerias.
     */
    data: BuildingSeriaCreateManyInput | BuildingSeriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuildingSeria update
   */
  export type BuildingSeriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildingSeria.
     */
    data: XOR<BuildingSeriaUpdateInput, BuildingSeriaUncheckedUpdateInput>
    /**
     * Choose, which BuildingSeria to update.
     */
    where: BuildingSeriaWhereUniqueInput
  }

  /**
   * BuildingSeria updateMany
   */
  export type BuildingSeriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildingSerias.
     */
    data: XOR<BuildingSeriaUpdateManyMutationInput, BuildingSeriaUncheckedUpdateManyInput>
    /**
     * Filter which BuildingSerias to update
     */
    where?: BuildingSeriaWhereInput
  }

  /**
   * BuildingSeria upsert
   */
  export type BuildingSeriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildingSeria to update in case it exists.
     */
    where: BuildingSeriaWhereUniqueInput
    /**
     * In case the BuildingSeria found by the `where` argument doesn't exist, create a new BuildingSeria with this data.
     */
    create: XOR<BuildingSeriaCreateInput, BuildingSeriaUncheckedCreateInput>
    /**
     * In case the BuildingSeria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingSeriaUpdateInput, BuildingSeriaUncheckedUpdateInput>
  }

  /**
   * BuildingSeria delete
   */
  export type BuildingSeriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    /**
     * Filter which BuildingSeria to delete.
     */
    where: BuildingSeriaWhereUniqueInput
  }

  /**
   * BuildingSeria deleteMany
   */
  export type BuildingSeriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildingSerias to delete
     */
    where?: BuildingSeriaWhereInput
  }

  /**
   * BuildingSeria.buildingCharacter
   */
  export type BuildingSeria$buildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    where?: BuildingCharacterWhereInput
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    cursor?: BuildingCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * BuildingSeria without action
   */
  export type BuildingSeriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
  }


  /**
   * Model WallMaterial
   */

  export type AggregateWallMaterial = {
    _count: WallMaterialCountAggregateOutputType | null
    _avg: WallMaterialAvgAggregateOutputType | null
    _sum: WallMaterialSumAggregateOutputType | null
    _min: WallMaterialMinAggregateOutputType | null
    _max: WallMaterialMaxAggregateOutputType | null
  }

  export type WallMaterialAvgAggregateOutputType = {
    id: number | null
  }

  export type WallMaterialSumAggregateOutputType = {
    id: number | null
  }

  export type WallMaterialMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type WallMaterialMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type WallMaterialCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type WallMaterialAvgAggregateInputType = {
    id?: true
  }

  export type WallMaterialSumAggregateInputType = {
    id?: true
  }

  export type WallMaterialMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type WallMaterialMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type WallMaterialCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type WallMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WallMaterial to aggregate.
     */
    where?: WallMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WallMaterials to fetch.
     */
    orderBy?: WallMaterialOrderByWithRelationInput | WallMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WallMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WallMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WallMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WallMaterials
    **/
    _count?: true | WallMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WallMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WallMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WallMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WallMaterialMaxAggregateInputType
  }

  export type GetWallMaterialAggregateType<T extends WallMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateWallMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallMaterial[P]>
      : GetScalarType<T[P], AggregateWallMaterial[P]>
  }




  export type WallMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WallMaterialWhereInput
    orderBy?: WallMaterialOrderByWithAggregationInput | WallMaterialOrderByWithAggregationInput[]
    by: WallMaterialScalarFieldEnum[] | WallMaterialScalarFieldEnum
    having?: WallMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WallMaterialCountAggregateInputType | true
    _avg?: WallMaterialAvgAggregateInputType
    _sum?: WallMaterialSumAggregateInputType
    _min?: WallMaterialMinAggregateInputType
    _max?: WallMaterialMaxAggregateInputType
  }

  export type WallMaterialGroupByOutputType = {
    id: number
    name: string
    _count: WallMaterialCountAggregateOutputType | null
    _avg: WallMaterialAvgAggregateOutputType | null
    _sum: WallMaterialSumAggregateOutputType | null
    _min: WallMaterialMinAggregateOutputType | null
    _max: WallMaterialMaxAggregateOutputType | null
  }

  type GetWallMaterialGroupByPayload<T extends WallMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WallMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WallMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WallMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], WallMaterialGroupByOutputType[P]>
        }
      >
    >


  export type WallMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buildingCharacter?: boolean | WallMaterial$buildingCharacterArgs<ExtArgs>
    _count?: boolean | WallMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallMaterial"]>

  export type WallMaterialSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type WallMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | WallMaterial$buildingCharacterArgs<ExtArgs>
    _count?: boolean | WallMaterialCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WallMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WallMaterial"
    objects: {
      buildingCharacter: Prisma.$BuildingCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["wallMaterial"]>
    composites: {}
  }


  type WallMaterialGetPayload<S extends boolean | null | undefined | WallMaterialDefaultArgs> = $Result.GetResult<Prisma.$WallMaterialPayload, S>

  type WallMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WallMaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WallMaterialCountAggregateInputType | true
    }

  export interface WallMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WallMaterial'], meta: { name: 'WallMaterial' } }
    /**
     * Find zero or one WallMaterial that matches the filter.
     * @param {WallMaterialFindUniqueArgs} args - Arguments to find a WallMaterial
     * @example
     * // Get one WallMaterial
     * const wallMaterial = await prisma.wallMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WallMaterialFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WallMaterialFindUniqueArgs<ExtArgs>>
    ): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WallMaterial that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WallMaterialFindUniqueOrThrowArgs} args - Arguments to find a WallMaterial
     * @example
     * // Get one WallMaterial
     * const wallMaterial = await prisma.wallMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WallMaterialFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WallMaterialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WallMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WallMaterialFindFirstArgs} args - Arguments to find a WallMaterial
     * @example
     * // Get one WallMaterial
     * const wallMaterial = await prisma.wallMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WallMaterialFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WallMaterialFindFirstArgs<ExtArgs>>
    ): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WallMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WallMaterialFindFirstOrThrowArgs} args - Arguments to find a WallMaterial
     * @example
     * // Get one WallMaterial
     * const wallMaterial = await prisma.wallMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WallMaterialFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WallMaterialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WallMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WallMaterialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WallMaterials
     * const wallMaterials = await prisma.wallMaterial.findMany()
     * 
     * // Get first 10 WallMaterials
     * const wallMaterials = await prisma.wallMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallMaterialWithIdOnly = await prisma.wallMaterial.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WallMaterialFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WallMaterialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WallMaterial.
     * @param {WallMaterialCreateArgs} args - Arguments to create a WallMaterial.
     * @example
     * // Create one WallMaterial
     * const WallMaterial = await prisma.wallMaterial.create({
     *   data: {
     *     // ... data to create a WallMaterial
     *   }
     * })
     * 
    **/
    create<T extends WallMaterialCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WallMaterialCreateArgs<ExtArgs>>
    ): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WallMaterials.
     *     @param {WallMaterialCreateManyArgs} args - Arguments to create many WallMaterials.
     *     @example
     *     // Create many WallMaterials
     *     const wallMaterial = await prisma.wallMaterial.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WallMaterialCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WallMaterialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WallMaterial.
     * @param {WallMaterialDeleteArgs} args - Arguments to delete one WallMaterial.
     * @example
     * // Delete one WallMaterial
     * const WallMaterial = await prisma.wallMaterial.delete({
     *   where: {
     *     // ... filter to delete one WallMaterial
     *   }
     * })
     * 
    **/
    delete<T extends WallMaterialDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WallMaterialDeleteArgs<ExtArgs>>
    ): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WallMaterial.
     * @param {WallMaterialUpdateArgs} args - Arguments to update one WallMaterial.
     * @example
     * // Update one WallMaterial
     * const wallMaterial = await prisma.wallMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WallMaterialUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WallMaterialUpdateArgs<ExtArgs>>
    ): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WallMaterials.
     * @param {WallMaterialDeleteManyArgs} args - Arguments to filter WallMaterials to delete.
     * @example
     * // Delete a few WallMaterials
     * const { count } = await prisma.wallMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WallMaterialDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WallMaterialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WallMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WallMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WallMaterials
     * const wallMaterial = await prisma.wallMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WallMaterialUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WallMaterialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WallMaterial.
     * @param {WallMaterialUpsertArgs} args - Arguments to update or create a WallMaterial.
     * @example
     * // Update or create a WallMaterial
     * const wallMaterial = await prisma.wallMaterial.upsert({
     *   create: {
     *     // ... data to create a WallMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WallMaterial we want to update
     *   }
     * })
    **/
    upsert<T extends WallMaterialUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WallMaterialUpsertArgs<ExtArgs>>
    ): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WallMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WallMaterialCountArgs} args - Arguments to filter WallMaterials to count.
     * @example
     * // Count the number of WallMaterials
     * const count = await prisma.wallMaterial.count({
     *   where: {
     *     // ... the filter for the WallMaterials we want to count
     *   }
     * })
    **/
    count<T extends WallMaterialCountArgs>(
      args?: Subset<T, WallMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WallMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WallMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WallMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WallMaterialAggregateArgs>(args: Subset<T, WallMaterialAggregateArgs>): Prisma.PrismaPromise<GetWallMaterialAggregateType<T>>

    /**
     * Group by WallMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WallMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WallMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WallMaterialGroupByArgs['orderBy'] }
        : { orderBy?: WallMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WallMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WallMaterial model
   */
  readonly fields: WallMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WallMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WallMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingCharacter<T extends WallMaterial$buildingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, WallMaterial$buildingCharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WallMaterial model
   */ 
  interface WallMaterialFieldRefs {
    readonly id: FieldRef<"WallMaterial", 'Int'>
    readonly name: FieldRef<"WallMaterial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WallMaterial findUnique
   */
  export type WallMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WallMaterial to fetch.
     */
    where: WallMaterialWhereUniqueInput
  }

  /**
   * WallMaterial findUniqueOrThrow
   */
  export type WallMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WallMaterial to fetch.
     */
    where: WallMaterialWhereUniqueInput
  }

  /**
   * WallMaterial findFirst
   */
  export type WallMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WallMaterial to fetch.
     */
    where?: WallMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WallMaterials to fetch.
     */
    orderBy?: WallMaterialOrderByWithRelationInput | WallMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WallMaterials.
     */
    cursor?: WallMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WallMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WallMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WallMaterials.
     */
    distinct?: WallMaterialScalarFieldEnum | WallMaterialScalarFieldEnum[]
  }

  /**
   * WallMaterial findFirstOrThrow
   */
  export type WallMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WallMaterial to fetch.
     */
    where?: WallMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WallMaterials to fetch.
     */
    orderBy?: WallMaterialOrderByWithRelationInput | WallMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WallMaterials.
     */
    cursor?: WallMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WallMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WallMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WallMaterials.
     */
    distinct?: WallMaterialScalarFieldEnum | WallMaterialScalarFieldEnum[]
  }

  /**
   * WallMaterial findMany
   */
  export type WallMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WallMaterials to fetch.
     */
    where?: WallMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WallMaterials to fetch.
     */
    orderBy?: WallMaterialOrderByWithRelationInput | WallMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WallMaterials.
     */
    cursor?: WallMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WallMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WallMaterials.
     */
    skip?: number
    distinct?: WallMaterialScalarFieldEnum | WallMaterialScalarFieldEnum[]
  }

  /**
   * WallMaterial create
   */
  export type WallMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a WallMaterial.
     */
    data: XOR<WallMaterialCreateInput, WallMaterialUncheckedCreateInput>
  }

  /**
   * WallMaterial createMany
   */
  export type WallMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WallMaterials.
     */
    data: WallMaterialCreateManyInput | WallMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WallMaterial update
   */
  export type WallMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a WallMaterial.
     */
    data: XOR<WallMaterialUpdateInput, WallMaterialUncheckedUpdateInput>
    /**
     * Choose, which WallMaterial to update.
     */
    where: WallMaterialWhereUniqueInput
  }

  /**
   * WallMaterial updateMany
   */
  export type WallMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WallMaterials.
     */
    data: XOR<WallMaterialUpdateManyMutationInput, WallMaterialUncheckedUpdateManyInput>
    /**
     * Filter which WallMaterials to update
     */
    where?: WallMaterialWhereInput
  }

  /**
   * WallMaterial upsert
   */
  export type WallMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the WallMaterial to update in case it exists.
     */
    where: WallMaterialWhereUniqueInput
    /**
     * In case the WallMaterial found by the `where` argument doesn't exist, create a new WallMaterial with this data.
     */
    create: XOR<WallMaterialCreateInput, WallMaterialUncheckedCreateInput>
    /**
     * In case the WallMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WallMaterialUpdateInput, WallMaterialUncheckedUpdateInput>
  }

  /**
   * WallMaterial delete
   */
  export type WallMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    /**
     * Filter which WallMaterial to delete.
     */
    where: WallMaterialWhereUniqueInput
  }

  /**
   * WallMaterial deleteMany
   */
  export type WallMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WallMaterials to delete
     */
    where?: WallMaterialWhereInput
  }

  /**
   * WallMaterial.buildingCharacter
   */
  export type WallMaterial$buildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    where?: BuildingCharacterWhereInput
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    cursor?: BuildingCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * WallMaterial without action
   */
  export type WallMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
  }


  /**
   * Model Overlaps
   */

  export type AggregateOverlaps = {
    _count: OverlapsCountAggregateOutputType | null
    _avg: OverlapsAvgAggregateOutputType | null
    _sum: OverlapsSumAggregateOutputType | null
    _min: OverlapsMinAggregateOutputType | null
    _max: OverlapsMaxAggregateOutputType | null
  }

  export type OverlapsAvgAggregateOutputType = {
    id: number | null
  }

  export type OverlapsSumAggregateOutputType = {
    id: number | null
  }

  export type OverlapsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type OverlapsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type OverlapsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type OverlapsAvgAggregateInputType = {
    id?: true
  }

  export type OverlapsSumAggregateInputType = {
    id?: true
  }

  export type OverlapsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type OverlapsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type OverlapsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type OverlapsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Overlaps to aggregate.
     */
    where?: OverlapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overlaps to fetch.
     */
    orderBy?: OverlapsOrderByWithRelationInput | OverlapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OverlapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overlaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overlaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Overlaps
    **/
    _count?: true | OverlapsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OverlapsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OverlapsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OverlapsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OverlapsMaxAggregateInputType
  }

  export type GetOverlapsAggregateType<T extends OverlapsAggregateArgs> = {
        [P in keyof T & keyof AggregateOverlaps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOverlaps[P]>
      : GetScalarType<T[P], AggregateOverlaps[P]>
  }




  export type OverlapsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OverlapsWhereInput
    orderBy?: OverlapsOrderByWithAggregationInput | OverlapsOrderByWithAggregationInput[]
    by: OverlapsScalarFieldEnum[] | OverlapsScalarFieldEnum
    having?: OverlapsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OverlapsCountAggregateInputType | true
    _avg?: OverlapsAvgAggregateInputType
    _sum?: OverlapsSumAggregateInputType
    _min?: OverlapsMinAggregateInputType
    _max?: OverlapsMaxAggregateInputType
  }

  export type OverlapsGroupByOutputType = {
    id: number
    name: string
    _count: OverlapsCountAggregateOutputType | null
    _avg: OverlapsAvgAggregateOutputType | null
    _sum: OverlapsSumAggregateOutputType | null
    _min: OverlapsMinAggregateOutputType | null
    _max: OverlapsMaxAggregateOutputType | null
  }

  type GetOverlapsGroupByPayload<T extends OverlapsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OverlapsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OverlapsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OverlapsGroupByOutputType[P]>
            : GetScalarType<T[P], OverlapsGroupByOutputType[P]>
        }
      >
    >


  export type OverlapsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buildingCharacter?: boolean | Overlaps$buildingCharacterArgs<ExtArgs>
    _count?: boolean | OverlapsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overlaps"]>

  export type OverlapsSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type OverlapsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | Overlaps$buildingCharacterArgs<ExtArgs>
    _count?: boolean | OverlapsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OverlapsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Overlaps"
    objects: {
      buildingCharacter: Prisma.$BuildingCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["overlaps"]>
    composites: {}
  }


  type OverlapsGetPayload<S extends boolean | null | undefined | OverlapsDefaultArgs> = $Result.GetResult<Prisma.$OverlapsPayload, S>

  type OverlapsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OverlapsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OverlapsCountAggregateInputType | true
    }

  export interface OverlapsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Overlaps'], meta: { name: 'Overlaps' } }
    /**
     * Find zero or one Overlaps that matches the filter.
     * @param {OverlapsFindUniqueArgs} args - Arguments to find a Overlaps
     * @example
     * // Get one Overlaps
     * const overlaps = await prisma.overlaps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OverlapsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OverlapsFindUniqueArgs<ExtArgs>>
    ): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Overlaps that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OverlapsFindUniqueOrThrowArgs} args - Arguments to find a Overlaps
     * @example
     * // Get one Overlaps
     * const overlaps = await prisma.overlaps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OverlapsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OverlapsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Overlaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverlapsFindFirstArgs} args - Arguments to find a Overlaps
     * @example
     * // Get one Overlaps
     * const overlaps = await prisma.overlaps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OverlapsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OverlapsFindFirstArgs<ExtArgs>>
    ): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Overlaps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverlapsFindFirstOrThrowArgs} args - Arguments to find a Overlaps
     * @example
     * // Get one Overlaps
     * const overlaps = await prisma.overlaps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OverlapsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OverlapsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Overlaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverlapsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Overlaps
     * const overlaps = await prisma.overlaps.findMany()
     * 
     * // Get first 10 Overlaps
     * const overlaps = await prisma.overlaps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overlapsWithIdOnly = await prisma.overlaps.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OverlapsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OverlapsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Overlaps.
     * @param {OverlapsCreateArgs} args - Arguments to create a Overlaps.
     * @example
     * // Create one Overlaps
     * const Overlaps = await prisma.overlaps.create({
     *   data: {
     *     // ... data to create a Overlaps
     *   }
     * })
     * 
    **/
    create<T extends OverlapsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OverlapsCreateArgs<ExtArgs>>
    ): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Overlaps.
     *     @param {OverlapsCreateManyArgs} args - Arguments to create many Overlaps.
     *     @example
     *     // Create many Overlaps
     *     const overlaps = await prisma.overlaps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OverlapsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OverlapsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Overlaps.
     * @param {OverlapsDeleteArgs} args - Arguments to delete one Overlaps.
     * @example
     * // Delete one Overlaps
     * const Overlaps = await prisma.overlaps.delete({
     *   where: {
     *     // ... filter to delete one Overlaps
     *   }
     * })
     * 
    **/
    delete<T extends OverlapsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OverlapsDeleteArgs<ExtArgs>>
    ): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Overlaps.
     * @param {OverlapsUpdateArgs} args - Arguments to update one Overlaps.
     * @example
     * // Update one Overlaps
     * const overlaps = await prisma.overlaps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OverlapsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OverlapsUpdateArgs<ExtArgs>>
    ): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Overlaps.
     * @param {OverlapsDeleteManyArgs} args - Arguments to filter Overlaps to delete.
     * @example
     * // Delete a few Overlaps
     * const { count } = await prisma.overlaps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OverlapsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OverlapsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overlaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverlapsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Overlaps
     * const overlaps = await prisma.overlaps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OverlapsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OverlapsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Overlaps.
     * @param {OverlapsUpsertArgs} args - Arguments to update or create a Overlaps.
     * @example
     * // Update or create a Overlaps
     * const overlaps = await prisma.overlaps.upsert({
     *   create: {
     *     // ... data to create a Overlaps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Overlaps we want to update
     *   }
     * })
    **/
    upsert<T extends OverlapsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OverlapsUpsertArgs<ExtArgs>>
    ): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Overlaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverlapsCountArgs} args - Arguments to filter Overlaps to count.
     * @example
     * // Count the number of Overlaps
     * const count = await prisma.overlaps.count({
     *   where: {
     *     // ... the filter for the Overlaps we want to count
     *   }
     * })
    **/
    count<T extends OverlapsCountArgs>(
      args?: Subset<T, OverlapsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OverlapsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Overlaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverlapsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OverlapsAggregateArgs>(args: Subset<T, OverlapsAggregateArgs>): Prisma.PrismaPromise<GetOverlapsAggregateType<T>>

    /**
     * Group by Overlaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverlapsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OverlapsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OverlapsGroupByArgs['orderBy'] }
        : { orderBy?: OverlapsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OverlapsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOverlapsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Overlaps model
   */
  readonly fields: OverlapsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Overlaps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OverlapsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingCharacter<T extends Overlaps$buildingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, Overlaps$buildingCharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Overlaps model
   */ 
  interface OverlapsFieldRefs {
    readonly id: FieldRef<"Overlaps", 'Int'>
    readonly name: FieldRef<"Overlaps", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Overlaps findUnique
   */
  export type OverlapsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * Filter, which Overlaps to fetch.
     */
    where: OverlapsWhereUniqueInput
  }

  /**
   * Overlaps findUniqueOrThrow
   */
  export type OverlapsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * Filter, which Overlaps to fetch.
     */
    where: OverlapsWhereUniqueInput
  }

  /**
   * Overlaps findFirst
   */
  export type OverlapsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * Filter, which Overlaps to fetch.
     */
    where?: OverlapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overlaps to fetch.
     */
    orderBy?: OverlapsOrderByWithRelationInput | OverlapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Overlaps.
     */
    cursor?: OverlapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overlaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overlaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Overlaps.
     */
    distinct?: OverlapsScalarFieldEnum | OverlapsScalarFieldEnum[]
  }

  /**
   * Overlaps findFirstOrThrow
   */
  export type OverlapsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * Filter, which Overlaps to fetch.
     */
    where?: OverlapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overlaps to fetch.
     */
    orderBy?: OverlapsOrderByWithRelationInput | OverlapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Overlaps.
     */
    cursor?: OverlapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overlaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overlaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Overlaps.
     */
    distinct?: OverlapsScalarFieldEnum | OverlapsScalarFieldEnum[]
  }

  /**
   * Overlaps findMany
   */
  export type OverlapsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * Filter, which Overlaps to fetch.
     */
    where?: OverlapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overlaps to fetch.
     */
    orderBy?: OverlapsOrderByWithRelationInput | OverlapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Overlaps.
     */
    cursor?: OverlapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overlaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overlaps.
     */
    skip?: number
    distinct?: OverlapsScalarFieldEnum | OverlapsScalarFieldEnum[]
  }

  /**
   * Overlaps create
   */
  export type OverlapsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * The data needed to create a Overlaps.
     */
    data: XOR<OverlapsCreateInput, OverlapsUncheckedCreateInput>
  }

  /**
   * Overlaps createMany
   */
  export type OverlapsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Overlaps.
     */
    data: OverlapsCreateManyInput | OverlapsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Overlaps update
   */
  export type OverlapsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * The data needed to update a Overlaps.
     */
    data: XOR<OverlapsUpdateInput, OverlapsUncheckedUpdateInput>
    /**
     * Choose, which Overlaps to update.
     */
    where: OverlapsWhereUniqueInput
  }

  /**
   * Overlaps updateMany
   */
  export type OverlapsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Overlaps.
     */
    data: XOR<OverlapsUpdateManyMutationInput, OverlapsUncheckedUpdateManyInput>
    /**
     * Filter which Overlaps to update
     */
    where?: OverlapsWhereInput
  }

  /**
   * Overlaps upsert
   */
  export type OverlapsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * The filter to search for the Overlaps to update in case it exists.
     */
    where: OverlapsWhereUniqueInput
    /**
     * In case the Overlaps found by the `where` argument doesn't exist, create a new Overlaps with this data.
     */
    create: XOR<OverlapsCreateInput, OverlapsUncheckedCreateInput>
    /**
     * In case the Overlaps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OverlapsUpdateInput, OverlapsUncheckedUpdateInput>
  }

  /**
   * Overlaps delete
   */
  export type OverlapsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    /**
     * Filter which Overlaps to delete.
     */
    where: OverlapsWhereUniqueInput
  }

  /**
   * Overlaps deleteMany
   */
  export type OverlapsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Overlaps to delete
     */
    where?: OverlapsWhereInput
  }

  /**
   * Overlaps.buildingCharacter
   */
  export type Overlaps$buildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    where?: BuildingCharacterWhereInput
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    cursor?: BuildingCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * Overlaps without action
   */
  export type OverlapsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
  }


  /**
   * Model WaterSupply
   */

  export type AggregateWaterSupply = {
    _count: WaterSupplyCountAggregateOutputType | null
    _avg: WaterSupplyAvgAggregateOutputType | null
    _sum: WaterSupplySumAggregateOutputType | null
    _min: WaterSupplyMinAggregateOutputType | null
    _max: WaterSupplyMaxAggregateOutputType | null
  }

  export type WaterSupplyAvgAggregateOutputType = {
    id: number | null
  }

  export type WaterSupplySumAggregateOutputType = {
    id: number | null
  }

  export type WaterSupplyMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type WaterSupplyMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type WaterSupplyCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type WaterSupplyAvgAggregateInputType = {
    id?: true
  }

  export type WaterSupplySumAggregateInputType = {
    id?: true
  }

  export type WaterSupplyMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type WaterSupplyMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type WaterSupplyCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type WaterSupplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WaterSupply to aggregate.
     */
    where?: WaterSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaterSupplies to fetch.
     */
    orderBy?: WaterSupplyOrderByWithRelationInput | WaterSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaterSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaterSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaterSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WaterSupplies
    **/
    _count?: true | WaterSupplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WaterSupplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WaterSupplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaterSupplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaterSupplyMaxAggregateInputType
  }

  export type GetWaterSupplyAggregateType<T extends WaterSupplyAggregateArgs> = {
        [P in keyof T & keyof AggregateWaterSupply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWaterSupply[P]>
      : GetScalarType<T[P], AggregateWaterSupply[P]>
  }




  export type WaterSupplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaterSupplyWhereInput
    orderBy?: WaterSupplyOrderByWithAggregationInput | WaterSupplyOrderByWithAggregationInput[]
    by: WaterSupplyScalarFieldEnum[] | WaterSupplyScalarFieldEnum
    having?: WaterSupplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaterSupplyCountAggregateInputType | true
    _avg?: WaterSupplyAvgAggregateInputType
    _sum?: WaterSupplySumAggregateInputType
    _min?: WaterSupplyMinAggregateInputType
    _max?: WaterSupplyMaxAggregateInputType
  }

  export type WaterSupplyGroupByOutputType = {
    id: number
    name: string
    _count: WaterSupplyCountAggregateOutputType | null
    _avg: WaterSupplyAvgAggregateOutputType | null
    _sum: WaterSupplySumAggregateOutputType | null
    _min: WaterSupplyMinAggregateOutputType | null
    _max: WaterSupplyMaxAggregateOutputType | null
  }

  type GetWaterSupplyGroupByPayload<T extends WaterSupplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WaterSupplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaterSupplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaterSupplyGroupByOutputType[P]>
            : GetScalarType<T[P], WaterSupplyGroupByOutputType[P]>
        }
      >
    >


  export type WaterSupplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buildingCharacter?: boolean | WaterSupply$buildingCharacterArgs<ExtArgs>
    _count?: boolean | WaterSupplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["waterSupply"]>

  export type WaterSupplySelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type WaterSupplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | WaterSupply$buildingCharacterArgs<ExtArgs>
    _count?: boolean | WaterSupplyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WaterSupplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WaterSupply"
    objects: {
      buildingCharacter: Prisma.$BuildingCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["waterSupply"]>
    composites: {}
  }


  type WaterSupplyGetPayload<S extends boolean | null | undefined | WaterSupplyDefaultArgs> = $Result.GetResult<Prisma.$WaterSupplyPayload, S>

  type WaterSupplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WaterSupplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WaterSupplyCountAggregateInputType | true
    }

  export interface WaterSupplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WaterSupply'], meta: { name: 'WaterSupply' } }
    /**
     * Find zero or one WaterSupply that matches the filter.
     * @param {WaterSupplyFindUniqueArgs} args - Arguments to find a WaterSupply
     * @example
     * // Get one WaterSupply
     * const waterSupply = await prisma.waterSupply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WaterSupplyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WaterSupplyFindUniqueArgs<ExtArgs>>
    ): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WaterSupply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WaterSupplyFindUniqueOrThrowArgs} args - Arguments to find a WaterSupply
     * @example
     * // Get one WaterSupply
     * const waterSupply = await prisma.waterSupply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WaterSupplyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WaterSupplyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WaterSupply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSupplyFindFirstArgs} args - Arguments to find a WaterSupply
     * @example
     * // Get one WaterSupply
     * const waterSupply = await prisma.waterSupply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WaterSupplyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WaterSupplyFindFirstArgs<ExtArgs>>
    ): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WaterSupply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSupplyFindFirstOrThrowArgs} args - Arguments to find a WaterSupply
     * @example
     * // Get one WaterSupply
     * const waterSupply = await prisma.waterSupply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WaterSupplyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WaterSupplyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WaterSupplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSupplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WaterSupplies
     * const waterSupplies = await prisma.waterSupply.findMany()
     * 
     * // Get first 10 WaterSupplies
     * const waterSupplies = await prisma.waterSupply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waterSupplyWithIdOnly = await prisma.waterSupply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WaterSupplyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WaterSupplyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WaterSupply.
     * @param {WaterSupplyCreateArgs} args - Arguments to create a WaterSupply.
     * @example
     * // Create one WaterSupply
     * const WaterSupply = await prisma.waterSupply.create({
     *   data: {
     *     // ... data to create a WaterSupply
     *   }
     * })
     * 
    **/
    create<T extends WaterSupplyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WaterSupplyCreateArgs<ExtArgs>>
    ): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WaterSupplies.
     *     @param {WaterSupplyCreateManyArgs} args - Arguments to create many WaterSupplies.
     *     @example
     *     // Create many WaterSupplies
     *     const waterSupply = await prisma.waterSupply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WaterSupplyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WaterSupplyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WaterSupply.
     * @param {WaterSupplyDeleteArgs} args - Arguments to delete one WaterSupply.
     * @example
     * // Delete one WaterSupply
     * const WaterSupply = await prisma.waterSupply.delete({
     *   where: {
     *     // ... filter to delete one WaterSupply
     *   }
     * })
     * 
    **/
    delete<T extends WaterSupplyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WaterSupplyDeleteArgs<ExtArgs>>
    ): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WaterSupply.
     * @param {WaterSupplyUpdateArgs} args - Arguments to update one WaterSupply.
     * @example
     * // Update one WaterSupply
     * const waterSupply = await prisma.waterSupply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WaterSupplyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WaterSupplyUpdateArgs<ExtArgs>>
    ): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WaterSupplies.
     * @param {WaterSupplyDeleteManyArgs} args - Arguments to filter WaterSupplies to delete.
     * @example
     * // Delete a few WaterSupplies
     * const { count } = await prisma.waterSupply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WaterSupplyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WaterSupplyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WaterSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSupplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WaterSupplies
     * const waterSupply = await prisma.waterSupply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WaterSupplyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WaterSupplyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WaterSupply.
     * @param {WaterSupplyUpsertArgs} args - Arguments to update or create a WaterSupply.
     * @example
     * // Update or create a WaterSupply
     * const waterSupply = await prisma.waterSupply.upsert({
     *   create: {
     *     // ... data to create a WaterSupply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WaterSupply we want to update
     *   }
     * })
    **/
    upsert<T extends WaterSupplyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WaterSupplyUpsertArgs<ExtArgs>>
    ): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WaterSupplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSupplyCountArgs} args - Arguments to filter WaterSupplies to count.
     * @example
     * // Count the number of WaterSupplies
     * const count = await prisma.waterSupply.count({
     *   where: {
     *     // ... the filter for the WaterSupplies we want to count
     *   }
     * })
    **/
    count<T extends WaterSupplyCountArgs>(
      args?: Subset<T, WaterSupplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaterSupplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WaterSupply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSupplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaterSupplyAggregateArgs>(args: Subset<T, WaterSupplyAggregateArgs>): Prisma.PrismaPromise<GetWaterSupplyAggregateType<T>>

    /**
     * Group by WaterSupply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterSupplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaterSupplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaterSupplyGroupByArgs['orderBy'] }
        : { orderBy?: WaterSupplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaterSupplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaterSupplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WaterSupply model
   */
  readonly fields: WaterSupplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WaterSupply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WaterSupplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingCharacter<T extends WaterSupply$buildingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, WaterSupply$buildingCharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WaterSupply model
   */ 
  interface WaterSupplyFieldRefs {
    readonly id: FieldRef<"WaterSupply", 'Int'>
    readonly name: FieldRef<"WaterSupply", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WaterSupply findUnique
   */
  export type WaterSupplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * Filter, which WaterSupply to fetch.
     */
    where: WaterSupplyWhereUniqueInput
  }

  /**
   * WaterSupply findUniqueOrThrow
   */
  export type WaterSupplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * Filter, which WaterSupply to fetch.
     */
    where: WaterSupplyWhereUniqueInput
  }

  /**
   * WaterSupply findFirst
   */
  export type WaterSupplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * Filter, which WaterSupply to fetch.
     */
    where?: WaterSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaterSupplies to fetch.
     */
    orderBy?: WaterSupplyOrderByWithRelationInput | WaterSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaterSupplies.
     */
    cursor?: WaterSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaterSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaterSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaterSupplies.
     */
    distinct?: WaterSupplyScalarFieldEnum | WaterSupplyScalarFieldEnum[]
  }

  /**
   * WaterSupply findFirstOrThrow
   */
  export type WaterSupplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * Filter, which WaterSupply to fetch.
     */
    where?: WaterSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaterSupplies to fetch.
     */
    orderBy?: WaterSupplyOrderByWithRelationInput | WaterSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WaterSupplies.
     */
    cursor?: WaterSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaterSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaterSupplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WaterSupplies.
     */
    distinct?: WaterSupplyScalarFieldEnum | WaterSupplyScalarFieldEnum[]
  }

  /**
   * WaterSupply findMany
   */
  export type WaterSupplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * Filter, which WaterSupplies to fetch.
     */
    where?: WaterSupplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WaterSupplies to fetch.
     */
    orderBy?: WaterSupplyOrderByWithRelationInput | WaterSupplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WaterSupplies.
     */
    cursor?: WaterSupplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WaterSupplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WaterSupplies.
     */
    skip?: number
    distinct?: WaterSupplyScalarFieldEnum | WaterSupplyScalarFieldEnum[]
  }

  /**
   * WaterSupply create
   */
  export type WaterSupplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * The data needed to create a WaterSupply.
     */
    data: XOR<WaterSupplyCreateInput, WaterSupplyUncheckedCreateInput>
  }

  /**
   * WaterSupply createMany
   */
  export type WaterSupplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WaterSupplies.
     */
    data: WaterSupplyCreateManyInput | WaterSupplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WaterSupply update
   */
  export type WaterSupplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * The data needed to update a WaterSupply.
     */
    data: XOR<WaterSupplyUpdateInput, WaterSupplyUncheckedUpdateInput>
    /**
     * Choose, which WaterSupply to update.
     */
    where: WaterSupplyWhereUniqueInput
  }

  /**
   * WaterSupply updateMany
   */
  export type WaterSupplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WaterSupplies.
     */
    data: XOR<WaterSupplyUpdateManyMutationInput, WaterSupplyUncheckedUpdateManyInput>
    /**
     * Filter which WaterSupplies to update
     */
    where?: WaterSupplyWhereInput
  }

  /**
   * WaterSupply upsert
   */
  export type WaterSupplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * The filter to search for the WaterSupply to update in case it exists.
     */
    where: WaterSupplyWhereUniqueInput
    /**
     * In case the WaterSupply found by the `where` argument doesn't exist, create a new WaterSupply with this data.
     */
    create: XOR<WaterSupplyCreateInput, WaterSupplyUncheckedCreateInput>
    /**
     * In case the WaterSupply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaterSupplyUpdateInput, WaterSupplyUncheckedUpdateInput>
  }

  /**
   * WaterSupply delete
   */
  export type WaterSupplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    /**
     * Filter which WaterSupply to delete.
     */
    where: WaterSupplyWhereUniqueInput
  }

  /**
   * WaterSupply deleteMany
   */
  export type WaterSupplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WaterSupplies to delete
     */
    where?: WaterSupplyWhereInput
  }

  /**
   * WaterSupply.buildingCharacter
   */
  export type WaterSupply$buildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    where?: BuildingCharacterWhereInput
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    cursor?: BuildingCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * WaterSupply without action
   */
  export type WaterSupplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
  }


  /**
   * Model HeatingSystem
   */

  export type AggregateHeatingSystem = {
    _count: HeatingSystemCountAggregateOutputType | null
    _avg: HeatingSystemAvgAggregateOutputType | null
    _sum: HeatingSystemSumAggregateOutputType | null
    _min: HeatingSystemMinAggregateOutputType | null
    _max: HeatingSystemMaxAggregateOutputType | null
  }

  export type HeatingSystemAvgAggregateOutputType = {
    id: number | null
  }

  export type HeatingSystemSumAggregateOutputType = {
    id: number | null
  }

  export type HeatingSystemMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type HeatingSystemMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type HeatingSystemCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type HeatingSystemAvgAggregateInputType = {
    id?: true
  }

  export type HeatingSystemSumAggregateInputType = {
    id?: true
  }

  export type HeatingSystemMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type HeatingSystemMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type HeatingSystemCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type HeatingSystemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeatingSystem to aggregate.
     */
    where?: HeatingSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeatingSystems to fetch.
     */
    orderBy?: HeatingSystemOrderByWithRelationInput | HeatingSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeatingSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeatingSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeatingSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeatingSystems
    **/
    _count?: true | HeatingSystemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HeatingSystemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HeatingSystemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeatingSystemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeatingSystemMaxAggregateInputType
  }

  export type GetHeatingSystemAggregateType<T extends HeatingSystemAggregateArgs> = {
        [P in keyof T & keyof AggregateHeatingSystem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeatingSystem[P]>
      : GetScalarType<T[P], AggregateHeatingSystem[P]>
  }




  export type HeatingSystemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeatingSystemWhereInput
    orderBy?: HeatingSystemOrderByWithAggregationInput | HeatingSystemOrderByWithAggregationInput[]
    by: HeatingSystemScalarFieldEnum[] | HeatingSystemScalarFieldEnum
    having?: HeatingSystemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeatingSystemCountAggregateInputType | true
    _avg?: HeatingSystemAvgAggregateInputType
    _sum?: HeatingSystemSumAggregateInputType
    _min?: HeatingSystemMinAggregateInputType
    _max?: HeatingSystemMaxAggregateInputType
  }

  export type HeatingSystemGroupByOutputType = {
    id: number
    name: string
    _count: HeatingSystemCountAggregateOutputType | null
    _avg: HeatingSystemAvgAggregateOutputType | null
    _sum: HeatingSystemSumAggregateOutputType | null
    _min: HeatingSystemMinAggregateOutputType | null
    _max: HeatingSystemMaxAggregateOutputType | null
  }

  type GetHeatingSystemGroupByPayload<T extends HeatingSystemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeatingSystemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeatingSystemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeatingSystemGroupByOutputType[P]>
            : GetScalarType<T[P], HeatingSystemGroupByOutputType[P]>
        }
      >
    >


  export type HeatingSystemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buildingCharacter?: boolean | HeatingSystem$buildingCharacterArgs<ExtArgs>
    _count?: boolean | HeatingSystemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["heatingSystem"]>

  export type HeatingSystemSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type HeatingSystemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | HeatingSystem$buildingCharacterArgs<ExtArgs>
    _count?: boolean | HeatingSystemCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $HeatingSystemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeatingSystem"
    objects: {
      buildingCharacter: Prisma.$BuildingCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["heatingSystem"]>
    composites: {}
  }


  type HeatingSystemGetPayload<S extends boolean | null | undefined | HeatingSystemDefaultArgs> = $Result.GetResult<Prisma.$HeatingSystemPayload, S>

  type HeatingSystemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HeatingSystemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HeatingSystemCountAggregateInputType | true
    }

  export interface HeatingSystemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeatingSystem'], meta: { name: 'HeatingSystem' } }
    /**
     * Find zero or one HeatingSystem that matches the filter.
     * @param {HeatingSystemFindUniqueArgs} args - Arguments to find a HeatingSystem
     * @example
     * // Get one HeatingSystem
     * const heatingSystem = await prisma.heatingSystem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HeatingSystemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HeatingSystemFindUniqueArgs<ExtArgs>>
    ): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HeatingSystem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HeatingSystemFindUniqueOrThrowArgs} args - Arguments to find a HeatingSystem
     * @example
     * // Get one HeatingSystem
     * const heatingSystem = await prisma.heatingSystem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HeatingSystemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HeatingSystemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HeatingSystem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeatingSystemFindFirstArgs} args - Arguments to find a HeatingSystem
     * @example
     * // Get one HeatingSystem
     * const heatingSystem = await prisma.heatingSystem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HeatingSystemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HeatingSystemFindFirstArgs<ExtArgs>>
    ): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HeatingSystem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeatingSystemFindFirstOrThrowArgs} args - Arguments to find a HeatingSystem
     * @example
     * // Get one HeatingSystem
     * const heatingSystem = await prisma.heatingSystem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HeatingSystemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HeatingSystemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HeatingSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeatingSystemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeatingSystems
     * const heatingSystems = await prisma.heatingSystem.findMany()
     * 
     * // Get first 10 HeatingSystems
     * const heatingSystems = await prisma.heatingSystem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heatingSystemWithIdOnly = await prisma.heatingSystem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HeatingSystemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HeatingSystemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HeatingSystem.
     * @param {HeatingSystemCreateArgs} args - Arguments to create a HeatingSystem.
     * @example
     * // Create one HeatingSystem
     * const HeatingSystem = await prisma.heatingSystem.create({
     *   data: {
     *     // ... data to create a HeatingSystem
     *   }
     * })
     * 
    **/
    create<T extends HeatingSystemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HeatingSystemCreateArgs<ExtArgs>>
    ): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HeatingSystems.
     *     @param {HeatingSystemCreateManyArgs} args - Arguments to create many HeatingSystems.
     *     @example
     *     // Create many HeatingSystems
     *     const heatingSystem = await prisma.heatingSystem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HeatingSystemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HeatingSystemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HeatingSystem.
     * @param {HeatingSystemDeleteArgs} args - Arguments to delete one HeatingSystem.
     * @example
     * // Delete one HeatingSystem
     * const HeatingSystem = await prisma.heatingSystem.delete({
     *   where: {
     *     // ... filter to delete one HeatingSystem
     *   }
     * })
     * 
    **/
    delete<T extends HeatingSystemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HeatingSystemDeleteArgs<ExtArgs>>
    ): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HeatingSystem.
     * @param {HeatingSystemUpdateArgs} args - Arguments to update one HeatingSystem.
     * @example
     * // Update one HeatingSystem
     * const heatingSystem = await prisma.heatingSystem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HeatingSystemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HeatingSystemUpdateArgs<ExtArgs>>
    ): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HeatingSystems.
     * @param {HeatingSystemDeleteManyArgs} args - Arguments to filter HeatingSystems to delete.
     * @example
     * // Delete a few HeatingSystems
     * const { count } = await prisma.heatingSystem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HeatingSystemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HeatingSystemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeatingSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeatingSystemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeatingSystems
     * const heatingSystem = await prisma.heatingSystem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HeatingSystemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HeatingSystemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HeatingSystem.
     * @param {HeatingSystemUpsertArgs} args - Arguments to update or create a HeatingSystem.
     * @example
     * // Update or create a HeatingSystem
     * const heatingSystem = await prisma.heatingSystem.upsert({
     *   create: {
     *     // ... data to create a HeatingSystem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeatingSystem we want to update
     *   }
     * })
    **/
    upsert<T extends HeatingSystemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HeatingSystemUpsertArgs<ExtArgs>>
    ): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HeatingSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeatingSystemCountArgs} args - Arguments to filter HeatingSystems to count.
     * @example
     * // Count the number of HeatingSystems
     * const count = await prisma.heatingSystem.count({
     *   where: {
     *     // ... the filter for the HeatingSystems we want to count
     *   }
     * })
    **/
    count<T extends HeatingSystemCountArgs>(
      args?: Subset<T, HeatingSystemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeatingSystemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeatingSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeatingSystemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeatingSystemAggregateArgs>(args: Subset<T, HeatingSystemAggregateArgs>): Prisma.PrismaPromise<GetHeatingSystemAggregateType<T>>

    /**
     * Group by HeatingSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeatingSystemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeatingSystemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeatingSystemGroupByArgs['orderBy'] }
        : { orderBy?: HeatingSystemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeatingSystemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeatingSystemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeatingSystem model
   */
  readonly fields: HeatingSystemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeatingSystem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeatingSystemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingCharacter<T extends HeatingSystem$buildingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, HeatingSystem$buildingCharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HeatingSystem model
   */ 
  interface HeatingSystemFieldRefs {
    readonly id: FieldRef<"HeatingSystem", 'Int'>
    readonly name: FieldRef<"HeatingSystem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HeatingSystem findUnique
   */
  export type HeatingSystemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * Filter, which HeatingSystem to fetch.
     */
    where: HeatingSystemWhereUniqueInput
  }

  /**
   * HeatingSystem findUniqueOrThrow
   */
  export type HeatingSystemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * Filter, which HeatingSystem to fetch.
     */
    where: HeatingSystemWhereUniqueInput
  }

  /**
   * HeatingSystem findFirst
   */
  export type HeatingSystemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * Filter, which HeatingSystem to fetch.
     */
    where?: HeatingSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeatingSystems to fetch.
     */
    orderBy?: HeatingSystemOrderByWithRelationInput | HeatingSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeatingSystems.
     */
    cursor?: HeatingSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeatingSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeatingSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeatingSystems.
     */
    distinct?: HeatingSystemScalarFieldEnum | HeatingSystemScalarFieldEnum[]
  }

  /**
   * HeatingSystem findFirstOrThrow
   */
  export type HeatingSystemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * Filter, which HeatingSystem to fetch.
     */
    where?: HeatingSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeatingSystems to fetch.
     */
    orderBy?: HeatingSystemOrderByWithRelationInput | HeatingSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeatingSystems.
     */
    cursor?: HeatingSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeatingSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeatingSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeatingSystems.
     */
    distinct?: HeatingSystemScalarFieldEnum | HeatingSystemScalarFieldEnum[]
  }

  /**
   * HeatingSystem findMany
   */
  export type HeatingSystemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * Filter, which HeatingSystems to fetch.
     */
    where?: HeatingSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeatingSystems to fetch.
     */
    orderBy?: HeatingSystemOrderByWithRelationInput | HeatingSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeatingSystems.
     */
    cursor?: HeatingSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeatingSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeatingSystems.
     */
    skip?: number
    distinct?: HeatingSystemScalarFieldEnum | HeatingSystemScalarFieldEnum[]
  }

  /**
   * HeatingSystem create
   */
  export type HeatingSystemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * The data needed to create a HeatingSystem.
     */
    data: XOR<HeatingSystemCreateInput, HeatingSystemUncheckedCreateInput>
  }

  /**
   * HeatingSystem createMany
   */
  export type HeatingSystemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeatingSystems.
     */
    data: HeatingSystemCreateManyInput | HeatingSystemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeatingSystem update
   */
  export type HeatingSystemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * The data needed to update a HeatingSystem.
     */
    data: XOR<HeatingSystemUpdateInput, HeatingSystemUncheckedUpdateInput>
    /**
     * Choose, which HeatingSystem to update.
     */
    where: HeatingSystemWhereUniqueInput
  }

  /**
   * HeatingSystem updateMany
   */
  export type HeatingSystemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeatingSystems.
     */
    data: XOR<HeatingSystemUpdateManyMutationInput, HeatingSystemUncheckedUpdateManyInput>
    /**
     * Filter which HeatingSystems to update
     */
    where?: HeatingSystemWhereInput
  }

  /**
   * HeatingSystem upsert
   */
  export type HeatingSystemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * The filter to search for the HeatingSystem to update in case it exists.
     */
    where: HeatingSystemWhereUniqueInput
    /**
     * In case the HeatingSystem found by the `where` argument doesn't exist, create a new HeatingSystem with this data.
     */
    create: XOR<HeatingSystemCreateInput, HeatingSystemUncheckedCreateInput>
    /**
     * In case the HeatingSystem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeatingSystemUpdateInput, HeatingSystemUncheckedUpdateInput>
  }

  /**
   * HeatingSystem delete
   */
  export type HeatingSystemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    /**
     * Filter which HeatingSystem to delete.
     */
    where: HeatingSystemWhereUniqueInput
  }

  /**
   * HeatingSystem deleteMany
   */
  export type HeatingSystemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeatingSystems to delete
     */
    where?: HeatingSystemWhereInput
  }

  /**
   * HeatingSystem.buildingCharacter
   */
  export type HeatingSystem$buildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    where?: BuildingCharacterWhereInput
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    cursor?: BuildingCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * HeatingSystem without action
   */
  export type HeatingSystemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
  }


  /**
   * Model Parking
   */

  export type AggregateParking = {
    _count: ParkingCountAggregateOutputType | null
    _avg: ParkingAvgAggregateOutputType | null
    _sum: ParkingSumAggregateOutputType | null
    _min: ParkingMinAggregateOutputType | null
    _max: ParkingMaxAggregateOutputType | null
  }

  export type ParkingAvgAggregateOutputType = {
    id: number | null
  }

  export type ParkingSumAggregateOutputType = {
    id: number | null
  }

  export type ParkingMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ParkingMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ParkingCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ParkingAvgAggregateInputType = {
    id?: true
  }

  export type ParkingSumAggregateInputType = {
    id?: true
  }

  export type ParkingMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ParkingMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ParkingCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ParkingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parking to aggregate.
     */
    where?: ParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parkings to fetch.
     */
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parkings
    **/
    _count?: true | ParkingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingMaxAggregateInputType
  }

  export type GetParkingAggregateType<T extends ParkingAggregateArgs> = {
        [P in keyof T & keyof AggregateParking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParking[P]>
      : GetScalarType<T[P], AggregateParking[P]>
  }




  export type ParkingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingWhereInput
    orderBy?: ParkingOrderByWithAggregationInput | ParkingOrderByWithAggregationInput[]
    by: ParkingScalarFieldEnum[] | ParkingScalarFieldEnum
    having?: ParkingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingCountAggregateInputType | true
    _avg?: ParkingAvgAggregateInputType
    _sum?: ParkingSumAggregateInputType
    _min?: ParkingMinAggregateInputType
    _max?: ParkingMaxAggregateInputType
  }

  export type ParkingGroupByOutputType = {
    id: number
    name: string
    _count: ParkingCountAggregateOutputType | null
    _avg: ParkingAvgAggregateOutputType | null
    _sum: ParkingSumAggregateOutputType | null
    _min: ParkingMinAggregateOutputType | null
    _max: ParkingMaxAggregateOutputType | null
  }

  type GetParkingGroupByPayload<T extends ParkingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingGroupByOutputType[P]>
        }
      >
    >


  export type ParkingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    buildingCharacter?: boolean | Parking$buildingCharacterArgs<ExtArgs>
    _count?: boolean | ParkingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parking"]>

  export type ParkingSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type ParkingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buildingCharacter?: boolean | Parking$buildingCharacterArgs<ExtArgs>
    _count?: boolean | ParkingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ParkingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parking"
    objects: {
      buildingCharacter: Prisma.$BuildingCharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["parking"]>
    composites: {}
  }


  type ParkingGetPayload<S extends boolean | null | undefined | ParkingDefaultArgs> = $Result.GetResult<Prisma.$ParkingPayload, S>

  type ParkingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParkingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParkingCountAggregateInputType | true
    }

  export interface ParkingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parking'], meta: { name: 'Parking' } }
    /**
     * Find zero or one Parking that matches the filter.
     * @param {ParkingFindUniqueArgs} args - Arguments to find a Parking
     * @example
     * // Get one Parking
     * const parking = await prisma.parking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParkingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ParkingFindUniqueArgs<ExtArgs>>
    ): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Parking that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ParkingFindUniqueOrThrowArgs} args - Arguments to find a Parking
     * @example
     * // Get one Parking
     * const parking = await prisma.parking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ParkingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParkingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Parking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingFindFirstArgs} args - Arguments to find a Parking
     * @example
     * // Get one Parking
     * const parking = await prisma.parking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParkingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ParkingFindFirstArgs<ExtArgs>>
    ): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Parking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingFindFirstOrThrowArgs} args - Arguments to find a Parking
     * @example
     * // Get one Parking
     * const parking = await prisma.parking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ParkingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParkingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Parkings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parkings
     * const parkings = await prisma.parking.findMany()
     * 
     * // Get first 10 Parkings
     * const parkings = await prisma.parking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingWithIdOnly = await prisma.parking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParkingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParkingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Parking.
     * @param {ParkingCreateArgs} args - Arguments to create a Parking.
     * @example
     * // Create one Parking
     * const Parking = await prisma.parking.create({
     *   data: {
     *     // ... data to create a Parking
     *   }
     * })
     * 
    **/
    create<T extends ParkingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ParkingCreateArgs<ExtArgs>>
    ): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Parkings.
     *     @param {ParkingCreateManyArgs} args - Arguments to create many Parkings.
     *     @example
     *     // Create many Parkings
     *     const parking = await prisma.parking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParkingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParkingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parking.
     * @param {ParkingDeleteArgs} args - Arguments to delete one Parking.
     * @example
     * // Delete one Parking
     * const Parking = await prisma.parking.delete({
     *   where: {
     *     // ... filter to delete one Parking
     *   }
     * })
     * 
    **/
    delete<T extends ParkingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ParkingDeleteArgs<ExtArgs>>
    ): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Parking.
     * @param {ParkingUpdateArgs} args - Arguments to update one Parking.
     * @example
     * // Update one Parking
     * const parking = await prisma.parking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParkingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ParkingUpdateArgs<ExtArgs>>
    ): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Parkings.
     * @param {ParkingDeleteManyArgs} args - Arguments to filter Parkings to delete.
     * @example
     * // Delete a few Parkings
     * const { count } = await prisma.parking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParkingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParkingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parkings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parkings
     * const parking = await prisma.parking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParkingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ParkingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parking.
     * @param {ParkingUpsertArgs} args - Arguments to update or create a Parking.
     * @example
     * // Update or create a Parking
     * const parking = await prisma.parking.upsert({
     *   create: {
     *     // ... data to create a Parking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parking we want to update
     *   }
     * })
    **/
    upsert<T extends ParkingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ParkingUpsertArgs<ExtArgs>>
    ): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Parkings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingCountArgs} args - Arguments to filter Parkings to count.
     * @example
     * // Count the number of Parkings
     * const count = await prisma.parking.count({
     *   where: {
     *     // ... the filter for the Parkings we want to count
     *   }
     * })
    **/
    count<T extends ParkingCountArgs>(
      args?: Subset<T, ParkingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingAggregateArgs>(args: Subset<T, ParkingAggregateArgs>): Prisma.PrismaPromise<GetParkingAggregateType<T>>

    /**
     * Group by Parking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingGroupByArgs['orderBy'] }
        : { orderBy?: ParkingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parking model
   */
  readonly fields: ParkingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buildingCharacter<T extends Parking$buildingCharacterArgs<ExtArgs> = {}>(args?: Subset<T, Parking$buildingCharacterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Parking model
   */ 
  interface ParkingFieldRefs {
    readonly id: FieldRef<"Parking", 'Int'>
    readonly name: FieldRef<"Parking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Parking findUnique
   */
  export type ParkingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parking to fetch.
     */
    where: ParkingWhereUniqueInput
  }

  /**
   * Parking findUniqueOrThrow
   */
  export type ParkingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parking to fetch.
     */
    where: ParkingWhereUniqueInput
  }

  /**
   * Parking findFirst
   */
  export type ParkingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parking to fetch.
     */
    where?: ParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parkings to fetch.
     */
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parkings.
     */
    cursor?: ParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parkings.
     */
    distinct?: ParkingScalarFieldEnum | ParkingScalarFieldEnum[]
  }

  /**
   * Parking findFirstOrThrow
   */
  export type ParkingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parking to fetch.
     */
    where?: ParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parkings to fetch.
     */
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parkings.
     */
    cursor?: ParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parkings.
     */
    distinct?: ParkingScalarFieldEnum | ParkingScalarFieldEnum[]
  }

  /**
   * Parking findMany
   */
  export type ParkingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parkings to fetch.
     */
    where?: ParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parkings to fetch.
     */
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parkings.
     */
    cursor?: ParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parkings.
     */
    skip?: number
    distinct?: ParkingScalarFieldEnum | ParkingScalarFieldEnum[]
  }

  /**
   * Parking create
   */
  export type ParkingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * The data needed to create a Parking.
     */
    data: XOR<ParkingCreateInput, ParkingUncheckedCreateInput>
  }

  /**
   * Parking createMany
   */
  export type ParkingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parkings.
     */
    data: ParkingCreateManyInput | ParkingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parking update
   */
  export type ParkingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * The data needed to update a Parking.
     */
    data: XOR<ParkingUpdateInput, ParkingUncheckedUpdateInput>
    /**
     * Choose, which Parking to update.
     */
    where: ParkingWhereUniqueInput
  }

  /**
   * Parking updateMany
   */
  export type ParkingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parkings.
     */
    data: XOR<ParkingUpdateManyMutationInput, ParkingUncheckedUpdateManyInput>
    /**
     * Filter which Parkings to update
     */
    where?: ParkingWhereInput
  }

  /**
   * Parking upsert
   */
  export type ParkingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * The filter to search for the Parking to update in case it exists.
     */
    where: ParkingWhereUniqueInput
    /**
     * In case the Parking found by the `where` argument doesn't exist, create a new Parking with this data.
     */
    create: XOR<ParkingCreateInput, ParkingUncheckedCreateInput>
    /**
     * In case the Parking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingUpdateInput, ParkingUncheckedUpdateInput>
  }

  /**
   * Parking delete
   */
  export type ParkingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter which Parking to delete.
     */
    where: ParkingWhereUniqueInput
  }

  /**
   * Parking deleteMany
   */
  export type ParkingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parkings to delete
     */
    where?: ParkingWhereInput
  }

  /**
   * Parking.buildingCharacter
   */
  export type Parking$buildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    where?: BuildingCharacterWhereInput
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    cursor?: BuildingCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * Parking without action
   */
  export type ParkingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
  }


  /**
   * Model BuildingCharacter
   */

  export type AggregateBuildingCharacter = {
    _count: BuildingCharacterCountAggregateOutputType | null
    _avg: BuildingCharacterAvgAggregateOutputType | null
    _sum: BuildingCharacterSumAggregateOutputType | null
    _min: BuildingCharacterMinAggregateOutputType | null
    _max: BuildingCharacterMaxAggregateOutputType | null
  }

  export type BuildingCharacterAvgAggregateOutputType = {
    id: number | null
    buildingConditionId: number | null
    buildingSeriaId: number | null
    wallMaterialId: number | null
    overlapsId: number | null
    waterSupplyId: number | null
    heatingSystemId: number | null
    passenger_elevators_count: number | null
    freight_elevators_count: number | null
    parkingId: number | null
  }

  export type BuildingCharacterSumAggregateOutputType = {
    id: number | null
    buildingConditionId: number | null
    buildingSeriaId: number | null
    wallMaterialId: number | null
    overlapsId: number | null
    waterSupplyId: number | null
    heatingSystemId: number | null
    passenger_elevators_count: number | null
    freight_elevators_count: number | null
    parkingId: number | null
  }

  export type BuildingCharacterMinAggregateOutputType = {
    id: number | null
    buildingConditionId: number | null
    buildingSeriaId: number | null
    building_year: string | null
    wallMaterialId: number | null
    overlapsId: number | null
    waterSupplyId: number | null
    heatingSystemId: number | null
    is_gas: boolean | null
    is_electric: boolean | null
    passenger_elevators_count: number | null
    freight_elevators_count: number | null
    is_building_security: boolean | null
    parkingId: number | null
    is_demolition_planned: boolean | null
  }

  export type BuildingCharacterMaxAggregateOutputType = {
    id: number | null
    buildingConditionId: number | null
    buildingSeriaId: number | null
    building_year: string | null
    wallMaterialId: number | null
    overlapsId: number | null
    waterSupplyId: number | null
    heatingSystemId: number | null
    is_gas: boolean | null
    is_electric: boolean | null
    passenger_elevators_count: number | null
    freight_elevators_count: number | null
    is_building_security: boolean | null
    parkingId: number | null
    is_demolition_planned: boolean | null
  }

  export type BuildingCharacterCountAggregateOutputType = {
    id: number
    buildingConditionId: number
    buildingSeriaId: number
    building_year: number
    wallMaterialId: number
    overlapsId: number
    waterSupplyId: number
    heatingSystemId: number
    is_gas: number
    is_electric: number
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: number
    parkingId: number
    is_demolition_planned: number
    _all: number
  }


  export type BuildingCharacterAvgAggregateInputType = {
    id?: true
    buildingConditionId?: true
    buildingSeriaId?: true
    wallMaterialId?: true
    overlapsId?: true
    waterSupplyId?: true
    heatingSystemId?: true
    passenger_elevators_count?: true
    freight_elevators_count?: true
    parkingId?: true
  }

  export type BuildingCharacterSumAggregateInputType = {
    id?: true
    buildingConditionId?: true
    buildingSeriaId?: true
    wallMaterialId?: true
    overlapsId?: true
    waterSupplyId?: true
    heatingSystemId?: true
    passenger_elevators_count?: true
    freight_elevators_count?: true
    parkingId?: true
  }

  export type BuildingCharacterMinAggregateInputType = {
    id?: true
    buildingConditionId?: true
    buildingSeriaId?: true
    building_year?: true
    wallMaterialId?: true
    overlapsId?: true
    waterSupplyId?: true
    heatingSystemId?: true
    is_gas?: true
    is_electric?: true
    passenger_elevators_count?: true
    freight_elevators_count?: true
    is_building_security?: true
    parkingId?: true
    is_demolition_planned?: true
  }

  export type BuildingCharacterMaxAggregateInputType = {
    id?: true
    buildingConditionId?: true
    buildingSeriaId?: true
    building_year?: true
    wallMaterialId?: true
    overlapsId?: true
    waterSupplyId?: true
    heatingSystemId?: true
    is_gas?: true
    is_electric?: true
    passenger_elevators_count?: true
    freight_elevators_count?: true
    is_building_security?: true
    parkingId?: true
    is_demolition_planned?: true
  }

  export type BuildingCharacterCountAggregateInputType = {
    id?: true
    buildingConditionId?: true
    buildingSeriaId?: true
    building_year?: true
    wallMaterialId?: true
    overlapsId?: true
    waterSupplyId?: true
    heatingSystemId?: true
    is_gas?: true
    is_electric?: true
    passenger_elevators_count?: true
    freight_elevators_count?: true
    is_building_security?: true
    parkingId?: true
    is_demolition_planned?: true
    _all?: true
  }

  export type BuildingCharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildingCharacter to aggregate.
     */
    where?: BuildingCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingCharacters to fetch.
     */
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildingCharacters
    **/
    _count?: true | BuildingCharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildingCharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildingCharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingCharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingCharacterMaxAggregateInputType
  }

  export type GetBuildingCharacterAggregateType<T extends BuildingCharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildingCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildingCharacter[P]>
      : GetScalarType<T[P], AggregateBuildingCharacter[P]>
  }




  export type BuildingCharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingCharacterWhereInput
    orderBy?: BuildingCharacterOrderByWithAggregationInput | BuildingCharacterOrderByWithAggregationInput[]
    by: BuildingCharacterScalarFieldEnum[] | BuildingCharacterScalarFieldEnum
    having?: BuildingCharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCharacterCountAggregateInputType | true
    _avg?: BuildingCharacterAvgAggregateInputType
    _sum?: BuildingCharacterSumAggregateInputType
    _min?: BuildingCharacterMinAggregateInputType
    _max?: BuildingCharacterMaxAggregateInputType
  }

  export type BuildingCharacterGroupByOutputType = {
    id: number
    buildingConditionId: number | null
    buildingSeriaId: number | null
    building_year: string
    wallMaterialId: number | null
    overlapsId: number | null
    waterSupplyId: number | null
    heatingSystemId: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId: number | null
    is_demolition_planned: boolean
    _count: BuildingCharacterCountAggregateOutputType | null
    _avg: BuildingCharacterAvgAggregateOutputType | null
    _sum: BuildingCharacterSumAggregateOutputType | null
    _min: BuildingCharacterMinAggregateOutputType | null
    _max: BuildingCharacterMaxAggregateOutputType | null
  }

  type GetBuildingCharacterGroupByPayload<T extends BuildingCharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingCharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingCharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingCharacterGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingCharacterGroupByOutputType[P]>
        }
      >
    >


  export type BuildingCharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildingConditionId?: boolean
    buildingSeriaId?: boolean
    building_year?: boolean
    wallMaterialId?: boolean
    overlapsId?: boolean
    waterSupplyId?: boolean
    heatingSystemId?: boolean
    is_gas?: boolean
    is_electric?: boolean
    passenger_elevators_count?: boolean
    freight_elevators_count?: boolean
    is_building_security?: boolean
    parkingId?: boolean
    is_demolition_planned?: boolean
    BuildingCondition?: boolean | BuildingCharacter$BuildingConditionArgs<ExtArgs>
    BuildingSeria?: boolean | BuildingCharacter$BuildingSeriaArgs<ExtArgs>
    WallMaterial?: boolean | BuildingCharacter$WallMaterialArgs<ExtArgs>
    Overlaps?: boolean | BuildingCharacter$OverlapsArgs<ExtArgs>
    WaterSupply?: boolean | BuildingCharacter$WaterSupplyArgs<ExtArgs>
    HeatingSystem?: boolean | BuildingCharacter$HeatingSystemArgs<ExtArgs>
    Parking?: boolean | BuildingCharacter$ParkingArgs<ExtArgs>
  }, ExtArgs["result"]["buildingCharacter"]>

  export type BuildingCharacterSelectScalar = {
    id?: boolean
    buildingConditionId?: boolean
    buildingSeriaId?: boolean
    building_year?: boolean
    wallMaterialId?: boolean
    overlapsId?: boolean
    waterSupplyId?: boolean
    heatingSystemId?: boolean
    is_gas?: boolean
    is_electric?: boolean
    passenger_elevators_count?: boolean
    freight_elevators_count?: boolean
    is_building_security?: boolean
    parkingId?: boolean
    is_demolition_planned?: boolean
  }


  export type BuildingCharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BuildingCondition?: boolean | BuildingCharacter$BuildingConditionArgs<ExtArgs>
    BuildingSeria?: boolean | BuildingCharacter$BuildingSeriaArgs<ExtArgs>
    WallMaterial?: boolean | BuildingCharacter$WallMaterialArgs<ExtArgs>
    Overlaps?: boolean | BuildingCharacter$OverlapsArgs<ExtArgs>
    WaterSupply?: boolean | BuildingCharacter$WaterSupplyArgs<ExtArgs>
    HeatingSystem?: boolean | BuildingCharacter$HeatingSystemArgs<ExtArgs>
    Parking?: boolean | BuildingCharacter$ParkingArgs<ExtArgs>
  }


  export type $BuildingCharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildingCharacter"
    objects: {
      BuildingCondition: Prisma.$BuildingConditionPayload<ExtArgs> | null
      BuildingSeria: Prisma.$BuildingSeriaPayload<ExtArgs> | null
      WallMaterial: Prisma.$WallMaterialPayload<ExtArgs> | null
      Overlaps: Prisma.$OverlapsPayload<ExtArgs> | null
      WaterSupply: Prisma.$WaterSupplyPayload<ExtArgs> | null
      HeatingSystem: Prisma.$HeatingSystemPayload<ExtArgs> | null
      Parking: Prisma.$ParkingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      buildingConditionId: number | null
      buildingSeriaId: number | null
      building_year: string
      wallMaterialId: number | null
      overlapsId: number | null
      waterSupplyId: number | null
      heatingSystemId: number | null
      is_gas: boolean
      is_electric: boolean
      passenger_elevators_count: number
      freight_elevators_count: number
      is_building_security: boolean
      parkingId: number | null
      is_demolition_planned: boolean
    }, ExtArgs["result"]["buildingCharacter"]>
    composites: {}
  }


  type BuildingCharacterGetPayload<S extends boolean | null | undefined | BuildingCharacterDefaultArgs> = $Result.GetResult<Prisma.$BuildingCharacterPayload, S>

  type BuildingCharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildingCharacterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildingCharacterCountAggregateInputType | true
    }

  export interface BuildingCharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildingCharacter'], meta: { name: 'BuildingCharacter' } }
    /**
     * Find zero or one BuildingCharacter that matches the filter.
     * @param {BuildingCharacterFindUniqueArgs} args - Arguments to find a BuildingCharacter
     * @example
     * // Get one BuildingCharacter
     * const buildingCharacter = await prisma.buildingCharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildingCharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingCharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildingCharacterClient<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BuildingCharacter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildingCharacterFindUniqueOrThrowArgs} args - Arguments to find a BuildingCharacter
     * @example
     * // Get one BuildingCharacter
     * const buildingCharacter = await prisma.buildingCharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildingCharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingCharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingCharacterClient<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BuildingCharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCharacterFindFirstArgs} args - Arguments to find a BuildingCharacter
     * @example
     * // Get one BuildingCharacter
     * const buildingCharacter = await prisma.buildingCharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildingCharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingCharacterFindFirstArgs<ExtArgs>>
    ): Prisma__BuildingCharacterClient<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BuildingCharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCharacterFindFirstOrThrowArgs} args - Arguments to find a BuildingCharacter
     * @example
     * // Get one BuildingCharacter
     * const buildingCharacter = await prisma.buildingCharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildingCharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingCharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingCharacterClient<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BuildingCharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildingCharacters
     * const buildingCharacters = await prisma.buildingCharacter.findMany()
     * 
     * // Get first 10 BuildingCharacters
     * const buildingCharacters = await prisma.buildingCharacter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingCharacterWithIdOnly = await prisma.buildingCharacter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildingCharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingCharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BuildingCharacter.
     * @param {BuildingCharacterCreateArgs} args - Arguments to create a BuildingCharacter.
     * @example
     * // Create one BuildingCharacter
     * const BuildingCharacter = await prisma.buildingCharacter.create({
     *   data: {
     *     // ... data to create a BuildingCharacter
     *   }
     * })
     * 
    **/
    create<T extends BuildingCharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingCharacterCreateArgs<ExtArgs>>
    ): Prisma__BuildingCharacterClient<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BuildingCharacters.
     *     @param {BuildingCharacterCreateManyArgs} args - Arguments to create many BuildingCharacters.
     *     @example
     *     // Create many BuildingCharacters
     *     const buildingCharacter = await prisma.buildingCharacter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildingCharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingCharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuildingCharacter.
     * @param {BuildingCharacterDeleteArgs} args - Arguments to delete one BuildingCharacter.
     * @example
     * // Delete one BuildingCharacter
     * const BuildingCharacter = await prisma.buildingCharacter.delete({
     *   where: {
     *     // ... filter to delete one BuildingCharacter
     *   }
     * })
     * 
    **/
    delete<T extends BuildingCharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingCharacterDeleteArgs<ExtArgs>>
    ): Prisma__BuildingCharacterClient<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BuildingCharacter.
     * @param {BuildingCharacterUpdateArgs} args - Arguments to update one BuildingCharacter.
     * @example
     * // Update one BuildingCharacter
     * const buildingCharacter = await prisma.buildingCharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildingCharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingCharacterUpdateArgs<ExtArgs>>
    ): Prisma__BuildingCharacterClient<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BuildingCharacters.
     * @param {BuildingCharacterDeleteManyArgs} args - Arguments to filter BuildingCharacters to delete.
     * @example
     * // Delete a few BuildingCharacters
     * const { count } = await prisma.buildingCharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildingCharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingCharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildingCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildingCharacters
     * const buildingCharacter = await prisma.buildingCharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildingCharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingCharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildingCharacter.
     * @param {BuildingCharacterUpsertArgs} args - Arguments to update or create a BuildingCharacter.
     * @example
     * // Update or create a BuildingCharacter
     * const buildingCharacter = await prisma.buildingCharacter.upsert({
     *   create: {
     *     // ... data to create a BuildingCharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildingCharacter we want to update
     *   }
     * })
    **/
    upsert<T extends BuildingCharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingCharacterUpsertArgs<ExtArgs>>
    ): Prisma__BuildingCharacterClient<$Result.GetResult<Prisma.$BuildingCharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BuildingCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCharacterCountArgs} args - Arguments to filter BuildingCharacters to count.
     * @example
     * // Count the number of BuildingCharacters
     * const count = await prisma.buildingCharacter.count({
     *   where: {
     *     // ... the filter for the BuildingCharacters we want to count
     *   }
     * })
    **/
    count<T extends BuildingCharacterCountArgs>(
      args?: Subset<T, BuildingCharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildingCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingCharacterAggregateArgs>(args: Subset<T, BuildingCharacterAggregateArgs>): Prisma.PrismaPromise<GetBuildingCharacterAggregateType<T>>

    /**
     * Group by BuildingCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingCharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingCharacterGroupByArgs['orderBy'] }
        : { orderBy?: BuildingCharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingCharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildingCharacter model
   */
  readonly fields: BuildingCharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildingCharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingCharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    BuildingCondition<T extends BuildingCharacter$BuildingConditionArgs<ExtArgs> = {}>(args?: Subset<T, BuildingCharacter$BuildingConditionArgs<ExtArgs>>): Prisma__BuildingConditionClient<$Result.GetResult<Prisma.$BuildingConditionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    BuildingSeria<T extends BuildingCharacter$BuildingSeriaArgs<ExtArgs> = {}>(args?: Subset<T, BuildingCharacter$BuildingSeriaArgs<ExtArgs>>): Prisma__BuildingSeriaClient<$Result.GetResult<Prisma.$BuildingSeriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    WallMaterial<T extends BuildingCharacter$WallMaterialArgs<ExtArgs> = {}>(args?: Subset<T, BuildingCharacter$WallMaterialArgs<ExtArgs>>): Prisma__WallMaterialClient<$Result.GetResult<Prisma.$WallMaterialPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Overlaps<T extends BuildingCharacter$OverlapsArgs<ExtArgs> = {}>(args?: Subset<T, BuildingCharacter$OverlapsArgs<ExtArgs>>): Prisma__OverlapsClient<$Result.GetResult<Prisma.$OverlapsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    WaterSupply<T extends BuildingCharacter$WaterSupplyArgs<ExtArgs> = {}>(args?: Subset<T, BuildingCharacter$WaterSupplyArgs<ExtArgs>>): Prisma__WaterSupplyClient<$Result.GetResult<Prisma.$WaterSupplyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    HeatingSystem<T extends BuildingCharacter$HeatingSystemArgs<ExtArgs> = {}>(args?: Subset<T, BuildingCharacter$HeatingSystemArgs<ExtArgs>>): Prisma__HeatingSystemClient<$Result.GetResult<Prisma.$HeatingSystemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Parking<T extends BuildingCharacter$ParkingArgs<ExtArgs> = {}>(args?: Subset<T, BuildingCharacter$ParkingArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BuildingCharacter model
   */ 
  interface BuildingCharacterFieldRefs {
    readonly id: FieldRef<"BuildingCharacter", 'Int'>
    readonly buildingConditionId: FieldRef<"BuildingCharacter", 'Int'>
    readonly buildingSeriaId: FieldRef<"BuildingCharacter", 'Int'>
    readonly building_year: FieldRef<"BuildingCharacter", 'String'>
    readonly wallMaterialId: FieldRef<"BuildingCharacter", 'Int'>
    readonly overlapsId: FieldRef<"BuildingCharacter", 'Int'>
    readonly waterSupplyId: FieldRef<"BuildingCharacter", 'Int'>
    readonly heatingSystemId: FieldRef<"BuildingCharacter", 'Int'>
    readonly is_gas: FieldRef<"BuildingCharacter", 'Boolean'>
    readonly is_electric: FieldRef<"BuildingCharacter", 'Boolean'>
    readonly passenger_elevators_count: FieldRef<"BuildingCharacter", 'Int'>
    readonly freight_elevators_count: FieldRef<"BuildingCharacter", 'Int'>
    readonly is_building_security: FieldRef<"BuildingCharacter", 'Boolean'>
    readonly parkingId: FieldRef<"BuildingCharacter", 'Int'>
    readonly is_demolition_planned: FieldRef<"BuildingCharacter", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BuildingCharacter findUnique
   */
  export type BuildingCharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCharacter to fetch.
     */
    where: BuildingCharacterWhereUniqueInput
  }

  /**
   * BuildingCharacter findUniqueOrThrow
   */
  export type BuildingCharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCharacter to fetch.
     */
    where: BuildingCharacterWhereUniqueInput
  }

  /**
   * BuildingCharacter findFirst
   */
  export type BuildingCharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCharacter to fetch.
     */
    where?: BuildingCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingCharacters to fetch.
     */
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildingCharacters.
     */
    cursor?: BuildingCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildingCharacters.
     */
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * BuildingCharacter findFirstOrThrow
   */
  export type BuildingCharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCharacter to fetch.
     */
    where?: BuildingCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingCharacters to fetch.
     */
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildingCharacters.
     */
    cursor?: BuildingCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildingCharacters.
     */
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * BuildingCharacter findMany
   */
  export type BuildingCharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * Filter, which BuildingCharacters to fetch.
     */
    where?: BuildingCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildingCharacters to fetch.
     */
    orderBy?: BuildingCharacterOrderByWithRelationInput | BuildingCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildingCharacters.
     */
    cursor?: BuildingCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildingCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildingCharacters.
     */
    skip?: number
    distinct?: BuildingCharacterScalarFieldEnum | BuildingCharacterScalarFieldEnum[]
  }

  /**
   * BuildingCharacter create
   */
  export type BuildingCharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildingCharacter.
     */
    data: XOR<BuildingCharacterCreateInput, BuildingCharacterUncheckedCreateInput>
  }

  /**
   * BuildingCharacter createMany
   */
  export type BuildingCharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildingCharacters.
     */
    data: BuildingCharacterCreateManyInput | BuildingCharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuildingCharacter update
   */
  export type BuildingCharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildingCharacter.
     */
    data: XOR<BuildingCharacterUpdateInput, BuildingCharacterUncheckedUpdateInput>
    /**
     * Choose, which BuildingCharacter to update.
     */
    where: BuildingCharacterWhereUniqueInput
  }

  /**
   * BuildingCharacter updateMany
   */
  export type BuildingCharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildingCharacters.
     */
    data: XOR<BuildingCharacterUpdateManyMutationInput, BuildingCharacterUncheckedUpdateManyInput>
    /**
     * Filter which BuildingCharacters to update
     */
    where?: BuildingCharacterWhereInput
  }

  /**
   * BuildingCharacter upsert
   */
  export type BuildingCharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildingCharacter to update in case it exists.
     */
    where: BuildingCharacterWhereUniqueInput
    /**
     * In case the BuildingCharacter found by the `where` argument doesn't exist, create a new BuildingCharacter with this data.
     */
    create: XOR<BuildingCharacterCreateInput, BuildingCharacterUncheckedCreateInput>
    /**
     * In case the BuildingCharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingCharacterUpdateInput, BuildingCharacterUncheckedUpdateInput>
  }

  /**
   * BuildingCharacter delete
   */
  export type BuildingCharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
    /**
     * Filter which BuildingCharacter to delete.
     */
    where: BuildingCharacterWhereUniqueInput
  }

  /**
   * BuildingCharacter deleteMany
   */
  export type BuildingCharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildingCharacters to delete
     */
    where?: BuildingCharacterWhereInput
  }

  /**
   * BuildingCharacter.BuildingCondition
   */
  export type BuildingCharacter$BuildingConditionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCondition
     */
    select?: BuildingConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingConditionInclude<ExtArgs> | null
    where?: BuildingConditionWhereInput
  }

  /**
   * BuildingCharacter.BuildingSeria
   */
  export type BuildingCharacter$BuildingSeriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingSeria
     */
    select?: BuildingSeriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingSeriaInclude<ExtArgs> | null
    where?: BuildingSeriaWhereInput
  }

  /**
   * BuildingCharacter.WallMaterial
   */
  export type BuildingCharacter$WallMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WallMaterial
     */
    select?: WallMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WallMaterialInclude<ExtArgs> | null
    where?: WallMaterialWhereInput
  }

  /**
   * BuildingCharacter.Overlaps
   */
  export type BuildingCharacter$OverlapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overlaps
     */
    select?: OverlapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverlapsInclude<ExtArgs> | null
    where?: OverlapsWhereInput
  }

  /**
   * BuildingCharacter.WaterSupply
   */
  export type BuildingCharacter$WaterSupplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaterSupply
     */
    select?: WaterSupplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaterSupplyInclude<ExtArgs> | null
    where?: WaterSupplyWhereInput
  }

  /**
   * BuildingCharacter.HeatingSystem
   */
  export type BuildingCharacter$HeatingSystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeatingSystem
     */
    select?: HeatingSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeatingSystemInclude<ExtArgs> | null
    where?: HeatingSystemWhereInput
  }

  /**
   * BuildingCharacter.Parking
   */
  export type BuildingCharacter$ParkingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    where?: ParkingWhereInput
  }

  /**
   * BuildingCharacter without action
   */
  export type BuildingCharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCharacter
     */
    select?: BuildingCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingCharacterInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RealtorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    reg_date: 'reg_date',
    deactivate_date: 'deactivate_date',
    photo: 'photo',
    login: 'login',
    password: 'password'
  };

  export type RealtorScalarFieldEnum = (typeof RealtorScalarFieldEnum)[keyof typeof RealtorScalarFieldEnum]


  export const ObjectTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ObjectTypeScalarFieldEnum = (typeof ObjectTypeScalarFieldEnum)[keyof typeof ObjectTypeScalarFieldEnum]


  export const ResidenceTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    objectTypeId: 'objectTypeId'
  };

  export type ResidenceTypeScalarFieldEnum = (typeof ResidenceTypeScalarFieldEnum)[keyof typeof ResidenceTypeScalarFieldEnum]


  export const ObjectCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ObjectCategoryScalarFieldEnum = (typeof ObjectCategoryScalarFieldEnum)[keyof typeof ObjectCategoryScalarFieldEnum]


  export const ObjectStatusScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ObjectStatusScalarFieldEnum = (typeof ObjectStatusScalarFieldEnum)[keyof typeof ObjectStatusScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rate: 'rate'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const RenovationScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RenovationScalarFieldEnum = (typeof RenovationScalarFieldEnum)[keyof typeof RenovationScalarFieldEnum]


  export const WindowSideScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WindowSideScalarFieldEnum = (typeof WindowSideScalarFieldEnum)[keyof typeof WindowSideScalarFieldEnum]


  export const RoomTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoomTypeScalarFieldEnum = (typeof RoomTypeScalarFieldEnum)[keyof typeof RoomTypeScalarFieldEnum]


  export const ObjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    realtorId: 'realtorId',
    objectTypeId: 'objectTypeId',
    residenceTypeId: 'residenceTypeId',
    objectCategoryId: 'objectCategoryId',
    objectStatusId: 'objectStatusId',
    is_studio: 'is_studio',
    floor: 'floor',
    floors_in_building: 'floors_in_building',
    total_area: 'total_area',
    live_area: 'live_area',
    kitchen_area: 'kitchen_area',
    rooms_area: 'rooms_area',
    price: 'price',
    currencyId: 'currencyId',
    price_per_square: 'price_per_square',
    price_type: 'price_type',
    renovationId: 'renovationId',
    windowSideId: 'windowSideId',
    roomTypeId: 'roomTypeId',
    is_apartment: 'is_apartment',
    is_luxury: 'is_luxury',
    ceiling_height: 'ceiling_height',
    combined_bath_count: 'combined_bath_count',
    separate_bath_count: 'separate_bath_count',
    loggia_count: 'loggia_count',
    loggia_description: 'loggia_description',
    balcony_count: 'balcony_count',
    balcony_description: 'balcony_description',
    general_description: 'general_description',
    cadastral_number: 'cadastral_number',
    document: 'document',
    layout: 'layout',
    fotos: 'fotos',
    online_show: 'online_show',
    video: 'video'
  };

  export type ObjectScalarFieldEnum = (typeof ObjectScalarFieldEnum)[keyof typeof ObjectScalarFieldEnum]


  export const OwnerShipScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type OwnerShipScalarFieldEnum = (typeof OwnerShipScalarFieldEnum)[keyof typeof OwnerShipScalarFieldEnum]


  export const ReasonDeletingScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ReasonDeletingScalarFieldEnum = (typeof ReasonDeletingScalarFieldEnum)[keyof typeof ReasonDeletingScalarFieldEnum]


  export const OwnerCooperationScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type OwnerCooperationScalarFieldEnum = (typeof OwnerCooperationScalarFieldEnum)[keyof typeof OwnerCooperationScalarFieldEnum]


  export const RelationshipTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RelationshipTypeScalarFieldEnum = (typeof RelationshipTypeScalarFieldEnum)[keyof typeof RelationshipTypeScalarFieldEnum]


  export const OwnerRelationScalarFieldEnum: {
    id: 'id',
    ownerShipId: 'ownerShipId',
    reasonDeletingId: 'reasonDeletingId',
    ownerCooperationId: 'ownerCooperationId',
    relationshipTypeId: 'relationshipTypeId',
    commission_amount: 'commission_amount',
    commission_comment: 'commission_comment',
    deposit_amount: 'deposit_amount',
    deposit_paid: 'deposit_paid',
    owner_price_ideal: 'owner_price_ideal',
    owner_price_real: 'owner_price_real',
    owner_price_minimal: 'owner_price_minimal'
  };

  export type OwnerRelationScalarFieldEnum = (typeof OwnerRelationScalarFieldEnum)[keyof typeof OwnerRelationScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const DistrictScalarFieldEnum: {
    id: 'id',
    name: 'name',
    regionId: 'regionId'
  };

  export type DistrictScalarFieldEnum = (typeof DistrictScalarFieldEnum)[keyof typeof DistrictScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const MahallaScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type MahallaScalarFieldEnum = (typeof MahallaScalarFieldEnum)[keyof typeof MahallaScalarFieldEnum]


  export const StreetScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type StreetScalarFieldEnum = (typeof StreetScalarFieldEnum)[keyof typeof StreetScalarFieldEnum]


  export const MetroScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type MetroScalarFieldEnum = (typeof MetroScalarFieldEnum)[keyof typeof MetroScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    regionId: 'regionId',
    districtId: 'districtId',
    areaId: 'areaId',
    mahallaId: 'mahallaId',
    streetId: 'streetId',
    house_number: 'house_number',
    apartment_number: 'apartment_number',
    location: 'location',
    landmark: 'landmark',
    metroId: 'metroId',
    location_description: 'location_description'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const BuildingConditionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type BuildingConditionScalarFieldEnum = (typeof BuildingConditionScalarFieldEnum)[keyof typeof BuildingConditionScalarFieldEnum]


  export const BuildingSeriaScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type BuildingSeriaScalarFieldEnum = (typeof BuildingSeriaScalarFieldEnum)[keyof typeof BuildingSeriaScalarFieldEnum]


  export const WallMaterialScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WallMaterialScalarFieldEnum = (typeof WallMaterialScalarFieldEnum)[keyof typeof WallMaterialScalarFieldEnum]


  export const OverlapsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type OverlapsScalarFieldEnum = (typeof OverlapsScalarFieldEnum)[keyof typeof OverlapsScalarFieldEnum]


  export const WaterSupplyScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WaterSupplyScalarFieldEnum = (typeof WaterSupplyScalarFieldEnum)[keyof typeof WaterSupplyScalarFieldEnum]


  export const HeatingSystemScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type HeatingSystemScalarFieldEnum = (typeof HeatingSystemScalarFieldEnum)[keyof typeof HeatingSystemScalarFieldEnum]


  export const ParkingScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ParkingScalarFieldEnum = (typeof ParkingScalarFieldEnum)[keyof typeof ParkingScalarFieldEnum]


  export const BuildingCharacterScalarFieldEnum: {
    id: 'id',
    buildingConditionId: 'buildingConditionId',
    buildingSeriaId: 'buildingSeriaId',
    building_year: 'building_year',
    wallMaterialId: 'wallMaterialId',
    overlapsId: 'overlapsId',
    waterSupplyId: 'waterSupplyId',
    heatingSystemId: 'heatingSystemId',
    is_gas: 'is_gas',
    is_electric: 'is_electric',
    passenger_elevators_count: 'passenger_elevators_count',
    freight_elevators_count: 'freight_elevators_count',
    is_building_security: 'is_building_security',
    parkingId: 'parkingId',
    is_demolition_planned: 'is_demolition_planned'
  };

  export type BuildingCharacterScalarFieldEnum = (typeof BuildingCharacterScalarFieldEnum)[keyof typeof BuildingCharacterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type RealtorWhereInput = {
    AND?: RealtorWhereInput | RealtorWhereInput[]
    OR?: RealtorWhereInput[]
    NOT?: RealtorWhereInput | RealtorWhereInput[]
    id?: IntFilter<"Realtor"> | number
    name?: StringFilter<"Realtor"> | string
    is_active?: BoolFilter<"Realtor"> | boolean
    reg_date?: DateTimeFilter<"Realtor"> | Date | string
    deactivate_date?: DateTimeFilter<"Realtor"> | Date | string
    photo?: StringFilter<"Realtor"> | string
    login?: StringFilter<"Realtor"> | string
    password?: StringFilter<"Realtor"> | string
    object?: ObjectListRelationFilter
  }

  export type RealtorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    reg_date?: SortOrder
    deactivate_date?: SortOrder
    photo?: SortOrder
    login?: SortOrder
    password?: SortOrder
    object?: ObjectOrderByRelationAggregateInput
  }

  export type RealtorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    login?: string
    AND?: RealtorWhereInput | RealtorWhereInput[]
    OR?: RealtorWhereInput[]
    NOT?: RealtorWhereInput | RealtorWhereInput[]
    name?: StringFilter<"Realtor"> | string
    is_active?: BoolFilter<"Realtor"> | boolean
    reg_date?: DateTimeFilter<"Realtor"> | Date | string
    deactivate_date?: DateTimeFilter<"Realtor"> | Date | string
    photo?: StringFilter<"Realtor"> | string
    password?: StringFilter<"Realtor"> | string
    object?: ObjectListRelationFilter
  }, "id" | "login">

  export type RealtorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    reg_date?: SortOrder
    deactivate_date?: SortOrder
    photo?: SortOrder
    login?: SortOrder
    password?: SortOrder
    _count?: RealtorCountOrderByAggregateInput
    _avg?: RealtorAvgOrderByAggregateInput
    _max?: RealtorMaxOrderByAggregateInput
    _min?: RealtorMinOrderByAggregateInput
    _sum?: RealtorSumOrderByAggregateInput
  }

  export type RealtorScalarWhereWithAggregatesInput = {
    AND?: RealtorScalarWhereWithAggregatesInput | RealtorScalarWhereWithAggregatesInput[]
    OR?: RealtorScalarWhereWithAggregatesInput[]
    NOT?: RealtorScalarWhereWithAggregatesInput | RealtorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Realtor"> | number
    name?: StringWithAggregatesFilter<"Realtor"> | string
    is_active?: BoolWithAggregatesFilter<"Realtor"> | boolean
    reg_date?: DateTimeWithAggregatesFilter<"Realtor"> | Date | string
    deactivate_date?: DateTimeWithAggregatesFilter<"Realtor"> | Date | string
    photo?: StringWithAggregatesFilter<"Realtor"> | string
    login?: StringWithAggregatesFilter<"Realtor"> | string
    password?: StringWithAggregatesFilter<"Realtor"> | string
  }

  export type ObjectTypeWhereInput = {
    AND?: ObjectTypeWhereInput | ObjectTypeWhereInput[]
    OR?: ObjectTypeWhereInput[]
    NOT?: ObjectTypeWhereInput | ObjectTypeWhereInput[]
    id?: IntFilter<"ObjectType"> | number
    name?: StringFilter<"ObjectType"> | string
    object?: ObjectListRelationFilter
    residenceType?: ResidenceTypeListRelationFilter
  }

  export type ObjectTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    object?: ObjectOrderByRelationAggregateInput
    residenceType?: ResidenceTypeOrderByRelationAggregateInput
  }

  export type ObjectTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ObjectTypeWhereInput | ObjectTypeWhereInput[]
    OR?: ObjectTypeWhereInput[]
    NOT?: ObjectTypeWhereInput | ObjectTypeWhereInput[]
    name?: StringFilter<"ObjectType"> | string
    object?: ObjectListRelationFilter
    residenceType?: ResidenceTypeListRelationFilter
  }, "id">

  export type ObjectTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ObjectTypeCountOrderByAggregateInput
    _avg?: ObjectTypeAvgOrderByAggregateInput
    _max?: ObjectTypeMaxOrderByAggregateInput
    _min?: ObjectTypeMinOrderByAggregateInput
    _sum?: ObjectTypeSumOrderByAggregateInput
  }

  export type ObjectTypeScalarWhereWithAggregatesInput = {
    AND?: ObjectTypeScalarWhereWithAggregatesInput | ObjectTypeScalarWhereWithAggregatesInput[]
    OR?: ObjectTypeScalarWhereWithAggregatesInput[]
    NOT?: ObjectTypeScalarWhereWithAggregatesInput | ObjectTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ObjectType"> | number
    name?: StringWithAggregatesFilter<"ObjectType"> | string
  }

  export type ResidenceTypeWhereInput = {
    AND?: ResidenceTypeWhereInput | ResidenceTypeWhereInput[]
    OR?: ResidenceTypeWhereInput[]
    NOT?: ResidenceTypeWhereInput | ResidenceTypeWhereInput[]
    id?: IntFilter<"ResidenceType"> | number
    name?: StringFilter<"ResidenceType"> | string
    objectTypeId?: IntNullableFilter<"ResidenceType"> | number | null
    object?: ObjectListRelationFilter
    ObjectType?: XOR<ObjectTypeNullableRelationFilter, ObjectTypeWhereInput> | null
  }

  export type ResidenceTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    objectTypeId?: SortOrderInput | SortOrder
    object?: ObjectOrderByRelationAggregateInput
    ObjectType?: ObjectTypeOrderByWithRelationInput
  }

  export type ResidenceTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResidenceTypeWhereInput | ResidenceTypeWhereInput[]
    OR?: ResidenceTypeWhereInput[]
    NOT?: ResidenceTypeWhereInput | ResidenceTypeWhereInput[]
    name?: StringFilter<"ResidenceType"> | string
    objectTypeId?: IntNullableFilter<"ResidenceType"> | number | null
    object?: ObjectListRelationFilter
    ObjectType?: XOR<ObjectTypeNullableRelationFilter, ObjectTypeWhereInput> | null
  }, "id">

  export type ResidenceTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    objectTypeId?: SortOrderInput | SortOrder
    _count?: ResidenceTypeCountOrderByAggregateInput
    _avg?: ResidenceTypeAvgOrderByAggregateInput
    _max?: ResidenceTypeMaxOrderByAggregateInput
    _min?: ResidenceTypeMinOrderByAggregateInput
    _sum?: ResidenceTypeSumOrderByAggregateInput
  }

  export type ResidenceTypeScalarWhereWithAggregatesInput = {
    AND?: ResidenceTypeScalarWhereWithAggregatesInput | ResidenceTypeScalarWhereWithAggregatesInput[]
    OR?: ResidenceTypeScalarWhereWithAggregatesInput[]
    NOT?: ResidenceTypeScalarWhereWithAggregatesInput | ResidenceTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ResidenceType"> | number
    name?: StringWithAggregatesFilter<"ResidenceType"> | string
    objectTypeId?: IntNullableWithAggregatesFilter<"ResidenceType"> | number | null
  }

  export type ObjectCategoryWhereInput = {
    AND?: ObjectCategoryWhereInput | ObjectCategoryWhereInput[]
    OR?: ObjectCategoryWhereInput[]
    NOT?: ObjectCategoryWhereInput | ObjectCategoryWhereInput[]
    id?: IntFilter<"ObjectCategory"> | number
    name?: StringFilter<"ObjectCategory"> | string
    object?: ObjectListRelationFilter
  }

  export type ObjectCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    object?: ObjectOrderByRelationAggregateInput
  }

  export type ObjectCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ObjectCategoryWhereInput | ObjectCategoryWhereInput[]
    OR?: ObjectCategoryWhereInput[]
    NOT?: ObjectCategoryWhereInput | ObjectCategoryWhereInput[]
    name?: StringFilter<"ObjectCategory"> | string
    object?: ObjectListRelationFilter
  }, "id">

  export type ObjectCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ObjectCategoryCountOrderByAggregateInput
    _avg?: ObjectCategoryAvgOrderByAggregateInput
    _max?: ObjectCategoryMaxOrderByAggregateInput
    _min?: ObjectCategoryMinOrderByAggregateInput
    _sum?: ObjectCategorySumOrderByAggregateInput
  }

  export type ObjectCategoryScalarWhereWithAggregatesInput = {
    AND?: ObjectCategoryScalarWhereWithAggregatesInput | ObjectCategoryScalarWhereWithAggregatesInput[]
    OR?: ObjectCategoryScalarWhereWithAggregatesInput[]
    NOT?: ObjectCategoryScalarWhereWithAggregatesInput | ObjectCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ObjectCategory"> | number
    name?: StringWithAggregatesFilter<"ObjectCategory"> | string
  }

  export type ObjectStatusWhereInput = {
    AND?: ObjectStatusWhereInput | ObjectStatusWhereInput[]
    OR?: ObjectStatusWhereInput[]
    NOT?: ObjectStatusWhereInput | ObjectStatusWhereInput[]
    id?: IntFilter<"ObjectStatus"> | number
    name?: StringFilter<"ObjectStatus"> | string
    object?: ObjectListRelationFilter
  }

  export type ObjectStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    object?: ObjectOrderByRelationAggregateInput
  }

  export type ObjectStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ObjectStatusWhereInput | ObjectStatusWhereInput[]
    OR?: ObjectStatusWhereInput[]
    NOT?: ObjectStatusWhereInput | ObjectStatusWhereInput[]
    name?: StringFilter<"ObjectStatus"> | string
    object?: ObjectListRelationFilter
  }, "id">

  export type ObjectStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ObjectStatusCountOrderByAggregateInput
    _avg?: ObjectStatusAvgOrderByAggregateInput
    _max?: ObjectStatusMaxOrderByAggregateInput
    _min?: ObjectStatusMinOrderByAggregateInput
    _sum?: ObjectStatusSumOrderByAggregateInput
  }

  export type ObjectStatusScalarWhereWithAggregatesInput = {
    AND?: ObjectStatusScalarWhereWithAggregatesInput | ObjectStatusScalarWhereWithAggregatesInput[]
    OR?: ObjectStatusScalarWhereWithAggregatesInput[]
    NOT?: ObjectStatusScalarWhereWithAggregatesInput | ObjectStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ObjectStatus"> | number
    name?: StringWithAggregatesFilter<"ObjectStatus"> | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: IntFilter<"Currency"> | number
    name?: StringFilter<"Currency"> | string
    rate?: StringFilter<"Currency"> | string
    object?: ObjectListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    object?: ObjectOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    name?: StringFilter<"Currency"> | string
    rate?: StringFilter<"Currency"> | string
    object?: ObjectListRelationFilter
  }, "id">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Currency"> | number
    name?: StringWithAggregatesFilter<"Currency"> | string
    rate?: StringWithAggregatesFilter<"Currency"> | string
  }

  export type RenovationWhereInput = {
    AND?: RenovationWhereInput | RenovationWhereInput[]
    OR?: RenovationWhereInput[]
    NOT?: RenovationWhereInput | RenovationWhereInput[]
    id?: IntFilter<"Renovation"> | number
    name?: StringFilter<"Renovation"> | string
    object?: ObjectListRelationFilter
  }

  export type RenovationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    object?: ObjectOrderByRelationAggregateInput
  }

  export type RenovationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RenovationWhereInput | RenovationWhereInput[]
    OR?: RenovationWhereInput[]
    NOT?: RenovationWhereInput | RenovationWhereInput[]
    name?: StringFilter<"Renovation"> | string
    object?: ObjectListRelationFilter
  }, "id">

  export type RenovationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RenovationCountOrderByAggregateInput
    _avg?: RenovationAvgOrderByAggregateInput
    _max?: RenovationMaxOrderByAggregateInput
    _min?: RenovationMinOrderByAggregateInput
    _sum?: RenovationSumOrderByAggregateInput
  }

  export type RenovationScalarWhereWithAggregatesInput = {
    AND?: RenovationScalarWhereWithAggregatesInput | RenovationScalarWhereWithAggregatesInput[]
    OR?: RenovationScalarWhereWithAggregatesInput[]
    NOT?: RenovationScalarWhereWithAggregatesInput | RenovationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Renovation"> | number
    name?: StringWithAggregatesFilter<"Renovation"> | string
  }

  export type WindowSideWhereInput = {
    AND?: WindowSideWhereInput | WindowSideWhereInput[]
    OR?: WindowSideWhereInput[]
    NOT?: WindowSideWhereInput | WindowSideWhereInput[]
    id?: IntFilter<"WindowSide"> | number
    name?: StringFilter<"WindowSide"> | string
    object?: ObjectListRelationFilter
  }

  export type WindowSideOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    object?: ObjectOrderByRelationAggregateInput
  }

  export type WindowSideWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WindowSideWhereInput | WindowSideWhereInput[]
    OR?: WindowSideWhereInput[]
    NOT?: WindowSideWhereInput | WindowSideWhereInput[]
    name?: StringFilter<"WindowSide"> | string
    object?: ObjectListRelationFilter
  }, "id">

  export type WindowSideOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: WindowSideCountOrderByAggregateInput
    _avg?: WindowSideAvgOrderByAggregateInput
    _max?: WindowSideMaxOrderByAggregateInput
    _min?: WindowSideMinOrderByAggregateInput
    _sum?: WindowSideSumOrderByAggregateInput
  }

  export type WindowSideScalarWhereWithAggregatesInput = {
    AND?: WindowSideScalarWhereWithAggregatesInput | WindowSideScalarWhereWithAggregatesInput[]
    OR?: WindowSideScalarWhereWithAggregatesInput[]
    NOT?: WindowSideScalarWhereWithAggregatesInput | WindowSideScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WindowSide"> | number
    name?: StringWithAggregatesFilter<"WindowSide"> | string
  }

  export type RoomTypeWhereInput = {
    AND?: RoomTypeWhereInput | RoomTypeWhereInput[]
    OR?: RoomTypeWhereInput[]
    NOT?: RoomTypeWhereInput | RoomTypeWhereInput[]
    id?: IntFilter<"RoomType"> | number
    name?: StringFilter<"RoomType"> | string
    object?: ObjectListRelationFilter
  }

  export type RoomTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    object?: ObjectOrderByRelationAggregateInput
  }

  export type RoomTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomTypeWhereInput | RoomTypeWhereInput[]
    OR?: RoomTypeWhereInput[]
    NOT?: RoomTypeWhereInput | RoomTypeWhereInput[]
    name?: StringFilter<"RoomType"> | string
    object?: ObjectListRelationFilter
  }, "id">

  export type RoomTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoomTypeCountOrderByAggregateInput
    _avg?: RoomTypeAvgOrderByAggregateInput
    _max?: RoomTypeMaxOrderByAggregateInput
    _min?: RoomTypeMinOrderByAggregateInput
    _sum?: RoomTypeSumOrderByAggregateInput
  }

  export type RoomTypeScalarWhereWithAggregatesInput = {
    AND?: RoomTypeScalarWhereWithAggregatesInput | RoomTypeScalarWhereWithAggregatesInput[]
    OR?: RoomTypeScalarWhereWithAggregatesInput[]
    NOT?: RoomTypeScalarWhereWithAggregatesInput | RoomTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomType"> | number
    name?: StringWithAggregatesFilter<"RoomType"> | string
  }

  export type ObjectWhereInput = {
    AND?: ObjectWhereInput | ObjectWhereInput[]
    OR?: ObjectWhereInput[]
    NOT?: ObjectWhereInput | ObjectWhereInput[]
    id?: IntFilter<"Object"> | number
    name?: StringFilter<"Object"> | string
    realtorId?: IntNullableFilter<"Object"> | number | null
    objectTypeId?: IntNullableFilter<"Object"> | number | null
    residenceTypeId?: IntNullableFilter<"Object"> | number | null
    objectCategoryId?: IntNullableFilter<"Object"> | number | null
    objectStatusId?: IntNullableFilter<"Object"> | number | null
    is_studio?: BoolFilter<"Object"> | boolean
    floor?: IntFilter<"Object"> | number
    floors_in_building?: IntFilter<"Object"> | number
    total_area?: FloatFilter<"Object"> | number
    live_area?: FloatFilter<"Object"> | number
    kitchen_area?: FloatFilter<"Object"> | number
    rooms_area?: FloatFilter<"Object"> | number
    price?: FloatFilter<"Object"> | number
    currencyId?: IntNullableFilter<"Object"> | number | null
    price_per_square?: FloatFilter<"Object"> | number
    price_type?: FloatFilter<"Object"> | number
    renovationId?: IntNullableFilter<"Object"> | number | null
    windowSideId?: IntNullableFilter<"Object"> | number | null
    roomTypeId?: IntNullableFilter<"Object"> | number | null
    is_apartment?: BoolFilter<"Object"> | boolean
    is_luxury?: BoolFilter<"Object"> | boolean
    ceiling_height?: FloatFilter<"Object"> | number
    combined_bath_count?: IntFilter<"Object"> | number
    separate_bath_count?: IntFilter<"Object"> | number
    loggia_count?: IntFilter<"Object"> | number
    loggia_description?: StringFilter<"Object"> | string
    balcony_count?: IntFilter<"Object"> | number
    balcony_description?: StringFilter<"Object"> | string
    general_description?: StringFilter<"Object"> | string
    cadastral_number?: IntFilter<"Object"> | number
    document?: StringFilter<"Object"> | string
    layout?: StringFilter<"Object"> | string
    fotos?: StringFilter<"Object"> | string
    online_show?: BoolFilter<"Object"> | boolean
    video?: StringFilter<"Object"> | string
    Realtor?: XOR<RealtorNullableRelationFilter, RealtorWhereInput> | null
    ObjectType?: XOR<ObjectTypeNullableRelationFilter, ObjectTypeWhereInput> | null
    ResidenceType?: XOR<ResidenceTypeNullableRelationFilter, ResidenceTypeWhereInput> | null
    ObjectCategory?: XOR<ObjectCategoryNullableRelationFilter, ObjectCategoryWhereInput> | null
    ObjectStatus?: XOR<ObjectStatusNullableRelationFilter, ObjectStatusWhereInput> | null
    Currency?: XOR<CurrencyNullableRelationFilter, CurrencyWhereInput> | null
    Renovation?: XOR<RenovationNullableRelationFilter, RenovationWhereInput> | null
    WindowSide?: XOR<WindowSideNullableRelationFilter, WindowSideWhereInput> | null
    RoomType?: XOR<RoomTypeNullableRelationFilter, RoomTypeWhereInput> | null
  }

  export type ObjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    realtorId?: SortOrderInput | SortOrder
    objectTypeId?: SortOrderInput | SortOrder
    residenceTypeId?: SortOrderInput | SortOrder
    objectCategoryId?: SortOrderInput | SortOrder
    objectStatusId?: SortOrderInput | SortOrder
    is_studio?: SortOrder
    floor?: SortOrder
    floors_in_building?: SortOrder
    total_area?: SortOrder
    live_area?: SortOrder
    kitchen_area?: SortOrder
    rooms_area?: SortOrder
    price?: SortOrder
    currencyId?: SortOrderInput | SortOrder
    price_per_square?: SortOrder
    price_type?: SortOrder
    renovationId?: SortOrderInput | SortOrder
    windowSideId?: SortOrderInput | SortOrder
    roomTypeId?: SortOrderInput | SortOrder
    is_apartment?: SortOrder
    is_luxury?: SortOrder
    ceiling_height?: SortOrder
    combined_bath_count?: SortOrder
    separate_bath_count?: SortOrder
    loggia_count?: SortOrder
    loggia_description?: SortOrder
    balcony_count?: SortOrder
    balcony_description?: SortOrder
    general_description?: SortOrder
    cadastral_number?: SortOrder
    document?: SortOrder
    layout?: SortOrder
    fotos?: SortOrder
    online_show?: SortOrder
    video?: SortOrder
    Realtor?: RealtorOrderByWithRelationInput
    ObjectType?: ObjectTypeOrderByWithRelationInput
    ResidenceType?: ResidenceTypeOrderByWithRelationInput
    ObjectCategory?: ObjectCategoryOrderByWithRelationInput
    ObjectStatus?: ObjectStatusOrderByWithRelationInput
    Currency?: CurrencyOrderByWithRelationInput
    Renovation?: RenovationOrderByWithRelationInput
    WindowSide?: WindowSideOrderByWithRelationInput
    RoomType?: RoomTypeOrderByWithRelationInput
  }

  export type ObjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ObjectWhereInput | ObjectWhereInput[]
    OR?: ObjectWhereInput[]
    NOT?: ObjectWhereInput | ObjectWhereInput[]
    name?: StringFilter<"Object"> | string
    realtorId?: IntNullableFilter<"Object"> | number | null
    objectTypeId?: IntNullableFilter<"Object"> | number | null
    residenceTypeId?: IntNullableFilter<"Object"> | number | null
    objectCategoryId?: IntNullableFilter<"Object"> | number | null
    objectStatusId?: IntNullableFilter<"Object"> | number | null
    is_studio?: BoolFilter<"Object"> | boolean
    floor?: IntFilter<"Object"> | number
    floors_in_building?: IntFilter<"Object"> | number
    total_area?: FloatFilter<"Object"> | number
    live_area?: FloatFilter<"Object"> | number
    kitchen_area?: FloatFilter<"Object"> | number
    rooms_area?: FloatFilter<"Object"> | number
    price?: FloatFilter<"Object"> | number
    currencyId?: IntNullableFilter<"Object"> | number | null
    price_per_square?: FloatFilter<"Object"> | number
    price_type?: FloatFilter<"Object"> | number
    renovationId?: IntNullableFilter<"Object"> | number | null
    windowSideId?: IntNullableFilter<"Object"> | number | null
    roomTypeId?: IntNullableFilter<"Object"> | number | null
    is_apartment?: BoolFilter<"Object"> | boolean
    is_luxury?: BoolFilter<"Object"> | boolean
    ceiling_height?: FloatFilter<"Object"> | number
    combined_bath_count?: IntFilter<"Object"> | number
    separate_bath_count?: IntFilter<"Object"> | number
    loggia_count?: IntFilter<"Object"> | number
    loggia_description?: StringFilter<"Object"> | string
    balcony_count?: IntFilter<"Object"> | number
    balcony_description?: StringFilter<"Object"> | string
    general_description?: StringFilter<"Object"> | string
    cadastral_number?: IntFilter<"Object"> | number
    document?: StringFilter<"Object"> | string
    layout?: StringFilter<"Object"> | string
    fotos?: StringFilter<"Object"> | string
    online_show?: BoolFilter<"Object"> | boolean
    video?: StringFilter<"Object"> | string
    Realtor?: XOR<RealtorNullableRelationFilter, RealtorWhereInput> | null
    ObjectType?: XOR<ObjectTypeNullableRelationFilter, ObjectTypeWhereInput> | null
    ResidenceType?: XOR<ResidenceTypeNullableRelationFilter, ResidenceTypeWhereInput> | null
    ObjectCategory?: XOR<ObjectCategoryNullableRelationFilter, ObjectCategoryWhereInput> | null
    ObjectStatus?: XOR<ObjectStatusNullableRelationFilter, ObjectStatusWhereInput> | null
    Currency?: XOR<CurrencyNullableRelationFilter, CurrencyWhereInput> | null
    Renovation?: XOR<RenovationNullableRelationFilter, RenovationWhereInput> | null
    WindowSide?: XOR<WindowSideNullableRelationFilter, WindowSideWhereInput> | null
    RoomType?: XOR<RoomTypeNullableRelationFilter, RoomTypeWhereInput> | null
  }, "id">

  export type ObjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    realtorId?: SortOrderInput | SortOrder
    objectTypeId?: SortOrderInput | SortOrder
    residenceTypeId?: SortOrderInput | SortOrder
    objectCategoryId?: SortOrderInput | SortOrder
    objectStatusId?: SortOrderInput | SortOrder
    is_studio?: SortOrder
    floor?: SortOrder
    floors_in_building?: SortOrder
    total_area?: SortOrder
    live_area?: SortOrder
    kitchen_area?: SortOrder
    rooms_area?: SortOrder
    price?: SortOrder
    currencyId?: SortOrderInput | SortOrder
    price_per_square?: SortOrder
    price_type?: SortOrder
    renovationId?: SortOrderInput | SortOrder
    windowSideId?: SortOrderInput | SortOrder
    roomTypeId?: SortOrderInput | SortOrder
    is_apartment?: SortOrder
    is_luxury?: SortOrder
    ceiling_height?: SortOrder
    combined_bath_count?: SortOrder
    separate_bath_count?: SortOrder
    loggia_count?: SortOrder
    loggia_description?: SortOrder
    balcony_count?: SortOrder
    balcony_description?: SortOrder
    general_description?: SortOrder
    cadastral_number?: SortOrder
    document?: SortOrder
    layout?: SortOrder
    fotos?: SortOrder
    online_show?: SortOrder
    video?: SortOrder
    _count?: ObjectCountOrderByAggregateInput
    _avg?: ObjectAvgOrderByAggregateInput
    _max?: ObjectMaxOrderByAggregateInput
    _min?: ObjectMinOrderByAggregateInput
    _sum?: ObjectSumOrderByAggregateInput
  }

  export type ObjectScalarWhereWithAggregatesInput = {
    AND?: ObjectScalarWhereWithAggregatesInput | ObjectScalarWhereWithAggregatesInput[]
    OR?: ObjectScalarWhereWithAggregatesInput[]
    NOT?: ObjectScalarWhereWithAggregatesInput | ObjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Object"> | number
    name?: StringWithAggregatesFilter<"Object"> | string
    realtorId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    objectTypeId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    residenceTypeId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    objectCategoryId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    objectStatusId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    is_studio?: BoolWithAggregatesFilter<"Object"> | boolean
    floor?: IntWithAggregatesFilter<"Object"> | number
    floors_in_building?: IntWithAggregatesFilter<"Object"> | number
    total_area?: FloatWithAggregatesFilter<"Object"> | number
    live_area?: FloatWithAggregatesFilter<"Object"> | number
    kitchen_area?: FloatWithAggregatesFilter<"Object"> | number
    rooms_area?: FloatWithAggregatesFilter<"Object"> | number
    price?: FloatWithAggregatesFilter<"Object"> | number
    currencyId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    price_per_square?: FloatWithAggregatesFilter<"Object"> | number
    price_type?: FloatWithAggregatesFilter<"Object"> | number
    renovationId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    windowSideId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    roomTypeId?: IntNullableWithAggregatesFilter<"Object"> | number | null
    is_apartment?: BoolWithAggregatesFilter<"Object"> | boolean
    is_luxury?: BoolWithAggregatesFilter<"Object"> | boolean
    ceiling_height?: FloatWithAggregatesFilter<"Object"> | number
    combined_bath_count?: IntWithAggregatesFilter<"Object"> | number
    separate_bath_count?: IntWithAggregatesFilter<"Object"> | number
    loggia_count?: IntWithAggregatesFilter<"Object"> | number
    loggia_description?: StringWithAggregatesFilter<"Object"> | string
    balcony_count?: IntWithAggregatesFilter<"Object"> | number
    balcony_description?: StringWithAggregatesFilter<"Object"> | string
    general_description?: StringWithAggregatesFilter<"Object"> | string
    cadastral_number?: IntWithAggregatesFilter<"Object"> | number
    document?: StringWithAggregatesFilter<"Object"> | string
    layout?: StringWithAggregatesFilter<"Object"> | string
    fotos?: StringWithAggregatesFilter<"Object"> | string
    online_show?: BoolWithAggregatesFilter<"Object"> | boolean
    video?: StringWithAggregatesFilter<"Object"> | string
  }

  export type OwnerShipWhereInput = {
    AND?: OwnerShipWhereInput | OwnerShipWhereInput[]
    OR?: OwnerShipWhereInput[]
    NOT?: OwnerShipWhereInput | OwnerShipWhereInput[]
    id?: IntFilter<"OwnerShip"> | number
    name?: StringFilter<"OwnerShip"> | string
    ownerRelation?: OwnerRelationListRelationFilter
  }

  export type OwnerShipOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerRelation?: OwnerRelationOrderByRelationAggregateInput
  }

  export type OwnerShipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OwnerShipWhereInput | OwnerShipWhereInput[]
    OR?: OwnerShipWhereInput[]
    NOT?: OwnerShipWhereInput | OwnerShipWhereInput[]
    name?: StringFilter<"OwnerShip"> | string
    ownerRelation?: OwnerRelationListRelationFilter
  }, "id">

  export type OwnerShipOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: OwnerShipCountOrderByAggregateInput
    _avg?: OwnerShipAvgOrderByAggregateInput
    _max?: OwnerShipMaxOrderByAggregateInput
    _min?: OwnerShipMinOrderByAggregateInput
    _sum?: OwnerShipSumOrderByAggregateInput
  }

  export type OwnerShipScalarWhereWithAggregatesInput = {
    AND?: OwnerShipScalarWhereWithAggregatesInput | OwnerShipScalarWhereWithAggregatesInput[]
    OR?: OwnerShipScalarWhereWithAggregatesInput[]
    NOT?: OwnerShipScalarWhereWithAggregatesInput | OwnerShipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OwnerShip"> | number
    name?: StringWithAggregatesFilter<"OwnerShip"> | string
  }

  export type ReasonDeletingWhereInput = {
    AND?: ReasonDeletingWhereInput | ReasonDeletingWhereInput[]
    OR?: ReasonDeletingWhereInput[]
    NOT?: ReasonDeletingWhereInput | ReasonDeletingWhereInput[]
    id?: IntFilter<"ReasonDeleting"> | number
    name?: StringFilter<"ReasonDeleting"> | string
    ownerRelation?: OwnerRelationListRelationFilter
  }

  export type ReasonDeletingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerRelation?: OwnerRelationOrderByRelationAggregateInput
  }

  export type ReasonDeletingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReasonDeletingWhereInput | ReasonDeletingWhereInput[]
    OR?: ReasonDeletingWhereInput[]
    NOT?: ReasonDeletingWhereInput | ReasonDeletingWhereInput[]
    name?: StringFilter<"ReasonDeleting"> | string
    ownerRelation?: OwnerRelationListRelationFilter
  }, "id">

  export type ReasonDeletingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ReasonDeletingCountOrderByAggregateInput
    _avg?: ReasonDeletingAvgOrderByAggregateInput
    _max?: ReasonDeletingMaxOrderByAggregateInput
    _min?: ReasonDeletingMinOrderByAggregateInput
    _sum?: ReasonDeletingSumOrderByAggregateInput
  }

  export type ReasonDeletingScalarWhereWithAggregatesInput = {
    AND?: ReasonDeletingScalarWhereWithAggregatesInput | ReasonDeletingScalarWhereWithAggregatesInput[]
    OR?: ReasonDeletingScalarWhereWithAggregatesInput[]
    NOT?: ReasonDeletingScalarWhereWithAggregatesInput | ReasonDeletingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReasonDeleting"> | number
    name?: StringWithAggregatesFilter<"ReasonDeleting"> | string
  }

  export type OwnerCooperationWhereInput = {
    AND?: OwnerCooperationWhereInput | OwnerCooperationWhereInput[]
    OR?: OwnerCooperationWhereInput[]
    NOT?: OwnerCooperationWhereInput | OwnerCooperationWhereInput[]
    id?: IntFilter<"OwnerCooperation"> | number
    name?: StringFilter<"OwnerCooperation"> | string
    ownerRelation?: OwnerRelationListRelationFilter
  }

  export type OwnerCooperationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerRelation?: OwnerRelationOrderByRelationAggregateInput
  }

  export type OwnerCooperationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OwnerCooperationWhereInput | OwnerCooperationWhereInput[]
    OR?: OwnerCooperationWhereInput[]
    NOT?: OwnerCooperationWhereInput | OwnerCooperationWhereInput[]
    name?: StringFilter<"OwnerCooperation"> | string
    ownerRelation?: OwnerRelationListRelationFilter
  }, "id">

  export type OwnerCooperationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: OwnerCooperationCountOrderByAggregateInput
    _avg?: OwnerCooperationAvgOrderByAggregateInput
    _max?: OwnerCooperationMaxOrderByAggregateInput
    _min?: OwnerCooperationMinOrderByAggregateInput
    _sum?: OwnerCooperationSumOrderByAggregateInput
  }

  export type OwnerCooperationScalarWhereWithAggregatesInput = {
    AND?: OwnerCooperationScalarWhereWithAggregatesInput | OwnerCooperationScalarWhereWithAggregatesInput[]
    OR?: OwnerCooperationScalarWhereWithAggregatesInput[]
    NOT?: OwnerCooperationScalarWhereWithAggregatesInput | OwnerCooperationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OwnerCooperation"> | number
    name?: StringWithAggregatesFilter<"OwnerCooperation"> | string
  }

  export type RelationshipTypeWhereInput = {
    AND?: RelationshipTypeWhereInput | RelationshipTypeWhereInput[]
    OR?: RelationshipTypeWhereInput[]
    NOT?: RelationshipTypeWhereInput | RelationshipTypeWhereInput[]
    id?: IntFilter<"RelationshipType"> | number
    name?: StringFilter<"RelationshipType"> | string
    ownerRelation?: OwnerRelationListRelationFilter
  }

  export type RelationshipTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerRelation?: OwnerRelationOrderByRelationAggregateInput
  }

  export type RelationshipTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RelationshipTypeWhereInput | RelationshipTypeWhereInput[]
    OR?: RelationshipTypeWhereInput[]
    NOT?: RelationshipTypeWhereInput | RelationshipTypeWhereInput[]
    name?: StringFilter<"RelationshipType"> | string
    ownerRelation?: OwnerRelationListRelationFilter
  }, "id">

  export type RelationshipTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RelationshipTypeCountOrderByAggregateInput
    _avg?: RelationshipTypeAvgOrderByAggregateInput
    _max?: RelationshipTypeMaxOrderByAggregateInput
    _min?: RelationshipTypeMinOrderByAggregateInput
    _sum?: RelationshipTypeSumOrderByAggregateInput
  }

  export type RelationshipTypeScalarWhereWithAggregatesInput = {
    AND?: RelationshipTypeScalarWhereWithAggregatesInput | RelationshipTypeScalarWhereWithAggregatesInput[]
    OR?: RelationshipTypeScalarWhereWithAggregatesInput[]
    NOT?: RelationshipTypeScalarWhereWithAggregatesInput | RelationshipTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RelationshipType"> | number
    name?: StringWithAggregatesFilter<"RelationshipType"> | string
  }

  export type OwnerRelationWhereInput = {
    AND?: OwnerRelationWhereInput | OwnerRelationWhereInput[]
    OR?: OwnerRelationWhereInput[]
    NOT?: OwnerRelationWhereInput | OwnerRelationWhereInput[]
    id?: IntFilter<"OwnerRelation"> | number
    ownerShipId?: IntNullableFilter<"OwnerRelation"> | number | null
    reasonDeletingId?: IntNullableFilter<"OwnerRelation"> | number | null
    ownerCooperationId?: IntNullableFilter<"OwnerRelation"> | number | null
    relationshipTypeId?: IntNullableFilter<"OwnerRelation"> | number | null
    commission_amount?: FloatFilter<"OwnerRelation"> | number
    commission_comment?: StringFilter<"OwnerRelation"> | string
    deposit_amount?: FloatFilter<"OwnerRelation"> | number
    deposit_paid?: FloatFilter<"OwnerRelation"> | number
    owner_price_ideal?: FloatFilter<"OwnerRelation"> | number
    owner_price_real?: FloatFilter<"OwnerRelation"> | number
    owner_price_minimal?: FloatFilter<"OwnerRelation"> | number
    OwnerShip?: XOR<OwnerShipNullableRelationFilter, OwnerShipWhereInput> | null
    ReasonDeleting?: XOR<ReasonDeletingNullableRelationFilter, ReasonDeletingWhereInput> | null
    OwnerCooperation?: XOR<OwnerCooperationNullableRelationFilter, OwnerCooperationWhereInput> | null
    RelationshipType?: XOR<RelationshipTypeNullableRelationFilter, RelationshipTypeWhereInput> | null
  }

  export type OwnerRelationOrderByWithRelationInput = {
    id?: SortOrder
    ownerShipId?: SortOrderInput | SortOrder
    reasonDeletingId?: SortOrderInput | SortOrder
    ownerCooperationId?: SortOrderInput | SortOrder
    relationshipTypeId?: SortOrderInput | SortOrder
    commission_amount?: SortOrder
    commission_comment?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    owner_price_ideal?: SortOrder
    owner_price_real?: SortOrder
    owner_price_minimal?: SortOrder
    OwnerShip?: OwnerShipOrderByWithRelationInput
    ReasonDeleting?: ReasonDeletingOrderByWithRelationInput
    OwnerCooperation?: OwnerCooperationOrderByWithRelationInput
    RelationshipType?: RelationshipTypeOrderByWithRelationInput
  }

  export type OwnerRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OwnerRelationWhereInput | OwnerRelationWhereInput[]
    OR?: OwnerRelationWhereInput[]
    NOT?: OwnerRelationWhereInput | OwnerRelationWhereInput[]
    ownerShipId?: IntNullableFilter<"OwnerRelation"> | number | null
    reasonDeletingId?: IntNullableFilter<"OwnerRelation"> | number | null
    ownerCooperationId?: IntNullableFilter<"OwnerRelation"> | number | null
    relationshipTypeId?: IntNullableFilter<"OwnerRelation"> | number | null
    commission_amount?: FloatFilter<"OwnerRelation"> | number
    commission_comment?: StringFilter<"OwnerRelation"> | string
    deposit_amount?: FloatFilter<"OwnerRelation"> | number
    deposit_paid?: FloatFilter<"OwnerRelation"> | number
    owner_price_ideal?: FloatFilter<"OwnerRelation"> | number
    owner_price_real?: FloatFilter<"OwnerRelation"> | number
    owner_price_minimal?: FloatFilter<"OwnerRelation"> | number
    OwnerShip?: XOR<OwnerShipNullableRelationFilter, OwnerShipWhereInput> | null
    ReasonDeleting?: XOR<ReasonDeletingNullableRelationFilter, ReasonDeletingWhereInput> | null
    OwnerCooperation?: XOR<OwnerCooperationNullableRelationFilter, OwnerCooperationWhereInput> | null
    RelationshipType?: XOR<RelationshipTypeNullableRelationFilter, RelationshipTypeWhereInput> | null
  }, "id">

  export type OwnerRelationOrderByWithAggregationInput = {
    id?: SortOrder
    ownerShipId?: SortOrderInput | SortOrder
    reasonDeletingId?: SortOrderInput | SortOrder
    ownerCooperationId?: SortOrderInput | SortOrder
    relationshipTypeId?: SortOrderInput | SortOrder
    commission_amount?: SortOrder
    commission_comment?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    owner_price_ideal?: SortOrder
    owner_price_real?: SortOrder
    owner_price_minimal?: SortOrder
    _count?: OwnerRelationCountOrderByAggregateInput
    _avg?: OwnerRelationAvgOrderByAggregateInput
    _max?: OwnerRelationMaxOrderByAggregateInput
    _min?: OwnerRelationMinOrderByAggregateInput
    _sum?: OwnerRelationSumOrderByAggregateInput
  }

  export type OwnerRelationScalarWhereWithAggregatesInput = {
    AND?: OwnerRelationScalarWhereWithAggregatesInput | OwnerRelationScalarWhereWithAggregatesInput[]
    OR?: OwnerRelationScalarWhereWithAggregatesInput[]
    NOT?: OwnerRelationScalarWhereWithAggregatesInput | OwnerRelationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OwnerRelation"> | number
    ownerShipId?: IntNullableWithAggregatesFilter<"OwnerRelation"> | number | null
    reasonDeletingId?: IntNullableWithAggregatesFilter<"OwnerRelation"> | number | null
    ownerCooperationId?: IntNullableWithAggregatesFilter<"OwnerRelation"> | number | null
    relationshipTypeId?: IntNullableWithAggregatesFilter<"OwnerRelation"> | number | null
    commission_amount?: FloatWithAggregatesFilter<"OwnerRelation"> | number
    commission_comment?: StringWithAggregatesFilter<"OwnerRelation"> | string
    deposit_amount?: FloatWithAggregatesFilter<"OwnerRelation"> | number
    deposit_paid?: FloatWithAggregatesFilter<"OwnerRelation"> | number
    owner_price_ideal?: FloatWithAggregatesFilter<"OwnerRelation"> | number
    owner_price_real?: FloatWithAggregatesFilter<"OwnerRelation"> | number
    owner_price_minimal?: FloatWithAggregatesFilter<"OwnerRelation"> | number
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    name?: StringFilter<"Region"> | string
    address?: AddressListRelationFilter
    district?: DistrictListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: AddressOrderByRelationAggregateInput
    district?: DistrictOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    name?: StringFilter<"Region"> | string
    address?: AddressListRelationFilter
    district?: DistrictListRelationFilter
  }, "id">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Region"> | number
    name?: StringWithAggregatesFilter<"Region"> | string
  }

  export type DistrictWhereInput = {
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    id?: IntFilter<"District"> | number
    name?: StringFilter<"District"> | string
    regionId?: IntNullableFilter<"District"> | number | null
    address?: AddressListRelationFilter
    Region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
  }

  export type DistrictOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrderInput | SortOrder
    address?: AddressOrderByRelationAggregateInput
    Region?: RegionOrderByWithRelationInput
  }

  export type DistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    name?: StringFilter<"District"> | string
    regionId?: IntNullableFilter<"District"> | number | null
    address?: AddressListRelationFilter
    Region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
  }, "id">

  export type DistrictOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrderInput | SortOrder
    _count?: DistrictCountOrderByAggregateInput
    _avg?: DistrictAvgOrderByAggregateInput
    _max?: DistrictMaxOrderByAggregateInput
    _min?: DistrictMinOrderByAggregateInput
    _sum?: DistrictSumOrderByAggregateInput
  }

  export type DistrictScalarWhereWithAggregatesInput = {
    AND?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    OR?: DistrictScalarWhereWithAggregatesInput[]
    NOT?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"District"> | number
    name?: StringWithAggregatesFilter<"District"> | string
    regionId?: IntNullableWithAggregatesFilter<"District"> | number | null
  }

  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: IntFilter<"Area"> | number
    name?: StringFilter<"Area"> | string
    address?: AddressListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: AddressOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    name?: StringFilter<"Area"> | string
    address?: AddressListRelationFilter
  }, "id">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: AreaCountOrderByAggregateInput
    _avg?: AreaAvgOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
    _sum?: AreaSumOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Area"> | number
    name?: StringWithAggregatesFilter<"Area"> | string
  }

  export type MahallaWhereInput = {
    AND?: MahallaWhereInput | MahallaWhereInput[]
    OR?: MahallaWhereInput[]
    NOT?: MahallaWhereInput | MahallaWhereInput[]
    id?: IntFilter<"Mahalla"> | number
    name?: StringFilter<"Mahalla"> | string
    address?: AddressListRelationFilter
  }

  export type MahallaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: AddressOrderByRelationAggregateInput
  }

  export type MahallaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MahallaWhereInput | MahallaWhereInput[]
    OR?: MahallaWhereInput[]
    NOT?: MahallaWhereInput | MahallaWhereInput[]
    name?: StringFilter<"Mahalla"> | string
    address?: AddressListRelationFilter
  }, "id">

  export type MahallaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: MahallaCountOrderByAggregateInput
    _avg?: MahallaAvgOrderByAggregateInput
    _max?: MahallaMaxOrderByAggregateInput
    _min?: MahallaMinOrderByAggregateInput
    _sum?: MahallaSumOrderByAggregateInput
  }

  export type MahallaScalarWhereWithAggregatesInput = {
    AND?: MahallaScalarWhereWithAggregatesInput | MahallaScalarWhereWithAggregatesInput[]
    OR?: MahallaScalarWhereWithAggregatesInput[]
    NOT?: MahallaScalarWhereWithAggregatesInput | MahallaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mahalla"> | number
    name?: StringWithAggregatesFilter<"Mahalla"> | string
  }

  export type StreetWhereInput = {
    AND?: StreetWhereInput | StreetWhereInput[]
    OR?: StreetWhereInput[]
    NOT?: StreetWhereInput | StreetWhereInput[]
    id?: IntFilter<"Street"> | number
    name?: StringFilter<"Street"> | string
    address?: AddressListRelationFilter
  }

  export type StreetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: AddressOrderByRelationAggregateInput
  }

  export type StreetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StreetWhereInput | StreetWhereInput[]
    OR?: StreetWhereInput[]
    NOT?: StreetWhereInput | StreetWhereInput[]
    name?: StringFilter<"Street"> | string
    address?: AddressListRelationFilter
  }, "id">

  export type StreetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: StreetCountOrderByAggregateInput
    _avg?: StreetAvgOrderByAggregateInput
    _max?: StreetMaxOrderByAggregateInput
    _min?: StreetMinOrderByAggregateInput
    _sum?: StreetSumOrderByAggregateInput
  }

  export type StreetScalarWhereWithAggregatesInput = {
    AND?: StreetScalarWhereWithAggregatesInput | StreetScalarWhereWithAggregatesInput[]
    OR?: StreetScalarWhereWithAggregatesInput[]
    NOT?: StreetScalarWhereWithAggregatesInput | StreetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Street"> | number
    name?: StringWithAggregatesFilter<"Street"> | string
  }

  export type MetroWhereInput = {
    AND?: MetroWhereInput | MetroWhereInput[]
    OR?: MetroWhereInput[]
    NOT?: MetroWhereInput | MetroWhereInput[]
    id?: IntFilter<"Metro"> | number
    name?: StringFilter<"Metro"> | string
    address?: AddressListRelationFilter
  }

  export type MetroOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: AddressOrderByRelationAggregateInput
  }

  export type MetroWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MetroWhereInput | MetroWhereInput[]
    OR?: MetroWhereInput[]
    NOT?: MetroWhereInput | MetroWhereInput[]
    name?: StringFilter<"Metro"> | string
    address?: AddressListRelationFilter
  }, "id">

  export type MetroOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: MetroCountOrderByAggregateInput
    _avg?: MetroAvgOrderByAggregateInput
    _max?: MetroMaxOrderByAggregateInput
    _min?: MetroMinOrderByAggregateInput
    _sum?: MetroSumOrderByAggregateInput
  }

  export type MetroScalarWhereWithAggregatesInput = {
    AND?: MetroScalarWhereWithAggregatesInput | MetroScalarWhereWithAggregatesInput[]
    OR?: MetroScalarWhereWithAggregatesInput[]
    NOT?: MetroScalarWhereWithAggregatesInput | MetroScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Metro"> | number
    name?: StringWithAggregatesFilter<"Metro"> | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    regionId?: IntNullableFilter<"Address"> | number | null
    districtId?: IntNullableFilter<"Address"> | number | null
    areaId?: IntNullableFilter<"Address"> | number | null
    mahallaId?: IntNullableFilter<"Address"> | number | null
    streetId?: IntNullableFilter<"Address"> | number | null
    house_number?: IntFilter<"Address"> | number
    apartment_number?: IntFilter<"Address"> | number
    location?: StringFilter<"Address"> | string
    landmark?: BoolFilter<"Address"> | boolean
    metroId?: IntNullableFilter<"Address"> | number | null
    location_description?: StringFilter<"Address"> | string
    Region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    District?: XOR<DistrictNullableRelationFilter, DistrictWhereInput> | null
    Area?: XOR<AreaNullableRelationFilter, AreaWhereInput> | null
    Mahalla?: XOR<MahallaNullableRelationFilter, MahallaWhereInput> | null
    Street?: XOR<StreetNullableRelationFilter, StreetWhereInput> | null
    Metro?: XOR<MetroNullableRelationFilter, MetroWhereInput> | null
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    regionId?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    areaId?: SortOrderInput | SortOrder
    mahallaId?: SortOrderInput | SortOrder
    streetId?: SortOrderInput | SortOrder
    house_number?: SortOrder
    apartment_number?: SortOrder
    location?: SortOrder
    landmark?: SortOrder
    metroId?: SortOrderInput | SortOrder
    location_description?: SortOrder
    Region?: RegionOrderByWithRelationInput
    District?: DistrictOrderByWithRelationInput
    Area?: AreaOrderByWithRelationInput
    Mahalla?: MahallaOrderByWithRelationInput
    Street?: StreetOrderByWithRelationInput
    Metro?: MetroOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    regionId?: IntNullableFilter<"Address"> | number | null
    districtId?: IntNullableFilter<"Address"> | number | null
    areaId?: IntNullableFilter<"Address"> | number | null
    mahallaId?: IntNullableFilter<"Address"> | number | null
    streetId?: IntNullableFilter<"Address"> | number | null
    house_number?: IntFilter<"Address"> | number
    apartment_number?: IntFilter<"Address"> | number
    location?: StringFilter<"Address"> | string
    landmark?: BoolFilter<"Address"> | boolean
    metroId?: IntNullableFilter<"Address"> | number | null
    location_description?: StringFilter<"Address"> | string
    Region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
    District?: XOR<DistrictNullableRelationFilter, DistrictWhereInput> | null
    Area?: XOR<AreaNullableRelationFilter, AreaWhereInput> | null
    Mahalla?: XOR<MahallaNullableRelationFilter, MahallaWhereInput> | null
    Street?: XOR<StreetNullableRelationFilter, StreetWhereInput> | null
    Metro?: XOR<MetroNullableRelationFilter, MetroWhereInput> | null
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    regionId?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    areaId?: SortOrderInput | SortOrder
    mahallaId?: SortOrderInput | SortOrder
    streetId?: SortOrderInput | SortOrder
    house_number?: SortOrder
    apartment_number?: SortOrder
    location?: SortOrder
    landmark?: SortOrder
    metroId?: SortOrderInput | SortOrder
    location_description?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    regionId?: IntNullableWithAggregatesFilter<"Address"> | number | null
    districtId?: IntNullableWithAggregatesFilter<"Address"> | number | null
    areaId?: IntNullableWithAggregatesFilter<"Address"> | number | null
    mahallaId?: IntNullableWithAggregatesFilter<"Address"> | number | null
    streetId?: IntNullableWithAggregatesFilter<"Address"> | number | null
    house_number?: IntWithAggregatesFilter<"Address"> | number
    apartment_number?: IntWithAggregatesFilter<"Address"> | number
    location?: StringWithAggregatesFilter<"Address"> | string
    landmark?: BoolWithAggregatesFilter<"Address"> | boolean
    metroId?: IntNullableWithAggregatesFilter<"Address"> | number | null
    location_description?: StringWithAggregatesFilter<"Address"> | string
  }

  export type BuildingConditionWhereInput = {
    AND?: BuildingConditionWhereInput | BuildingConditionWhereInput[]
    OR?: BuildingConditionWhereInput[]
    NOT?: BuildingConditionWhereInput | BuildingConditionWhereInput[]
    id?: IntFilter<"BuildingCondition"> | number
    name?: StringFilter<"BuildingCondition"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }

  export type BuildingConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingCharacter?: BuildingCharacterOrderByRelationAggregateInput
  }

  export type BuildingConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuildingConditionWhereInput | BuildingConditionWhereInput[]
    OR?: BuildingConditionWhereInput[]
    NOT?: BuildingConditionWhereInput | BuildingConditionWhereInput[]
    name?: StringFilter<"BuildingCondition"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }, "id">

  export type BuildingConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: BuildingConditionCountOrderByAggregateInput
    _avg?: BuildingConditionAvgOrderByAggregateInput
    _max?: BuildingConditionMaxOrderByAggregateInput
    _min?: BuildingConditionMinOrderByAggregateInput
    _sum?: BuildingConditionSumOrderByAggregateInput
  }

  export type BuildingConditionScalarWhereWithAggregatesInput = {
    AND?: BuildingConditionScalarWhereWithAggregatesInput | BuildingConditionScalarWhereWithAggregatesInput[]
    OR?: BuildingConditionScalarWhereWithAggregatesInput[]
    NOT?: BuildingConditionScalarWhereWithAggregatesInput | BuildingConditionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuildingCondition"> | number
    name?: StringWithAggregatesFilter<"BuildingCondition"> | string
  }

  export type BuildingSeriaWhereInput = {
    AND?: BuildingSeriaWhereInput | BuildingSeriaWhereInput[]
    OR?: BuildingSeriaWhereInput[]
    NOT?: BuildingSeriaWhereInput | BuildingSeriaWhereInput[]
    id?: IntFilter<"BuildingSeria"> | number
    name?: StringFilter<"BuildingSeria"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }

  export type BuildingSeriaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingCharacter?: BuildingCharacterOrderByRelationAggregateInput
  }

  export type BuildingSeriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuildingSeriaWhereInput | BuildingSeriaWhereInput[]
    OR?: BuildingSeriaWhereInput[]
    NOT?: BuildingSeriaWhereInput | BuildingSeriaWhereInput[]
    name?: StringFilter<"BuildingSeria"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }, "id">

  export type BuildingSeriaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: BuildingSeriaCountOrderByAggregateInput
    _avg?: BuildingSeriaAvgOrderByAggregateInput
    _max?: BuildingSeriaMaxOrderByAggregateInput
    _min?: BuildingSeriaMinOrderByAggregateInput
    _sum?: BuildingSeriaSumOrderByAggregateInput
  }

  export type BuildingSeriaScalarWhereWithAggregatesInput = {
    AND?: BuildingSeriaScalarWhereWithAggregatesInput | BuildingSeriaScalarWhereWithAggregatesInput[]
    OR?: BuildingSeriaScalarWhereWithAggregatesInput[]
    NOT?: BuildingSeriaScalarWhereWithAggregatesInput | BuildingSeriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuildingSeria"> | number
    name?: StringWithAggregatesFilter<"BuildingSeria"> | string
  }

  export type WallMaterialWhereInput = {
    AND?: WallMaterialWhereInput | WallMaterialWhereInput[]
    OR?: WallMaterialWhereInput[]
    NOT?: WallMaterialWhereInput | WallMaterialWhereInput[]
    id?: IntFilter<"WallMaterial"> | number
    name?: StringFilter<"WallMaterial"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }

  export type WallMaterialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingCharacter?: BuildingCharacterOrderByRelationAggregateInput
  }

  export type WallMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WallMaterialWhereInput | WallMaterialWhereInput[]
    OR?: WallMaterialWhereInput[]
    NOT?: WallMaterialWhereInput | WallMaterialWhereInput[]
    name?: StringFilter<"WallMaterial"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }, "id">

  export type WallMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: WallMaterialCountOrderByAggregateInput
    _avg?: WallMaterialAvgOrderByAggregateInput
    _max?: WallMaterialMaxOrderByAggregateInput
    _min?: WallMaterialMinOrderByAggregateInput
    _sum?: WallMaterialSumOrderByAggregateInput
  }

  export type WallMaterialScalarWhereWithAggregatesInput = {
    AND?: WallMaterialScalarWhereWithAggregatesInput | WallMaterialScalarWhereWithAggregatesInput[]
    OR?: WallMaterialScalarWhereWithAggregatesInput[]
    NOT?: WallMaterialScalarWhereWithAggregatesInput | WallMaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WallMaterial"> | number
    name?: StringWithAggregatesFilter<"WallMaterial"> | string
  }

  export type OverlapsWhereInput = {
    AND?: OverlapsWhereInput | OverlapsWhereInput[]
    OR?: OverlapsWhereInput[]
    NOT?: OverlapsWhereInput | OverlapsWhereInput[]
    id?: IntFilter<"Overlaps"> | number
    name?: StringFilter<"Overlaps"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }

  export type OverlapsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingCharacter?: BuildingCharacterOrderByRelationAggregateInput
  }

  export type OverlapsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OverlapsWhereInput | OverlapsWhereInput[]
    OR?: OverlapsWhereInput[]
    NOT?: OverlapsWhereInput | OverlapsWhereInput[]
    name?: StringFilter<"Overlaps"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }, "id">

  export type OverlapsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: OverlapsCountOrderByAggregateInput
    _avg?: OverlapsAvgOrderByAggregateInput
    _max?: OverlapsMaxOrderByAggregateInput
    _min?: OverlapsMinOrderByAggregateInput
    _sum?: OverlapsSumOrderByAggregateInput
  }

  export type OverlapsScalarWhereWithAggregatesInput = {
    AND?: OverlapsScalarWhereWithAggregatesInput | OverlapsScalarWhereWithAggregatesInput[]
    OR?: OverlapsScalarWhereWithAggregatesInput[]
    NOT?: OverlapsScalarWhereWithAggregatesInput | OverlapsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Overlaps"> | number
    name?: StringWithAggregatesFilter<"Overlaps"> | string
  }

  export type WaterSupplyWhereInput = {
    AND?: WaterSupplyWhereInput | WaterSupplyWhereInput[]
    OR?: WaterSupplyWhereInput[]
    NOT?: WaterSupplyWhereInput | WaterSupplyWhereInput[]
    id?: IntFilter<"WaterSupply"> | number
    name?: StringFilter<"WaterSupply"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }

  export type WaterSupplyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingCharacter?: BuildingCharacterOrderByRelationAggregateInput
  }

  export type WaterSupplyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WaterSupplyWhereInput | WaterSupplyWhereInput[]
    OR?: WaterSupplyWhereInput[]
    NOT?: WaterSupplyWhereInput | WaterSupplyWhereInput[]
    name?: StringFilter<"WaterSupply"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }, "id">

  export type WaterSupplyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: WaterSupplyCountOrderByAggregateInput
    _avg?: WaterSupplyAvgOrderByAggregateInput
    _max?: WaterSupplyMaxOrderByAggregateInput
    _min?: WaterSupplyMinOrderByAggregateInput
    _sum?: WaterSupplySumOrderByAggregateInput
  }

  export type WaterSupplyScalarWhereWithAggregatesInput = {
    AND?: WaterSupplyScalarWhereWithAggregatesInput | WaterSupplyScalarWhereWithAggregatesInput[]
    OR?: WaterSupplyScalarWhereWithAggregatesInput[]
    NOT?: WaterSupplyScalarWhereWithAggregatesInput | WaterSupplyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WaterSupply"> | number
    name?: StringWithAggregatesFilter<"WaterSupply"> | string
  }

  export type HeatingSystemWhereInput = {
    AND?: HeatingSystemWhereInput | HeatingSystemWhereInput[]
    OR?: HeatingSystemWhereInput[]
    NOT?: HeatingSystemWhereInput | HeatingSystemWhereInput[]
    id?: IntFilter<"HeatingSystem"> | number
    name?: StringFilter<"HeatingSystem"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }

  export type HeatingSystemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingCharacter?: BuildingCharacterOrderByRelationAggregateInput
  }

  export type HeatingSystemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HeatingSystemWhereInput | HeatingSystemWhereInput[]
    OR?: HeatingSystemWhereInput[]
    NOT?: HeatingSystemWhereInput | HeatingSystemWhereInput[]
    name?: StringFilter<"HeatingSystem"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }, "id">

  export type HeatingSystemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: HeatingSystemCountOrderByAggregateInput
    _avg?: HeatingSystemAvgOrderByAggregateInput
    _max?: HeatingSystemMaxOrderByAggregateInput
    _min?: HeatingSystemMinOrderByAggregateInput
    _sum?: HeatingSystemSumOrderByAggregateInput
  }

  export type HeatingSystemScalarWhereWithAggregatesInput = {
    AND?: HeatingSystemScalarWhereWithAggregatesInput | HeatingSystemScalarWhereWithAggregatesInput[]
    OR?: HeatingSystemScalarWhereWithAggregatesInput[]
    NOT?: HeatingSystemScalarWhereWithAggregatesInput | HeatingSystemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HeatingSystem"> | number
    name?: StringWithAggregatesFilter<"HeatingSystem"> | string
  }

  export type ParkingWhereInput = {
    AND?: ParkingWhereInput | ParkingWhereInput[]
    OR?: ParkingWhereInput[]
    NOT?: ParkingWhereInput | ParkingWhereInput[]
    id?: IntFilter<"Parking"> | number
    name?: StringFilter<"Parking"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }

  export type ParkingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    buildingCharacter?: BuildingCharacterOrderByRelationAggregateInput
  }

  export type ParkingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParkingWhereInput | ParkingWhereInput[]
    OR?: ParkingWhereInput[]
    NOT?: ParkingWhereInput | ParkingWhereInput[]
    name?: StringFilter<"Parking"> | string
    buildingCharacter?: BuildingCharacterListRelationFilter
  }, "id">

  export type ParkingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ParkingCountOrderByAggregateInput
    _avg?: ParkingAvgOrderByAggregateInput
    _max?: ParkingMaxOrderByAggregateInput
    _min?: ParkingMinOrderByAggregateInput
    _sum?: ParkingSumOrderByAggregateInput
  }

  export type ParkingScalarWhereWithAggregatesInput = {
    AND?: ParkingScalarWhereWithAggregatesInput | ParkingScalarWhereWithAggregatesInput[]
    OR?: ParkingScalarWhereWithAggregatesInput[]
    NOT?: ParkingScalarWhereWithAggregatesInput | ParkingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parking"> | number
    name?: StringWithAggregatesFilter<"Parking"> | string
  }

  export type BuildingCharacterWhereInput = {
    AND?: BuildingCharacterWhereInput | BuildingCharacterWhereInput[]
    OR?: BuildingCharacterWhereInput[]
    NOT?: BuildingCharacterWhereInput | BuildingCharacterWhereInput[]
    id?: IntFilter<"BuildingCharacter"> | number
    buildingConditionId?: IntNullableFilter<"BuildingCharacter"> | number | null
    buildingSeriaId?: IntNullableFilter<"BuildingCharacter"> | number | null
    building_year?: StringFilter<"BuildingCharacter"> | string
    wallMaterialId?: IntNullableFilter<"BuildingCharacter"> | number | null
    overlapsId?: IntNullableFilter<"BuildingCharacter"> | number | null
    waterSupplyId?: IntNullableFilter<"BuildingCharacter"> | number | null
    heatingSystemId?: IntNullableFilter<"BuildingCharacter"> | number | null
    is_gas?: BoolFilter<"BuildingCharacter"> | boolean
    is_electric?: BoolFilter<"BuildingCharacter"> | boolean
    passenger_elevators_count?: IntFilter<"BuildingCharacter"> | number
    freight_elevators_count?: IntFilter<"BuildingCharacter"> | number
    is_building_security?: BoolFilter<"BuildingCharacter"> | boolean
    parkingId?: IntNullableFilter<"BuildingCharacter"> | number | null
    is_demolition_planned?: BoolFilter<"BuildingCharacter"> | boolean
    BuildingCondition?: XOR<BuildingConditionNullableRelationFilter, BuildingConditionWhereInput> | null
    BuildingSeria?: XOR<BuildingSeriaNullableRelationFilter, BuildingSeriaWhereInput> | null
    WallMaterial?: XOR<WallMaterialNullableRelationFilter, WallMaterialWhereInput> | null
    Overlaps?: XOR<OverlapsNullableRelationFilter, OverlapsWhereInput> | null
    WaterSupply?: XOR<WaterSupplyNullableRelationFilter, WaterSupplyWhereInput> | null
    HeatingSystem?: XOR<HeatingSystemNullableRelationFilter, HeatingSystemWhereInput> | null
    Parking?: XOR<ParkingNullableRelationFilter, ParkingWhereInput> | null
  }

  export type BuildingCharacterOrderByWithRelationInput = {
    id?: SortOrder
    buildingConditionId?: SortOrderInput | SortOrder
    buildingSeriaId?: SortOrderInput | SortOrder
    building_year?: SortOrder
    wallMaterialId?: SortOrderInput | SortOrder
    overlapsId?: SortOrderInput | SortOrder
    waterSupplyId?: SortOrderInput | SortOrder
    heatingSystemId?: SortOrderInput | SortOrder
    is_gas?: SortOrder
    is_electric?: SortOrder
    passenger_elevators_count?: SortOrder
    freight_elevators_count?: SortOrder
    is_building_security?: SortOrder
    parkingId?: SortOrderInput | SortOrder
    is_demolition_planned?: SortOrder
    BuildingCondition?: BuildingConditionOrderByWithRelationInput
    BuildingSeria?: BuildingSeriaOrderByWithRelationInput
    WallMaterial?: WallMaterialOrderByWithRelationInput
    Overlaps?: OverlapsOrderByWithRelationInput
    WaterSupply?: WaterSupplyOrderByWithRelationInput
    HeatingSystem?: HeatingSystemOrderByWithRelationInput
    Parking?: ParkingOrderByWithRelationInput
  }

  export type BuildingCharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuildingCharacterWhereInput | BuildingCharacterWhereInput[]
    OR?: BuildingCharacterWhereInput[]
    NOT?: BuildingCharacterWhereInput | BuildingCharacterWhereInput[]
    buildingConditionId?: IntNullableFilter<"BuildingCharacter"> | number | null
    buildingSeriaId?: IntNullableFilter<"BuildingCharacter"> | number | null
    building_year?: StringFilter<"BuildingCharacter"> | string
    wallMaterialId?: IntNullableFilter<"BuildingCharacter"> | number | null
    overlapsId?: IntNullableFilter<"BuildingCharacter"> | number | null
    waterSupplyId?: IntNullableFilter<"BuildingCharacter"> | number | null
    heatingSystemId?: IntNullableFilter<"BuildingCharacter"> | number | null
    is_gas?: BoolFilter<"BuildingCharacter"> | boolean
    is_electric?: BoolFilter<"BuildingCharacter"> | boolean
    passenger_elevators_count?: IntFilter<"BuildingCharacter"> | number
    freight_elevators_count?: IntFilter<"BuildingCharacter"> | number
    is_building_security?: BoolFilter<"BuildingCharacter"> | boolean
    parkingId?: IntNullableFilter<"BuildingCharacter"> | number | null
    is_demolition_planned?: BoolFilter<"BuildingCharacter"> | boolean
    BuildingCondition?: XOR<BuildingConditionNullableRelationFilter, BuildingConditionWhereInput> | null
    BuildingSeria?: XOR<BuildingSeriaNullableRelationFilter, BuildingSeriaWhereInput> | null
    WallMaterial?: XOR<WallMaterialNullableRelationFilter, WallMaterialWhereInput> | null
    Overlaps?: XOR<OverlapsNullableRelationFilter, OverlapsWhereInput> | null
    WaterSupply?: XOR<WaterSupplyNullableRelationFilter, WaterSupplyWhereInput> | null
    HeatingSystem?: XOR<HeatingSystemNullableRelationFilter, HeatingSystemWhereInput> | null
    Parking?: XOR<ParkingNullableRelationFilter, ParkingWhereInput> | null
  }, "id">

  export type BuildingCharacterOrderByWithAggregationInput = {
    id?: SortOrder
    buildingConditionId?: SortOrderInput | SortOrder
    buildingSeriaId?: SortOrderInput | SortOrder
    building_year?: SortOrder
    wallMaterialId?: SortOrderInput | SortOrder
    overlapsId?: SortOrderInput | SortOrder
    waterSupplyId?: SortOrderInput | SortOrder
    heatingSystemId?: SortOrderInput | SortOrder
    is_gas?: SortOrder
    is_electric?: SortOrder
    passenger_elevators_count?: SortOrder
    freight_elevators_count?: SortOrder
    is_building_security?: SortOrder
    parkingId?: SortOrderInput | SortOrder
    is_demolition_planned?: SortOrder
    _count?: BuildingCharacterCountOrderByAggregateInput
    _avg?: BuildingCharacterAvgOrderByAggregateInput
    _max?: BuildingCharacterMaxOrderByAggregateInput
    _min?: BuildingCharacterMinOrderByAggregateInput
    _sum?: BuildingCharacterSumOrderByAggregateInput
  }

  export type BuildingCharacterScalarWhereWithAggregatesInput = {
    AND?: BuildingCharacterScalarWhereWithAggregatesInput | BuildingCharacterScalarWhereWithAggregatesInput[]
    OR?: BuildingCharacterScalarWhereWithAggregatesInput[]
    NOT?: BuildingCharacterScalarWhereWithAggregatesInput | BuildingCharacterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuildingCharacter"> | number
    buildingConditionId?: IntNullableWithAggregatesFilter<"BuildingCharacter"> | number | null
    buildingSeriaId?: IntNullableWithAggregatesFilter<"BuildingCharacter"> | number | null
    building_year?: StringWithAggregatesFilter<"BuildingCharacter"> | string
    wallMaterialId?: IntNullableWithAggregatesFilter<"BuildingCharacter"> | number | null
    overlapsId?: IntNullableWithAggregatesFilter<"BuildingCharacter"> | number | null
    waterSupplyId?: IntNullableWithAggregatesFilter<"BuildingCharacter"> | number | null
    heatingSystemId?: IntNullableWithAggregatesFilter<"BuildingCharacter"> | number | null
    is_gas?: BoolWithAggregatesFilter<"BuildingCharacter"> | boolean
    is_electric?: BoolWithAggregatesFilter<"BuildingCharacter"> | boolean
    passenger_elevators_count?: IntWithAggregatesFilter<"BuildingCharacter"> | number
    freight_elevators_count?: IntWithAggregatesFilter<"BuildingCharacter"> | number
    is_building_security?: BoolWithAggregatesFilter<"BuildingCharacter"> | boolean
    parkingId?: IntNullableWithAggregatesFilter<"BuildingCharacter"> | number | null
    is_demolition_planned?: BoolWithAggregatesFilter<"BuildingCharacter"> | boolean
  }

  export type RealtorCreateInput = {
    name: string
    is_active: boolean
    reg_date: Date | string
    deactivate_date: Date | string
    photo: string
    login: string
    password: string
    object?: ObjectCreateNestedManyWithoutRealtorInput
  }

  export type RealtorUncheckedCreateInput = {
    id?: number
    name: string
    is_active: boolean
    reg_date: Date | string
    deactivate_date: Date | string
    photo: string
    login: string
    password: string
    object?: ObjectUncheckedCreateNestedManyWithoutRealtorInput
  }

  export type RealtorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    reg_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivate_date?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutRealtorNestedInput
  }

  export type RealtorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    reg_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivate_date?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutRealtorNestedInput
  }

  export type RealtorCreateManyInput = {
    id?: number
    name: string
    is_active: boolean
    reg_date: Date | string
    deactivate_date: Date | string
    photo: string
    login: string
    password: string
  }

  export type RealtorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    reg_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivate_date?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type RealtorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    reg_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivate_date?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectTypeCreateInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutObjectTypeInput
    residenceType?: ResidenceTypeCreateNestedManyWithoutObjectTypeInput
  }

  export type ObjectTypeUncheckedCreateInput = {
    id?: number
    name: string
    object?: ObjectUncheckedCreateNestedManyWithoutObjectTypeInput
    residenceType?: ResidenceTypeUncheckedCreateNestedManyWithoutObjectTypeInput
  }

  export type ObjectTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutObjectTypeNestedInput
    residenceType?: ResidenceTypeUpdateManyWithoutObjectTypeNestedInput
  }

  export type ObjectTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutObjectTypeNestedInput
    residenceType?: ResidenceTypeUncheckedUpdateManyWithoutObjectTypeNestedInput
  }

  export type ObjectTypeCreateManyInput = {
    id?: number
    name: string
  }

  export type ObjectTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResidenceTypeCreateInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutResidenceTypeInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutResidenceTypeInput
  }

  export type ResidenceTypeUncheckedCreateInput = {
    id?: number
    name: string
    objectTypeId?: number | null
    object?: ObjectUncheckedCreateNestedManyWithoutResidenceTypeInput
  }

  export type ResidenceTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutResidenceTypeNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutResidenceTypeNestedInput
  }

  export type ResidenceTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    object?: ObjectUncheckedUpdateManyWithoutResidenceTypeNestedInput
  }

  export type ResidenceTypeCreateManyInput = {
    id?: number
    name: string
    objectTypeId?: number | null
  }

  export type ResidenceTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ResidenceTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ObjectCategoryCreateInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutObjectCategoryInput
  }

  export type ObjectCategoryUncheckedCreateInput = {
    id?: number
    name: string
    object?: ObjectUncheckedCreateNestedManyWithoutObjectCategoryInput
  }

  export type ObjectCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutObjectCategoryNestedInput
  }

  export type ObjectCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutObjectCategoryNestedInput
  }

  export type ObjectCategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type ObjectCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectStatusCreateInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutObjectStatusInput
  }

  export type ObjectStatusUncheckedCreateInput = {
    id?: number
    name: string
    object?: ObjectUncheckedCreateNestedManyWithoutObjectStatusInput
  }

  export type ObjectStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutObjectStatusNestedInput
  }

  export type ObjectStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutObjectStatusNestedInput
  }

  export type ObjectStatusCreateManyInput = {
    id?: number
    name: string
  }

  export type ObjectStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyCreateInput = {
    name: string
    rate: string
    object?: ObjectCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: number
    name: string
    rate: string
    object?: ObjectUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    id?: number
    name: string
    rate: string
  }

  export type CurrencyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
  }

  export type RenovationCreateInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutRenovationInput
  }

  export type RenovationUncheckedCreateInput = {
    id?: number
    name: string
    object?: ObjectUncheckedCreateNestedManyWithoutRenovationInput
  }

  export type RenovationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutRenovationNestedInput
  }

  export type RenovationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutRenovationNestedInput
  }

  export type RenovationCreateManyInput = {
    id?: number
    name: string
  }

  export type RenovationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RenovationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WindowSideCreateInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutWindowSideInput
  }

  export type WindowSideUncheckedCreateInput = {
    id?: number
    name: string
    object?: ObjectUncheckedCreateNestedManyWithoutWindowSideInput
  }

  export type WindowSideUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutWindowSideNestedInput
  }

  export type WindowSideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutWindowSideNestedInput
  }

  export type WindowSideCreateManyInput = {
    id?: number
    name: string
  }

  export type WindowSideUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WindowSideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTypeCreateInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateInput = {
    id?: number
    name: string
    object?: ObjectUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeCreateManyInput = {
    id?: number
    name: string
  }

  export type RoomTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerShipCreateInput = {
    name: string
    ownerRelation?: OwnerRelationCreateNestedManyWithoutOwnerShipInput
  }

  export type OwnerShipUncheckedCreateInput = {
    id?: number
    name: string
    ownerRelation?: OwnerRelationUncheckedCreateNestedManyWithoutOwnerShipInput
  }

  export type OwnerShipUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    ownerRelation?: OwnerRelationUpdateManyWithoutOwnerShipNestedInput
  }

  export type OwnerShipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerRelation?: OwnerRelationUncheckedUpdateManyWithoutOwnerShipNestedInput
  }

  export type OwnerShipCreateManyInput = {
    id?: number
    name: string
  }

  export type OwnerShipUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerShipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReasonDeletingCreateInput = {
    name: string
    ownerRelation?: OwnerRelationCreateNestedManyWithoutReasonDeletingInput
  }

  export type ReasonDeletingUncheckedCreateInput = {
    id?: number
    name: string
    ownerRelation?: OwnerRelationUncheckedCreateNestedManyWithoutReasonDeletingInput
  }

  export type ReasonDeletingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    ownerRelation?: OwnerRelationUpdateManyWithoutReasonDeletingNestedInput
  }

  export type ReasonDeletingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerRelation?: OwnerRelationUncheckedUpdateManyWithoutReasonDeletingNestedInput
  }

  export type ReasonDeletingCreateManyInput = {
    id?: number
    name: string
  }

  export type ReasonDeletingUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReasonDeletingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerCooperationCreateInput = {
    name: string
    ownerRelation?: OwnerRelationCreateNestedManyWithoutOwnerCooperationInput
  }

  export type OwnerCooperationUncheckedCreateInput = {
    id?: number
    name: string
    ownerRelation?: OwnerRelationUncheckedCreateNestedManyWithoutOwnerCooperationInput
  }

  export type OwnerCooperationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    ownerRelation?: OwnerRelationUpdateManyWithoutOwnerCooperationNestedInput
  }

  export type OwnerCooperationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerRelation?: OwnerRelationUncheckedUpdateManyWithoutOwnerCooperationNestedInput
  }

  export type OwnerCooperationCreateManyInput = {
    id?: number
    name: string
  }

  export type OwnerCooperationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerCooperationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RelationshipTypeCreateInput = {
    name: string
    ownerRelation?: OwnerRelationCreateNestedManyWithoutRelationshipTypeInput
  }

  export type RelationshipTypeUncheckedCreateInput = {
    id?: number
    name: string
    ownerRelation?: OwnerRelationUncheckedCreateNestedManyWithoutRelationshipTypeInput
  }

  export type RelationshipTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    ownerRelation?: OwnerRelationUpdateManyWithoutRelationshipTypeNestedInput
  }

  export type RelationshipTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerRelation?: OwnerRelationUncheckedUpdateManyWithoutRelationshipTypeNestedInput
  }

  export type RelationshipTypeCreateManyInput = {
    id?: number
    name: string
  }

  export type RelationshipTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RelationshipTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerRelationCreateInput = {
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
    OwnerShip?: OwnerShipCreateNestedOneWithoutOwnerRelationInput
    ReasonDeleting?: ReasonDeletingCreateNestedOneWithoutOwnerRelationInput
    OwnerCooperation?: OwnerCooperationCreateNestedOneWithoutOwnerRelationInput
    RelationshipType?: RelationshipTypeCreateNestedOneWithoutOwnerRelationInput
  }

  export type OwnerRelationUncheckedCreateInput = {
    id?: number
    ownerShipId?: number | null
    reasonDeletingId?: number | null
    ownerCooperationId?: number | null
    relationshipTypeId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationUpdateInput = {
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
    OwnerShip?: OwnerShipUpdateOneWithoutOwnerRelationNestedInput
    ReasonDeleting?: ReasonDeletingUpdateOneWithoutOwnerRelationNestedInput
    OwnerCooperation?: OwnerCooperationUpdateOneWithoutOwnerRelationNestedInput
    RelationshipType?: RelationshipTypeUpdateOneWithoutOwnerRelationNestedInput
  }

  export type OwnerRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerShipId?: NullableIntFieldUpdateOperationsInput | number | null
    reasonDeletingId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerCooperationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationCreateManyInput = {
    id?: number
    ownerShipId?: number | null
    reasonDeletingId?: number | null
    ownerCooperationId?: number | null
    relationshipTypeId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationUpdateManyMutationInput = {
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerShipId?: NullableIntFieldUpdateOperationsInput | number | null
    reasonDeletingId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerCooperationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type RegionCreateInput = {
    name: string
    address?: AddressCreateNestedManyWithoutRegionInput
    district?: DistrictCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    name: string
    address?: AddressUncheckedCreateNestedManyWithoutRegionInput
    district?: DistrictUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutRegionNestedInput
    district?: DistrictUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutRegionNestedInput
    district?: DistrictUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: number
    name: string
  }

  export type RegionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictCreateInput = {
    name: string
    address?: AddressCreateNestedManyWithoutDistrictInput
    Region?: RegionCreateNestedOneWithoutDistrictInput
  }

  export type DistrictUncheckedCreateInput = {
    id?: number
    name: string
    regionId?: number | null
    address?: AddressUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutDistrictNestedInput
    Region?: RegionUpdateOneWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictCreateManyInput = {
    id?: number
    name: string
    regionId?: number | null
  }

  export type DistrictUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaCreateInput = {
    name: string
    address?: AddressCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateInput = {
    id?: number
    name: string
    address?: AddressUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaCreateManyInput = {
    id?: number
    name: string
  }

  export type AreaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MahallaCreateInput = {
    name: string
    address?: AddressCreateNestedManyWithoutMahallaInput
  }

  export type MahallaUncheckedCreateInput = {
    id?: number
    name: string
    address?: AddressUncheckedCreateNestedManyWithoutMahallaInput
  }

  export type MahallaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutMahallaNestedInput
  }

  export type MahallaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutMahallaNestedInput
  }

  export type MahallaCreateManyInput = {
    id?: number
    name: string
  }

  export type MahallaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MahallaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StreetCreateInput = {
    name: string
    address?: AddressCreateNestedManyWithoutStreetInput
  }

  export type StreetUncheckedCreateInput = {
    id?: number
    name: string
    address?: AddressUncheckedCreateNestedManyWithoutStreetInput
  }

  export type StreetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutStreetNestedInput
  }

  export type StreetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutStreetNestedInput
  }

  export type StreetCreateManyInput = {
    id?: number
    name: string
  }

  export type StreetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StreetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MetroCreateInput = {
    name: string
    address?: AddressCreateNestedManyWithoutMetroInput
  }

  export type MetroUncheckedCreateInput = {
    id?: number
    name: string
    address?: AddressUncheckedCreateNestedManyWithoutMetroInput
  }

  export type MetroUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutMetroNestedInput
  }

  export type MetroUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutMetroNestedInput
  }

  export type MetroCreateManyInput = {
    id?: number
    name: string
  }

  export type MetroUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MetroUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateInput = {
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
    Region?: RegionCreateNestedOneWithoutAddressInput
    District?: DistrictCreateNestedOneWithoutAddressInput
    Area?: AreaCreateNestedOneWithoutAddressInput
    Mahalla?: MahallaCreateNestedOneWithoutAddressInput
    Street?: StreetCreateNestedOneWithoutAddressInput
    Metro?: MetroCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressUpdateInput = {
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
    Region?: RegionUpdateOneWithoutAddressNestedInput
    District?: DistrictUpdateOneWithoutAddressNestedInput
    Area?: AreaUpdateOneWithoutAddressNestedInput
    Mahalla?: MahallaUpdateOneWithoutAddressNestedInput
    Street?: StreetUpdateOneWithoutAddressNestedInput
    Metro?: MetroUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressUpdateManyMutationInput = {
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingConditionCreateInput = {
    name: string
    buildingCharacter?: BuildingCharacterCreateNestedManyWithoutBuildingConditionInput
  }

  export type BuildingConditionUncheckedCreateInput = {
    id?: number
    name: string
    buildingCharacter?: BuildingCharacterUncheckedCreateNestedManyWithoutBuildingConditionInput
  }

  export type BuildingConditionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUpdateManyWithoutBuildingConditionNestedInput
  }

  export type BuildingConditionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUncheckedUpdateManyWithoutBuildingConditionNestedInput
  }

  export type BuildingConditionCreateManyInput = {
    id?: number
    name: string
  }

  export type BuildingConditionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingConditionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingSeriaCreateInput = {
    name: string
    buildingCharacter?: BuildingCharacterCreateNestedManyWithoutBuildingSeriaInput
  }

  export type BuildingSeriaUncheckedCreateInput = {
    id?: number
    name: string
    buildingCharacter?: BuildingCharacterUncheckedCreateNestedManyWithoutBuildingSeriaInput
  }

  export type BuildingSeriaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUpdateManyWithoutBuildingSeriaNestedInput
  }

  export type BuildingSeriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUncheckedUpdateManyWithoutBuildingSeriaNestedInput
  }

  export type BuildingSeriaCreateManyInput = {
    id?: number
    name: string
  }

  export type BuildingSeriaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingSeriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WallMaterialCreateInput = {
    name: string
    buildingCharacter?: BuildingCharacterCreateNestedManyWithoutWallMaterialInput
  }

  export type WallMaterialUncheckedCreateInput = {
    id?: number
    name: string
    buildingCharacter?: BuildingCharacterUncheckedCreateNestedManyWithoutWallMaterialInput
  }

  export type WallMaterialUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUpdateManyWithoutWallMaterialNestedInput
  }

  export type WallMaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUncheckedUpdateManyWithoutWallMaterialNestedInput
  }

  export type WallMaterialCreateManyInput = {
    id?: number
    name: string
  }

  export type WallMaterialUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WallMaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OverlapsCreateInput = {
    name: string
    buildingCharacter?: BuildingCharacterCreateNestedManyWithoutOverlapsInput
  }

  export type OverlapsUncheckedCreateInput = {
    id?: number
    name: string
    buildingCharacter?: BuildingCharacterUncheckedCreateNestedManyWithoutOverlapsInput
  }

  export type OverlapsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUpdateManyWithoutOverlapsNestedInput
  }

  export type OverlapsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUncheckedUpdateManyWithoutOverlapsNestedInput
  }

  export type OverlapsCreateManyInput = {
    id?: number
    name: string
  }

  export type OverlapsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OverlapsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WaterSupplyCreateInput = {
    name: string
    buildingCharacter?: BuildingCharacterCreateNestedManyWithoutWaterSupplyInput
  }

  export type WaterSupplyUncheckedCreateInput = {
    id?: number
    name: string
    buildingCharacter?: BuildingCharacterUncheckedCreateNestedManyWithoutWaterSupplyInput
  }

  export type WaterSupplyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUpdateManyWithoutWaterSupplyNestedInput
  }

  export type WaterSupplyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUncheckedUpdateManyWithoutWaterSupplyNestedInput
  }

  export type WaterSupplyCreateManyInput = {
    id?: number
    name: string
  }

  export type WaterSupplyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WaterSupplyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HeatingSystemCreateInput = {
    name: string
    buildingCharacter?: BuildingCharacterCreateNestedManyWithoutHeatingSystemInput
  }

  export type HeatingSystemUncheckedCreateInput = {
    id?: number
    name: string
    buildingCharacter?: BuildingCharacterUncheckedCreateNestedManyWithoutHeatingSystemInput
  }

  export type HeatingSystemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUpdateManyWithoutHeatingSystemNestedInput
  }

  export type HeatingSystemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUncheckedUpdateManyWithoutHeatingSystemNestedInput
  }

  export type HeatingSystemCreateManyInput = {
    id?: number
    name: string
  }

  export type HeatingSystemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HeatingSystemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ParkingCreateInput = {
    name: string
    buildingCharacter?: BuildingCharacterCreateNestedManyWithoutParkingInput
  }

  export type ParkingUncheckedCreateInput = {
    id?: number
    name: string
    buildingCharacter?: BuildingCharacterUncheckedCreateNestedManyWithoutParkingInput
  }

  export type ParkingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUpdateManyWithoutParkingNestedInput
  }

  export type ParkingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    buildingCharacter?: BuildingCharacterUncheckedUpdateManyWithoutParkingNestedInput
  }

  export type ParkingCreateManyInput = {
    id?: number
    name: string
  }

  export type ParkingUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ParkingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingCharacterCreateInput = {
    building_year: string
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
    BuildingCondition?: BuildingConditionCreateNestedOneWithoutBuildingCharacterInput
    BuildingSeria?: BuildingSeriaCreateNestedOneWithoutBuildingCharacterInput
    WallMaterial?: WallMaterialCreateNestedOneWithoutBuildingCharacterInput
    Overlaps?: OverlapsCreateNestedOneWithoutBuildingCharacterInput
    WaterSupply?: WaterSupplyCreateNestedOneWithoutBuildingCharacterInput
    HeatingSystem?: HeatingSystemCreateNestedOneWithoutBuildingCharacterInput
    Parking?: ParkingCreateNestedOneWithoutBuildingCharacterInput
  }

  export type BuildingCharacterUncheckedCreateInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
    BuildingCondition?: BuildingConditionUpdateOneWithoutBuildingCharacterNestedInput
    BuildingSeria?: BuildingSeriaUpdateOneWithoutBuildingCharacterNestedInput
    WallMaterial?: WallMaterialUpdateOneWithoutBuildingCharacterNestedInput
    Overlaps?: OverlapsUpdateOneWithoutBuildingCharacterNestedInput
    WaterSupply?: WaterSupplyUpdateOneWithoutBuildingCharacterNestedInput
    HeatingSystem?: HeatingSystemUpdateOneWithoutBuildingCharacterNestedInput
    Parking?: ParkingUpdateOneWithoutBuildingCharacterNestedInput
  }

  export type BuildingCharacterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterCreateManyInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateManyMutationInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ObjectListRelationFilter = {
    every?: ObjectWhereInput
    some?: ObjectWhereInput
    none?: ObjectWhereInput
  }

  export type ObjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RealtorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    reg_date?: SortOrder
    deactivate_date?: SortOrder
    photo?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type RealtorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RealtorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    reg_date?: SortOrder
    deactivate_date?: SortOrder
    photo?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type RealtorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    reg_date?: SortOrder
    deactivate_date?: SortOrder
    photo?: SortOrder
    login?: SortOrder
    password?: SortOrder
  }

  export type RealtorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ResidenceTypeListRelationFilter = {
    every?: ResidenceTypeWhereInput
    some?: ResidenceTypeWhereInput
    none?: ResidenceTypeWhereInput
  }

  export type ResidenceTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ObjectTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ObjectTypeNullableRelationFilter = {
    is?: ObjectTypeWhereInput | null
    isNot?: ObjectTypeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ResidenceTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    objectTypeId?: SortOrder
  }

  export type ResidenceTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    objectTypeId?: SortOrder
  }

  export type ResidenceTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    objectTypeId?: SortOrder
  }

  export type ResidenceTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    objectTypeId?: SortOrder
  }

  export type ResidenceTypeSumOrderByAggregateInput = {
    id?: SortOrder
    objectTypeId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ObjectCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ObjectCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ObjectStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ObjectStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ObjectStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RenovationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RenovationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RenovationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RenovationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RenovationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WindowSideCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WindowSideAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WindowSideMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WindowSideMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WindowSideSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RealtorNullableRelationFilter = {
    is?: RealtorWhereInput | null
    isNot?: RealtorWhereInput | null
  }

  export type ResidenceTypeNullableRelationFilter = {
    is?: ResidenceTypeWhereInput | null
    isNot?: ResidenceTypeWhereInput | null
  }

  export type ObjectCategoryNullableRelationFilter = {
    is?: ObjectCategoryWhereInput | null
    isNot?: ObjectCategoryWhereInput | null
  }

  export type ObjectStatusNullableRelationFilter = {
    is?: ObjectStatusWhereInput | null
    isNot?: ObjectStatusWhereInput | null
  }

  export type CurrencyNullableRelationFilter = {
    is?: CurrencyWhereInput | null
    isNot?: CurrencyWhereInput | null
  }

  export type RenovationNullableRelationFilter = {
    is?: RenovationWhereInput | null
    isNot?: RenovationWhereInput | null
  }

  export type WindowSideNullableRelationFilter = {
    is?: WindowSideWhereInput | null
    isNot?: WindowSideWhereInput | null
  }

  export type RoomTypeNullableRelationFilter = {
    is?: RoomTypeWhereInput | null
    isNot?: RoomTypeWhereInput | null
  }

  export type ObjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    realtorId?: SortOrder
    objectTypeId?: SortOrder
    residenceTypeId?: SortOrder
    objectCategoryId?: SortOrder
    objectStatusId?: SortOrder
    is_studio?: SortOrder
    floor?: SortOrder
    floors_in_building?: SortOrder
    total_area?: SortOrder
    live_area?: SortOrder
    kitchen_area?: SortOrder
    rooms_area?: SortOrder
    price?: SortOrder
    currencyId?: SortOrder
    price_per_square?: SortOrder
    price_type?: SortOrder
    renovationId?: SortOrder
    windowSideId?: SortOrder
    roomTypeId?: SortOrder
    is_apartment?: SortOrder
    is_luxury?: SortOrder
    ceiling_height?: SortOrder
    combined_bath_count?: SortOrder
    separate_bath_count?: SortOrder
    loggia_count?: SortOrder
    loggia_description?: SortOrder
    balcony_count?: SortOrder
    balcony_description?: SortOrder
    general_description?: SortOrder
    cadastral_number?: SortOrder
    document?: SortOrder
    layout?: SortOrder
    fotos?: SortOrder
    online_show?: SortOrder
    video?: SortOrder
  }

  export type ObjectAvgOrderByAggregateInput = {
    id?: SortOrder
    realtorId?: SortOrder
    objectTypeId?: SortOrder
    residenceTypeId?: SortOrder
    objectCategoryId?: SortOrder
    objectStatusId?: SortOrder
    floor?: SortOrder
    floors_in_building?: SortOrder
    total_area?: SortOrder
    live_area?: SortOrder
    kitchen_area?: SortOrder
    rooms_area?: SortOrder
    price?: SortOrder
    currencyId?: SortOrder
    price_per_square?: SortOrder
    price_type?: SortOrder
    renovationId?: SortOrder
    windowSideId?: SortOrder
    roomTypeId?: SortOrder
    ceiling_height?: SortOrder
    combined_bath_count?: SortOrder
    separate_bath_count?: SortOrder
    loggia_count?: SortOrder
    balcony_count?: SortOrder
    cadastral_number?: SortOrder
  }

  export type ObjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    realtorId?: SortOrder
    objectTypeId?: SortOrder
    residenceTypeId?: SortOrder
    objectCategoryId?: SortOrder
    objectStatusId?: SortOrder
    is_studio?: SortOrder
    floor?: SortOrder
    floors_in_building?: SortOrder
    total_area?: SortOrder
    live_area?: SortOrder
    kitchen_area?: SortOrder
    rooms_area?: SortOrder
    price?: SortOrder
    currencyId?: SortOrder
    price_per_square?: SortOrder
    price_type?: SortOrder
    renovationId?: SortOrder
    windowSideId?: SortOrder
    roomTypeId?: SortOrder
    is_apartment?: SortOrder
    is_luxury?: SortOrder
    ceiling_height?: SortOrder
    combined_bath_count?: SortOrder
    separate_bath_count?: SortOrder
    loggia_count?: SortOrder
    loggia_description?: SortOrder
    balcony_count?: SortOrder
    balcony_description?: SortOrder
    general_description?: SortOrder
    cadastral_number?: SortOrder
    document?: SortOrder
    layout?: SortOrder
    fotos?: SortOrder
    online_show?: SortOrder
    video?: SortOrder
  }

  export type ObjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    realtorId?: SortOrder
    objectTypeId?: SortOrder
    residenceTypeId?: SortOrder
    objectCategoryId?: SortOrder
    objectStatusId?: SortOrder
    is_studio?: SortOrder
    floor?: SortOrder
    floors_in_building?: SortOrder
    total_area?: SortOrder
    live_area?: SortOrder
    kitchen_area?: SortOrder
    rooms_area?: SortOrder
    price?: SortOrder
    currencyId?: SortOrder
    price_per_square?: SortOrder
    price_type?: SortOrder
    renovationId?: SortOrder
    windowSideId?: SortOrder
    roomTypeId?: SortOrder
    is_apartment?: SortOrder
    is_luxury?: SortOrder
    ceiling_height?: SortOrder
    combined_bath_count?: SortOrder
    separate_bath_count?: SortOrder
    loggia_count?: SortOrder
    loggia_description?: SortOrder
    balcony_count?: SortOrder
    balcony_description?: SortOrder
    general_description?: SortOrder
    cadastral_number?: SortOrder
    document?: SortOrder
    layout?: SortOrder
    fotos?: SortOrder
    online_show?: SortOrder
    video?: SortOrder
  }

  export type ObjectSumOrderByAggregateInput = {
    id?: SortOrder
    realtorId?: SortOrder
    objectTypeId?: SortOrder
    residenceTypeId?: SortOrder
    objectCategoryId?: SortOrder
    objectStatusId?: SortOrder
    floor?: SortOrder
    floors_in_building?: SortOrder
    total_area?: SortOrder
    live_area?: SortOrder
    kitchen_area?: SortOrder
    rooms_area?: SortOrder
    price?: SortOrder
    currencyId?: SortOrder
    price_per_square?: SortOrder
    price_type?: SortOrder
    renovationId?: SortOrder
    windowSideId?: SortOrder
    roomTypeId?: SortOrder
    ceiling_height?: SortOrder
    combined_bath_count?: SortOrder
    separate_bath_count?: SortOrder
    loggia_count?: SortOrder
    balcony_count?: SortOrder
    cadastral_number?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OwnerRelationListRelationFilter = {
    every?: OwnerRelationWhereInput
    some?: OwnerRelationWhereInput
    none?: OwnerRelationWhereInput
  }

  export type OwnerRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerShipCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OwnerShipAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OwnerShipMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OwnerShipMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OwnerShipSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReasonDeletingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ReasonDeletingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReasonDeletingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ReasonDeletingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ReasonDeletingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OwnerCooperationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OwnerCooperationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OwnerCooperationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OwnerCooperationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OwnerCooperationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RelationshipTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RelationshipTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RelationshipTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RelationshipTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RelationshipTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OwnerShipNullableRelationFilter = {
    is?: OwnerShipWhereInput | null
    isNot?: OwnerShipWhereInput | null
  }

  export type ReasonDeletingNullableRelationFilter = {
    is?: ReasonDeletingWhereInput | null
    isNot?: ReasonDeletingWhereInput | null
  }

  export type OwnerCooperationNullableRelationFilter = {
    is?: OwnerCooperationWhereInput | null
    isNot?: OwnerCooperationWhereInput | null
  }

  export type RelationshipTypeNullableRelationFilter = {
    is?: RelationshipTypeWhereInput | null
    isNot?: RelationshipTypeWhereInput | null
  }

  export type OwnerRelationCountOrderByAggregateInput = {
    id?: SortOrder
    ownerShipId?: SortOrder
    reasonDeletingId?: SortOrder
    ownerCooperationId?: SortOrder
    relationshipTypeId?: SortOrder
    commission_amount?: SortOrder
    commission_comment?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    owner_price_ideal?: SortOrder
    owner_price_real?: SortOrder
    owner_price_minimal?: SortOrder
  }

  export type OwnerRelationAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerShipId?: SortOrder
    reasonDeletingId?: SortOrder
    ownerCooperationId?: SortOrder
    relationshipTypeId?: SortOrder
    commission_amount?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    owner_price_ideal?: SortOrder
    owner_price_real?: SortOrder
    owner_price_minimal?: SortOrder
  }

  export type OwnerRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerShipId?: SortOrder
    reasonDeletingId?: SortOrder
    ownerCooperationId?: SortOrder
    relationshipTypeId?: SortOrder
    commission_amount?: SortOrder
    commission_comment?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    owner_price_ideal?: SortOrder
    owner_price_real?: SortOrder
    owner_price_minimal?: SortOrder
  }

  export type OwnerRelationMinOrderByAggregateInput = {
    id?: SortOrder
    ownerShipId?: SortOrder
    reasonDeletingId?: SortOrder
    ownerCooperationId?: SortOrder
    relationshipTypeId?: SortOrder
    commission_amount?: SortOrder
    commission_comment?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    owner_price_ideal?: SortOrder
    owner_price_real?: SortOrder
    owner_price_minimal?: SortOrder
  }

  export type OwnerRelationSumOrderByAggregateInput = {
    id?: SortOrder
    ownerShipId?: SortOrder
    reasonDeletingId?: SortOrder
    ownerCooperationId?: SortOrder
    relationshipTypeId?: SortOrder
    commission_amount?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    owner_price_ideal?: SortOrder
    owner_price_real?: SortOrder
    owner_price_minimal?: SortOrder
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type DistrictListRelationFilter = {
    every?: DistrictWhereInput
    some?: DistrictWhereInput
    none?: DistrictWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistrictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionNullableRelationFilter = {
    is?: RegionWhereInput | null
    isNot?: RegionWhereInput | null
  }

  export type DistrictCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrder
  }

  export type DistrictAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
  }

  export type DistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrder
  }

  export type DistrictMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    regionId?: SortOrder
  }

  export type DistrictSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AreaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AreaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MahallaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MahallaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MahallaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MahallaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MahallaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StreetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StreetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StreetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StreetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StreetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MetroCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MetroAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MetroMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MetroMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MetroSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DistrictNullableRelationFilter = {
    is?: DistrictWhereInput | null
    isNot?: DistrictWhereInput | null
  }

  export type AreaNullableRelationFilter = {
    is?: AreaWhereInput | null
    isNot?: AreaWhereInput | null
  }

  export type MahallaNullableRelationFilter = {
    is?: MahallaWhereInput | null
    isNot?: MahallaWhereInput | null
  }

  export type StreetNullableRelationFilter = {
    is?: StreetWhereInput | null
    isNot?: StreetWhereInput | null
  }

  export type MetroNullableRelationFilter = {
    is?: MetroWhereInput | null
    isNot?: MetroWhereInput | null
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    districtId?: SortOrder
    areaId?: SortOrder
    mahallaId?: SortOrder
    streetId?: SortOrder
    house_number?: SortOrder
    apartment_number?: SortOrder
    location?: SortOrder
    landmark?: SortOrder
    metroId?: SortOrder
    location_description?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    districtId?: SortOrder
    areaId?: SortOrder
    mahallaId?: SortOrder
    streetId?: SortOrder
    house_number?: SortOrder
    apartment_number?: SortOrder
    metroId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    districtId?: SortOrder
    areaId?: SortOrder
    mahallaId?: SortOrder
    streetId?: SortOrder
    house_number?: SortOrder
    apartment_number?: SortOrder
    location?: SortOrder
    landmark?: SortOrder
    metroId?: SortOrder
    location_description?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    districtId?: SortOrder
    areaId?: SortOrder
    mahallaId?: SortOrder
    streetId?: SortOrder
    house_number?: SortOrder
    apartment_number?: SortOrder
    location?: SortOrder
    landmark?: SortOrder
    metroId?: SortOrder
    location_description?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    districtId?: SortOrder
    areaId?: SortOrder
    mahallaId?: SortOrder
    streetId?: SortOrder
    house_number?: SortOrder
    apartment_number?: SortOrder
    metroId?: SortOrder
  }

  export type BuildingCharacterListRelationFilter = {
    every?: BuildingCharacterWhereInput
    some?: BuildingCharacterWhereInput
    none?: BuildingCharacterWhereInput
  }

  export type BuildingCharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BuildingConditionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BuildingConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BuildingConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BuildingConditionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BuildingSeriaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BuildingSeriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BuildingSeriaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BuildingSeriaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BuildingSeriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WallMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WallMaterialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WallMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WallMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WallMaterialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OverlapsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OverlapsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OverlapsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OverlapsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type OverlapsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaterSupplyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WaterSupplyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaterSupplyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WaterSupplyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WaterSupplySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HeatingSystemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type HeatingSystemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HeatingSystemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type HeatingSystemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type HeatingSystemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParkingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ParkingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParkingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ParkingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ParkingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BuildingConditionNullableRelationFilter = {
    is?: BuildingConditionWhereInput | null
    isNot?: BuildingConditionWhereInput | null
  }

  export type BuildingSeriaNullableRelationFilter = {
    is?: BuildingSeriaWhereInput | null
    isNot?: BuildingSeriaWhereInput | null
  }

  export type WallMaterialNullableRelationFilter = {
    is?: WallMaterialWhereInput | null
    isNot?: WallMaterialWhereInput | null
  }

  export type OverlapsNullableRelationFilter = {
    is?: OverlapsWhereInput | null
    isNot?: OverlapsWhereInput | null
  }

  export type WaterSupplyNullableRelationFilter = {
    is?: WaterSupplyWhereInput | null
    isNot?: WaterSupplyWhereInput | null
  }

  export type HeatingSystemNullableRelationFilter = {
    is?: HeatingSystemWhereInput | null
    isNot?: HeatingSystemWhereInput | null
  }

  export type ParkingNullableRelationFilter = {
    is?: ParkingWhereInput | null
    isNot?: ParkingWhereInput | null
  }

  export type BuildingCharacterCountOrderByAggregateInput = {
    id?: SortOrder
    buildingConditionId?: SortOrder
    buildingSeriaId?: SortOrder
    building_year?: SortOrder
    wallMaterialId?: SortOrder
    overlapsId?: SortOrder
    waterSupplyId?: SortOrder
    heatingSystemId?: SortOrder
    is_gas?: SortOrder
    is_electric?: SortOrder
    passenger_elevators_count?: SortOrder
    freight_elevators_count?: SortOrder
    is_building_security?: SortOrder
    parkingId?: SortOrder
    is_demolition_planned?: SortOrder
  }

  export type BuildingCharacterAvgOrderByAggregateInput = {
    id?: SortOrder
    buildingConditionId?: SortOrder
    buildingSeriaId?: SortOrder
    wallMaterialId?: SortOrder
    overlapsId?: SortOrder
    waterSupplyId?: SortOrder
    heatingSystemId?: SortOrder
    passenger_elevators_count?: SortOrder
    freight_elevators_count?: SortOrder
    parkingId?: SortOrder
  }

  export type BuildingCharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    buildingConditionId?: SortOrder
    buildingSeriaId?: SortOrder
    building_year?: SortOrder
    wallMaterialId?: SortOrder
    overlapsId?: SortOrder
    waterSupplyId?: SortOrder
    heatingSystemId?: SortOrder
    is_gas?: SortOrder
    is_electric?: SortOrder
    passenger_elevators_count?: SortOrder
    freight_elevators_count?: SortOrder
    is_building_security?: SortOrder
    parkingId?: SortOrder
    is_demolition_planned?: SortOrder
  }

  export type BuildingCharacterMinOrderByAggregateInput = {
    id?: SortOrder
    buildingConditionId?: SortOrder
    buildingSeriaId?: SortOrder
    building_year?: SortOrder
    wallMaterialId?: SortOrder
    overlapsId?: SortOrder
    waterSupplyId?: SortOrder
    heatingSystemId?: SortOrder
    is_gas?: SortOrder
    is_electric?: SortOrder
    passenger_elevators_count?: SortOrder
    freight_elevators_count?: SortOrder
    is_building_security?: SortOrder
    parkingId?: SortOrder
    is_demolition_planned?: SortOrder
  }

  export type BuildingCharacterSumOrderByAggregateInput = {
    id?: SortOrder
    buildingConditionId?: SortOrder
    buildingSeriaId?: SortOrder
    wallMaterialId?: SortOrder
    overlapsId?: SortOrder
    waterSupplyId?: SortOrder
    heatingSystemId?: SortOrder
    passenger_elevators_count?: SortOrder
    freight_elevators_count?: SortOrder
    parkingId?: SortOrder
  }

  export type ObjectCreateNestedManyWithoutRealtorInput = {
    create?: XOR<ObjectCreateWithoutRealtorInput, ObjectUncheckedCreateWithoutRealtorInput> | ObjectCreateWithoutRealtorInput[] | ObjectUncheckedCreateWithoutRealtorInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRealtorInput | ObjectCreateOrConnectWithoutRealtorInput[]
    createMany?: ObjectCreateManyRealtorInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutRealtorInput = {
    create?: XOR<ObjectCreateWithoutRealtorInput, ObjectUncheckedCreateWithoutRealtorInput> | ObjectCreateWithoutRealtorInput[] | ObjectUncheckedCreateWithoutRealtorInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRealtorInput | ObjectCreateOrConnectWithoutRealtorInput[]
    createMany?: ObjectCreateManyRealtorInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ObjectUpdateManyWithoutRealtorNestedInput = {
    create?: XOR<ObjectCreateWithoutRealtorInput, ObjectUncheckedCreateWithoutRealtorInput> | ObjectCreateWithoutRealtorInput[] | ObjectUncheckedCreateWithoutRealtorInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRealtorInput | ObjectCreateOrConnectWithoutRealtorInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutRealtorInput | ObjectUpsertWithWhereUniqueWithoutRealtorInput[]
    createMany?: ObjectCreateManyRealtorInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutRealtorInput | ObjectUpdateWithWhereUniqueWithoutRealtorInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutRealtorInput | ObjectUpdateManyWithWhereWithoutRealtorInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ObjectUncheckedUpdateManyWithoutRealtorNestedInput = {
    create?: XOR<ObjectCreateWithoutRealtorInput, ObjectUncheckedCreateWithoutRealtorInput> | ObjectCreateWithoutRealtorInput[] | ObjectUncheckedCreateWithoutRealtorInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRealtorInput | ObjectCreateOrConnectWithoutRealtorInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutRealtorInput | ObjectUpsertWithWhereUniqueWithoutRealtorInput[]
    createMany?: ObjectCreateManyRealtorInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutRealtorInput | ObjectUpdateWithWhereUniqueWithoutRealtorInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutRealtorInput | ObjectUpdateManyWithWhereWithoutRealtorInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectCreateNestedManyWithoutObjectTypeInput = {
    create?: XOR<ObjectCreateWithoutObjectTypeInput, ObjectUncheckedCreateWithoutObjectTypeInput> | ObjectCreateWithoutObjectTypeInput[] | ObjectUncheckedCreateWithoutObjectTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectTypeInput | ObjectCreateOrConnectWithoutObjectTypeInput[]
    createMany?: ObjectCreateManyObjectTypeInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ResidenceTypeCreateNestedManyWithoutObjectTypeInput = {
    create?: XOR<ResidenceTypeCreateWithoutObjectTypeInput, ResidenceTypeUncheckedCreateWithoutObjectTypeInput> | ResidenceTypeCreateWithoutObjectTypeInput[] | ResidenceTypeUncheckedCreateWithoutObjectTypeInput[]
    connectOrCreate?: ResidenceTypeCreateOrConnectWithoutObjectTypeInput | ResidenceTypeCreateOrConnectWithoutObjectTypeInput[]
    createMany?: ResidenceTypeCreateManyObjectTypeInputEnvelope
    connect?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutObjectTypeInput = {
    create?: XOR<ObjectCreateWithoutObjectTypeInput, ObjectUncheckedCreateWithoutObjectTypeInput> | ObjectCreateWithoutObjectTypeInput[] | ObjectUncheckedCreateWithoutObjectTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectTypeInput | ObjectCreateOrConnectWithoutObjectTypeInput[]
    createMany?: ObjectCreateManyObjectTypeInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ResidenceTypeUncheckedCreateNestedManyWithoutObjectTypeInput = {
    create?: XOR<ResidenceTypeCreateWithoutObjectTypeInput, ResidenceTypeUncheckedCreateWithoutObjectTypeInput> | ResidenceTypeCreateWithoutObjectTypeInput[] | ResidenceTypeUncheckedCreateWithoutObjectTypeInput[]
    connectOrCreate?: ResidenceTypeCreateOrConnectWithoutObjectTypeInput | ResidenceTypeCreateOrConnectWithoutObjectTypeInput[]
    createMany?: ResidenceTypeCreateManyObjectTypeInputEnvelope
    connect?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
  }

  export type ObjectUpdateManyWithoutObjectTypeNestedInput = {
    create?: XOR<ObjectCreateWithoutObjectTypeInput, ObjectUncheckedCreateWithoutObjectTypeInput> | ObjectCreateWithoutObjectTypeInput[] | ObjectUncheckedCreateWithoutObjectTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectTypeInput | ObjectCreateOrConnectWithoutObjectTypeInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutObjectTypeInput | ObjectUpsertWithWhereUniqueWithoutObjectTypeInput[]
    createMany?: ObjectCreateManyObjectTypeInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutObjectTypeInput | ObjectUpdateWithWhereUniqueWithoutObjectTypeInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutObjectTypeInput | ObjectUpdateManyWithWhereWithoutObjectTypeInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ResidenceTypeUpdateManyWithoutObjectTypeNestedInput = {
    create?: XOR<ResidenceTypeCreateWithoutObjectTypeInput, ResidenceTypeUncheckedCreateWithoutObjectTypeInput> | ResidenceTypeCreateWithoutObjectTypeInput[] | ResidenceTypeUncheckedCreateWithoutObjectTypeInput[]
    connectOrCreate?: ResidenceTypeCreateOrConnectWithoutObjectTypeInput | ResidenceTypeCreateOrConnectWithoutObjectTypeInput[]
    upsert?: ResidenceTypeUpsertWithWhereUniqueWithoutObjectTypeInput | ResidenceTypeUpsertWithWhereUniqueWithoutObjectTypeInput[]
    createMany?: ResidenceTypeCreateManyObjectTypeInputEnvelope
    set?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
    disconnect?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
    delete?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
    connect?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
    update?: ResidenceTypeUpdateWithWhereUniqueWithoutObjectTypeInput | ResidenceTypeUpdateWithWhereUniqueWithoutObjectTypeInput[]
    updateMany?: ResidenceTypeUpdateManyWithWhereWithoutObjectTypeInput | ResidenceTypeUpdateManyWithWhereWithoutObjectTypeInput[]
    deleteMany?: ResidenceTypeScalarWhereInput | ResidenceTypeScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutObjectTypeNestedInput = {
    create?: XOR<ObjectCreateWithoutObjectTypeInput, ObjectUncheckedCreateWithoutObjectTypeInput> | ObjectCreateWithoutObjectTypeInput[] | ObjectUncheckedCreateWithoutObjectTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectTypeInput | ObjectCreateOrConnectWithoutObjectTypeInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutObjectTypeInput | ObjectUpsertWithWhereUniqueWithoutObjectTypeInput[]
    createMany?: ObjectCreateManyObjectTypeInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutObjectTypeInput | ObjectUpdateWithWhereUniqueWithoutObjectTypeInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutObjectTypeInput | ObjectUpdateManyWithWhereWithoutObjectTypeInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ResidenceTypeUncheckedUpdateManyWithoutObjectTypeNestedInput = {
    create?: XOR<ResidenceTypeCreateWithoutObjectTypeInput, ResidenceTypeUncheckedCreateWithoutObjectTypeInput> | ResidenceTypeCreateWithoutObjectTypeInput[] | ResidenceTypeUncheckedCreateWithoutObjectTypeInput[]
    connectOrCreate?: ResidenceTypeCreateOrConnectWithoutObjectTypeInput | ResidenceTypeCreateOrConnectWithoutObjectTypeInput[]
    upsert?: ResidenceTypeUpsertWithWhereUniqueWithoutObjectTypeInput | ResidenceTypeUpsertWithWhereUniqueWithoutObjectTypeInput[]
    createMany?: ResidenceTypeCreateManyObjectTypeInputEnvelope
    set?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
    disconnect?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
    delete?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
    connect?: ResidenceTypeWhereUniqueInput | ResidenceTypeWhereUniqueInput[]
    update?: ResidenceTypeUpdateWithWhereUniqueWithoutObjectTypeInput | ResidenceTypeUpdateWithWhereUniqueWithoutObjectTypeInput[]
    updateMany?: ResidenceTypeUpdateManyWithWhereWithoutObjectTypeInput | ResidenceTypeUpdateManyWithWhereWithoutObjectTypeInput[]
    deleteMany?: ResidenceTypeScalarWhereInput | ResidenceTypeScalarWhereInput[]
  }

  export type ObjectCreateNestedManyWithoutResidenceTypeInput = {
    create?: XOR<ObjectCreateWithoutResidenceTypeInput, ObjectUncheckedCreateWithoutResidenceTypeInput> | ObjectCreateWithoutResidenceTypeInput[] | ObjectUncheckedCreateWithoutResidenceTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutResidenceTypeInput | ObjectCreateOrConnectWithoutResidenceTypeInput[]
    createMany?: ObjectCreateManyResidenceTypeInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectTypeCreateNestedOneWithoutResidenceTypeInput = {
    create?: XOR<ObjectTypeCreateWithoutResidenceTypeInput, ObjectTypeUncheckedCreateWithoutResidenceTypeInput>
    connectOrCreate?: ObjectTypeCreateOrConnectWithoutResidenceTypeInput
    connect?: ObjectTypeWhereUniqueInput
  }

  export type ObjectUncheckedCreateNestedManyWithoutResidenceTypeInput = {
    create?: XOR<ObjectCreateWithoutResidenceTypeInput, ObjectUncheckedCreateWithoutResidenceTypeInput> | ObjectCreateWithoutResidenceTypeInput[] | ObjectUncheckedCreateWithoutResidenceTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutResidenceTypeInput | ObjectCreateOrConnectWithoutResidenceTypeInput[]
    createMany?: ObjectCreateManyResidenceTypeInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUpdateManyWithoutResidenceTypeNestedInput = {
    create?: XOR<ObjectCreateWithoutResidenceTypeInput, ObjectUncheckedCreateWithoutResidenceTypeInput> | ObjectCreateWithoutResidenceTypeInput[] | ObjectUncheckedCreateWithoutResidenceTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutResidenceTypeInput | ObjectCreateOrConnectWithoutResidenceTypeInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutResidenceTypeInput | ObjectUpsertWithWhereUniqueWithoutResidenceTypeInput[]
    createMany?: ObjectCreateManyResidenceTypeInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutResidenceTypeInput | ObjectUpdateWithWhereUniqueWithoutResidenceTypeInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutResidenceTypeInput | ObjectUpdateManyWithWhereWithoutResidenceTypeInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectTypeUpdateOneWithoutResidenceTypeNestedInput = {
    create?: XOR<ObjectTypeCreateWithoutResidenceTypeInput, ObjectTypeUncheckedCreateWithoutResidenceTypeInput>
    connectOrCreate?: ObjectTypeCreateOrConnectWithoutResidenceTypeInput
    upsert?: ObjectTypeUpsertWithoutResidenceTypeInput
    disconnect?: ObjectTypeWhereInput | boolean
    delete?: ObjectTypeWhereInput | boolean
    connect?: ObjectTypeWhereUniqueInput
    update?: XOR<XOR<ObjectTypeUpdateToOneWithWhereWithoutResidenceTypeInput, ObjectTypeUpdateWithoutResidenceTypeInput>, ObjectTypeUncheckedUpdateWithoutResidenceTypeInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ObjectUncheckedUpdateManyWithoutResidenceTypeNestedInput = {
    create?: XOR<ObjectCreateWithoutResidenceTypeInput, ObjectUncheckedCreateWithoutResidenceTypeInput> | ObjectCreateWithoutResidenceTypeInput[] | ObjectUncheckedCreateWithoutResidenceTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutResidenceTypeInput | ObjectCreateOrConnectWithoutResidenceTypeInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutResidenceTypeInput | ObjectUpsertWithWhereUniqueWithoutResidenceTypeInput[]
    createMany?: ObjectCreateManyResidenceTypeInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutResidenceTypeInput | ObjectUpdateWithWhereUniqueWithoutResidenceTypeInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutResidenceTypeInput | ObjectUpdateManyWithWhereWithoutResidenceTypeInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectCreateNestedManyWithoutObjectCategoryInput = {
    create?: XOR<ObjectCreateWithoutObjectCategoryInput, ObjectUncheckedCreateWithoutObjectCategoryInput> | ObjectCreateWithoutObjectCategoryInput[] | ObjectUncheckedCreateWithoutObjectCategoryInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectCategoryInput | ObjectCreateOrConnectWithoutObjectCategoryInput[]
    createMany?: ObjectCreateManyObjectCategoryInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutObjectCategoryInput = {
    create?: XOR<ObjectCreateWithoutObjectCategoryInput, ObjectUncheckedCreateWithoutObjectCategoryInput> | ObjectCreateWithoutObjectCategoryInput[] | ObjectUncheckedCreateWithoutObjectCategoryInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectCategoryInput | ObjectCreateOrConnectWithoutObjectCategoryInput[]
    createMany?: ObjectCreateManyObjectCategoryInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUpdateManyWithoutObjectCategoryNestedInput = {
    create?: XOR<ObjectCreateWithoutObjectCategoryInput, ObjectUncheckedCreateWithoutObjectCategoryInput> | ObjectCreateWithoutObjectCategoryInput[] | ObjectUncheckedCreateWithoutObjectCategoryInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectCategoryInput | ObjectCreateOrConnectWithoutObjectCategoryInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutObjectCategoryInput | ObjectUpsertWithWhereUniqueWithoutObjectCategoryInput[]
    createMany?: ObjectCreateManyObjectCategoryInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutObjectCategoryInput | ObjectUpdateWithWhereUniqueWithoutObjectCategoryInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutObjectCategoryInput | ObjectUpdateManyWithWhereWithoutObjectCategoryInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutObjectCategoryNestedInput = {
    create?: XOR<ObjectCreateWithoutObjectCategoryInput, ObjectUncheckedCreateWithoutObjectCategoryInput> | ObjectCreateWithoutObjectCategoryInput[] | ObjectUncheckedCreateWithoutObjectCategoryInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectCategoryInput | ObjectCreateOrConnectWithoutObjectCategoryInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutObjectCategoryInput | ObjectUpsertWithWhereUniqueWithoutObjectCategoryInput[]
    createMany?: ObjectCreateManyObjectCategoryInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutObjectCategoryInput | ObjectUpdateWithWhereUniqueWithoutObjectCategoryInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutObjectCategoryInput | ObjectUpdateManyWithWhereWithoutObjectCategoryInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectCreateNestedManyWithoutObjectStatusInput = {
    create?: XOR<ObjectCreateWithoutObjectStatusInput, ObjectUncheckedCreateWithoutObjectStatusInput> | ObjectCreateWithoutObjectStatusInput[] | ObjectUncheckedCreateWithoutObjectStatusInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectStatusInput | ObjectCreateOrConnectWithoutObjectStatusInput[]
    createMany?: ObjectCreateManyObjectStatusInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutObjectStatusInput = {
    create?: XOR<ObjectCreateWithoutObjectStatusInput, ObjectUncheckedCreateWithoutObjectStatusInput> | ObjectCreateWithoutObjectStatusInput[] | ObjectUncheckedCreateWithoutObjectStatusInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectStatusInput | ObjectCreateOrConnectWithoutObjectStatusInput[]
    createMany?: ObjectCreateManyObjectStatusInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUpdateManyWithoutObjectStatusNestedInput = {
    create?: XOR<ObjectCreateWithoutObjectStatusInput, ObjectUncheckedCreateWithoutObjectStatusInput> | ObjectCreateWithoutObjectStatusInput[] | ObjectUncheckedCreateWithoutObjectStatusInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectStatusInput | ObjectCreateOrConnectWithoutObjectStatusInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutObjectStatusInput | ObjectUpsertWithWhereUniqueWithoutObjectStatusInput[]
    createMany?: ObjectCreateManyObjectStatusInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutObjectStatusInput | ObjectUpdateWithWhereUniqueWithoutObjectStatusInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutObjectStatusInput | ObjectUpdateManyWithWhereWithoutObjectStatusInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutObjectStatusNestedInput = {
    create?: XOR<ObjectCreateWithoutObjectStatusInput, ObjectUncheckedCreateWithoutObjectStatusInput> | ObjectCreateWithoutObjectStatusInput[] | ObjectUncheckedCreateWithoutObjectStatusInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutObjectStatusInput | ObjectCreateOrConnectWithoutObjectStatusInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutObjectStatusInput | ObjectUpsertWithWhereUniqueWithoutObjectStatusInput[]
    createMany?: ObjectCreateManyObjectStatusInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutObjectStatusInput | ObjectUpdateWithWhereUniqueWithoutObjectStatusInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutObjectStatusInput | ObjectUpdateManyWithWhereWithoutObjectStatusInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ObjectCreateWithoutCurrencyInput, ObjectUncheckedCreateWithoutCurrencyInput> | ObjectCreateWithoutCurrencyInput[] | ObjectUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutCurrencyInput | ObjectCreateOrConnectWithoutCurrencyInput[]
    createMany?: ObjectCreateManyCurrencyInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ObjectCreateWithoutCurrencyInput, ObjectUncheckedCreateWithoutCurrencyInput> | ObjectCreateWithoutCurrencyInput[] | ObjectUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutCurrencyInput | ObjectCreateOrConnectWithoutCurrencyInput[]
    createMany?: ObjectCreateManyCurrencyInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ObjectCreateWithoutCurrencyInput, ObjectUncheckedCreateWithoutCurrencyInput> | ObjectCreateWithoutCurrencyInput[] | ObjectUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutCurrencyInput | ObjectCreateOrConnectWithoutCurrencyInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutCurrencyInput | ObjectUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ObjectCreateManyCurrencyInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutCurrencyInput | ObjectUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutCurrencyInput | ObjectUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ObjectCreateWithoutCurrencyInput, ObjectUncheckedCreateWithoutCurrencyInput> | ObjectCreateWithoutCurrencyInput[] | ObjectUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutCurrencyInput | ObjectCreateOrConnectWithoutCurrencyInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutCurrencyInput | ObjectUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ObjectCreateManyCurrencyInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutCurrencyInput | ObjectUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutCurrencyInput | ObjectUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectCreateNestedManyWithoutRenovationInput = {
    create?: XOR<ObjectCreateWithoutRenovationInput, ObjectUncheckedCreateWithoutRenovationInput> | ObjectCreateWithoutRenovationInput[] | ObjectUncheckedCreateWithoutRenovationInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRenovationInput | ObjectCreateOrConnectWithoutRenovationInput[]
    createMany?: ObjectCreateManyRenovationInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutRenovationInput = {
    create?: XOR<ObjectCreateWithoutRenovationInput, ObjectUncheckedCreateWithoutRenovationInput> | ObjectCreateWithoutRenovationInput[] | ObjectUncheckedCreateWithoutRenovationInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRenovationInput | ObjectCreateOrConnectWithoutRenovationInput[]
    createMany?: ObjectCreateManyRenovationInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUpdateManyWithoutRenovationNestedInput = {
    create?: XOR<ObjectCreateWithoutRenovationInput, ObjectUncheckedCreateWithoutRenovationInput> | ObjectCreateWithoutRenovationInput[] | ObjectUncheckedCreateWithoutRenovationInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRenovationInput | ObjectCreateOrConnectWithoutRenovationInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutRenovationInput | ObjectUpsertWithWhereUniqueWithoutRenovationInput[]
    createMany?: ObjectCreateManyRenovationInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutRenovationInput | ObjectUpdateWithWhereUniqueWithoutRenovationInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutRenovationInput | ObjectUpdateManyWithWhereWithoutRenovationInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutRenovationNestedInput = {
    create?: XOR<ObjectCreateWithoutRenovationInput, ObjectUncheckedCreateWithoutRenovationInput> | ObjectCreateWithoutRenovationInput[] | ObjectUncheckedCreateWithoutRenovationInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRenovationInput | ObjectCreateOrConnectWithoutRenovationInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutRenovationInput | ObjectUpsertWithWhereUniqueWithoutRenovationInput[]
    createMany?: ObjectCreateManyRenovationInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutRenovationInput | ObjectUpdateWithWhereUniqueWithoutRenovationInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutRenovationInput | ObjectUpdateManyWithWhereWithoutRenovationInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectCreateNestedManyWithoutWindowSideInput = {
    create?: XOR<ObjectCreateWithoutWindowSideInput, ObjectUncheckedCreateWithoutWindowSideInput> | ObjectCreateWithoutWindowSideInput[] | ObjectUncheckedCreateWithoutWindowSideInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutWindowSideInput | ObjectCreateOrConnectWithoutWindowSideInput[]
    createMany?: ObjectCreateManyWindowSideInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutWindowSideInput = {
    create?: XOR<ObjectCreateWithoutWindowSideInput, ObjectUncheckedCreateWithoutWindowSideInput> | ObjectCreateWithoutWindowSideInput[] | ObjectUncheckedCreateWithoutWindowSideInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutWindowSideInput | ObjectCreateOrConnectWithoutWindowSideInput[]
    createMany?: ObjectCreateManyWindowSideInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUpdateManyWithoutWindowSideNestedInput = {
    create?: XOR<ObjectCreateWithoutWindowSideInput, ObjectUncheckedCreateWithoutWindowSideInput> | ObjectCreateWithoutWindowSideInput[] | ObjectUncheckedCreateWithoutWindowSideInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutWindowSideInput | ObjectCreateOrConnectWithoutWindowSideInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutWindowSideInput | ObjectUpsertWithWhereUniqueWithoutWindowSideInput[]
    createMany?: ObjectCreateManyWindowSideInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutWindowSideInput | ObjectUpdateWithWhereUniqueWithoutWindowSideInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutWindowSideInput | ObjectUpdateManyWithWhereWithoutWindowSideInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutWindowSideNestedInput = {
    create?: XOR<ObjectCreateWithoutWindowSideInput, ObjectUncheckedCreateWithoutWindowSideInput> | ObjectCreateWithoutWindowSideInput[] | ObjectUncheckedCreateWithoutWindowSideInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutWindowSideInput | ObjectCreateOrConnectWithoutWindowSideInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutWindowSideInput | ObjectUpsertWithWhereUniqueWithoutWindowSideInput[]
    createMany?: ObjectCreateManyWindowSideInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutWindowSideInput | ObjectUpdateWithWhereUniqueWithoutWindowSideInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutWindowSideInput | ObjectUpdateManyWithWhereWithoutWindowSideInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<ObjectCreateWithoutRoomTypeInput, ObjectUncheckedCreateWithoutRoomTypeInput> | ObjectCreateWithoutRoomTypeInput[] | ObjectUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRoomTypeInput | ObjectCreateOrConnectWithoutRoomTypeInput[]
    createMany?: ObjectCreateManyRoomTypeInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<ObjectCreateWithoutRoomTypeInput, ObjectUncheckedCreateWithoutRoomTypeInput> | ObjectCreateWithoutRoomTypeInput[] | ObjectUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRoomTypeInput | ObjectCreateOrConnectWithoutRoomTypeInput[]
    createMany?: ObjectCreateManyRoomTypeInputEnvelope
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
  }

  export type ObjectUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<ObjectCreateWithoutRoomTypeInput, ObjectUncheckedCreateWithoutRoomTypeInput> | ObjectCreateWithoutRoomTypeInput[] | ObjectUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRoomTypeInput | ObjectCreateOrConnectWithoutRoomTypeInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutRoomTypeInput | ObjectUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: ObjectCreateManyRoomTypeInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutRoomTypeInput | ObjectUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutRoomTypeInput | ObjectUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type ObjectUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<ObjectCreateWithoutRoomTypeInput, ObjectUncheckedCreateWithoutRoomTypeInput> | ObjectCreateWithoutRoomTypeInput[] | ObjectUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ObjectCreateOrConnectWithoutRoomTypeInput | ObjectCreateOrConnectWithoutRoomTypeInput[]
    upsert?: ObjectUpsertWithWhereUniqueWithoutRoomTypeInput | ObjectUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: ObjectCreateManyRoomTypeInputEnvelope
    set?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    disconnect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    delete?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    connect?: ObjectWhereUniqueInput | ObjectWhereUniqueInput[]
    update?: ObjectUpdateWithWhereUniqueWithoutRoomTypeInput | ObjectUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: ObjectUpdateManyWithWhereWithoutRoomTypeInput | ObjectUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
  }

  export type RealtorCreateNestedOneWithoutObjectInput = {
    create?: XOR<RealtorCreateWithoutObjectInput, RealtorUncheckedCreateWithoutObjectInput>
    connectOrCreate?: RealtorCreateOrConnectWithoutObjectInput
    connect?: RealtorWhereUniqueInput
  }

  export type ObjectTypeCreateNestedOneWithoutObjectInput = {
    create?: XOR<ObjectTypeCreateWithoutObjectInput, ObjectTypeUncheckedCreateWithoutObjectInput>
    connectOrCreate?: ObjectTypeCreateOrConnectWithoutObjectInput
    connect?: ObjectTypeWhereUniqueInput
  }

  export type ResidenceTypeCreateNestedOneWithoutObjectInput = {
    create?: XOR<ResidenceTypeCreateWithoutObjectInput, ResidenceTypeUncheckedCreateWithoutObjectInput>
    connectOrCreate?: ResidenceTypeCreateOrConnectWithoutObjectInput
    connect?: ResidenceTypeWhereUniqueInput
  }

  export type ObjectCategoryCreateNestedOneWithoutObjectInput = {
    create?: XOR<ObjectCategoryCreateWithoutObjectInput, ObjectCategoryUncheckedCreateWithoutObjectInput>
    connectOrCreate?: ObjectCategoryCreateOrConnectWithoutObjectInput
    connect?: ObjectCategoryWhereUniqueInput
  }

  export type ObjectStatusCreateNestedOneWithoutObjectInput = {
    create?: XOR<ObjectStatusCreateWithoutObjectInput, ObjectStatusUncheckedCreateWithoutObjectInput>
    connectOrCreate?: ObjectStatusCreateOrConnectWithoutObjectInput
    connect?: ObjectStatusWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutObjectInput = {
    create?: XOR<CurrencyCreateWithoutObjectInput, CurrencyUncheckedCreateWithoutObjectInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutObjectInput
    connect?: CurrencyWhereUniqueInput
  }

  export type RenovationCreateNestedOneWithoutObjectInput = {
    create?: XOR<RenovationCreateWithoutObjectInput, RenovationUncheckedCreateWithoutObjectInput>
    connectOrCreate?: RenovationCreateOrConnectWithoutObjectInput
    connect?: RenovationWhereUniqueInput
  }

  export type WindowSideCreateNestedOneWithoutObjectInput = {
    create?: XOR<WindowSideCreateWithoutObjectInput, WindowSideUncheckedCreateWithoutObjectInput>
    connectOrCreate?: WindowSideCreateOrConnectWithoutObjectInput
    connect?: WindowSideWhereUniqueInput
  }

  export type RoomTypeCreateNestedOneWithoutObjectInput = {
    create?: XOR<RoomTypeCreateWithoutObjectInput, RoomTypeUncheckedCreateWithoutObjectInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutObjectInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RealtorUpdateOneWithoutObjectNestedInput = {
    create?: XOR<RealtorCreateWithoutObjectInput, RealtorUncheckedCreateWithoutObjectInput>
    connectOrCreate?: RealtorCreateOrConnectWithoutObjectInput
    upsert?: RealtorUpsertWithoutObjectInput
    disconnect?: RealtorWhereInput | boolean
    delete?: RealtorWhereInput | boolean
    connect?: RealtorWhereUniqueInput
    update?: XOR<XOR<RealtorUpdateToOneWithWhereWithoutObjectInput, RealtorUpdateWithoutObjectInput>, RealtorUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectTypeUpdateOneWithoutObjectNestedInput = {
    create?: XOR<ObjectTypeCreateWithoutObjectInput, ObjectTypeUncheckedCreateWithoutObjectInput>
    connectOrCreate?: ObjectTypeCreateOrConnectWithoutObjectInput
    upsert?: ObjectTypeUpsertWithoutObjectInput
    disconnect?: ObjectTypeWhereInput | boolean
    delete?: ObjectTypeWhereInput | boolean
    connect?: ObjectTypeWhereUniqueInput
    update?: XOR<XOR<ObjectTypeUpdateToOneWithWhereWithoutObjectInput, ObjectTypeUpdateWithoutObjectInput>, ObjectTypeUncheckedUpdateWithoutObjectInput>
  }

  export type ResidenceTypeUpdateOneWithoutObjectNestedInput = {
    create?: XOR<ResidenceTypeCreateWithoutObjectInput, ResidenceTypeUncheckedCreateWithoutObjectInput>
    connectOrCreate?: ResidenceTypeCreateOrConnectWithoutObjectInput
    upsert?: ResidenceTypeUpsertWithoutObjectInput
    disconnect?: ResidenceTypeWhereInput | boolean
    delete?: ResidenceTypeWhereInput | boolean
    connect?: ResidenceTypeWhereUniqueInput
    update?: XOR<XOR<ResidenceTypeUpdateToOneWithWhereWithoutObjectInput, ResidenceTypeUpdateWithoutObjectInput>, ResidenceTypeUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectCategoryUpdateOneWithoutObjectNestedInput = {
    create?: XOR<ObjectCategoryCreateWithoutObjectInput, ObjectCategoryUncheckedCreateWithoutObjectInput>
    connectOrCreate?: ObjectCategoryCreateOrConnectWithoutObjectInput
    upsert?: ObjectCategoryUpsertWithoutObjectInput
    disconnect?: ObjectCategoryWhereInput | boolean
    delete?: ObjectCategoryWhereInput | boolean
    connect?: ObjectCategoryWhereUniqueInput
    update?: XOR<XOR<ObjectCategoryUpdateToOneWithWhereWithoutObjectInput, ObjectCategoryUpdateWithoutObjectInput>, ObjectCategoryUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectStatusUpdateOneWithoutObjectNestedInput = {
    create?: XOR<ObjectStatusCreateWithoutObjectInput, ObjectStatusUncheckedCreateWithoutObjectInput>
    connectOrCreate?: ObjectStatusCreateOrConnectWithoutObjectInput
    upsert?: ObjectStatusUpsertWithoutObjectInput
    disconnect?: ObjectStatusWhereInput | boolean
    delete?: ObjectStatusWhereInput | boolean
    connect?: ObjectStatusWhereUniqueInput
    update?: XOR<XOR<ObjectStatusUpdateToOneWithWhereWithoutObjectInput, ObjectStatusUpdateWithoutObjectInput>, ObjectStatusUncheckedUpdateWithoutObjectInput>
  }

  export type CurrencyUpdateOneWithoutObjectNestedInput = {
    create?: XOR<CurrencyCreateWithoutObjectInput, CurrencyUncheckedCreateWithoutObjectInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutObjectInput
    upsert?: CurrencyUpsertWithoutObjectInput
    disconnect?: CurrencyWhereInput | boolean
    delete?: CurrencyWhereInput | boolean
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutObjectInput, CurrencyUpdateWithoutObjectInput>, CurrencyUncheckedUpdateWithoutObjectInput>
  }

  export type RenovationUpdateOneWithoutObjectNestedInput = {
    create?: XOR<RenovationCreateWithoutObjectInput, RenovationUncheckedCreateWithoutObjectInput>
    connectOrCreate?: RenovationCreateOrConnectWithoutObjectInput
    upsert?: RenovationUpsertWithoutObjectInput
    disconnect?: RenovationWhereInput | boolean
    delete?: RenovationWhereInput | boolean
    connect?: RenovationWhereUniqueInput
    update?: XOR<XOR<RenovationUpdateToOneWithWhereWithoutObjectInput, RenovationUpdateWithoutObjectInput>, RenovationUncheckedUpdateWithoutObjectInput>
  }

  export type WindowSideUpdateOneWithoutObjectNestedInput = {
    create?: XOR<WindowSideCreateWithoutObjectInput, WindowSideUncheckedCreateWithoutObjectInput>
    connectOrCreate?: WindowSideCreateOrConnectWithoutObjectInput
    upsert?: WindowSideUpsertWithoutObjectInput
    disconnect?: WindowSideWhereInput | boolean
    delete?: WindowSideWhereInput | boolean
    connect?: WindowSideWhereUniqueInput
    update?: XOR<XOR<WindowSideUpdateToOneWithWhereWithoutObjectInput, WindowSideUpdateWithoutObjectInput>, WindowSideUncheckedUpdateWithoutObjectInput>
  }

  export type RoomTypeUpdateOneWithoutObjectNestedInput = {
    create?: XOR<RoomTypeCreateWithoutObjectInput, RoomTypeUncheckedCreateWithoutObjectInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutObjectInput
    upsert?: RoomTypeUpsertWithoutObjectInput
    disconnect?: RoomTypeWhereInput | boolean
    delete?: RoomTypeWhereInput | boolean
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutObjectInput, RoomTypeUpdateWithoutObjectInput>, RoomTypeUncheckedUpdateWithoutObjectInput>
  }

  export type OwnerRelationCreateNestedManyWithoutOwnerShipInput = {
    create?: XOR<OwnerRelationCreateWithoutOwnerShipInput, OwnerRelationUncheckedCreateWithoutOwnerShipInput> | OwnerRelationCreateWithoutOwnerShipInput[] | OwnerRelationUncheckedCreateWithoutOwnerShipInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutOwnerShipInput | OwnerRelationCreateOrConnectWithoutOwnerShipInput[]
    createMany?: OwnerRelationCreateManyOwnerShipInputEnvelope
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
  }

  export type OwnerRelationUncheckedCreateNestedManyWithoutOwnerShipInput = {
    create?: XOR<OwnerRelationCreateWithoutOwnerShipInput, OwnerRelationUncheckedCreateWithoutOwnerShipInput> | OwnerRelationCreateWithoutOwnerShipInput[] | OwnerRelationUncheckedCreateWithoutOwnerShipInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutOwnerShipInput | OwnerRelationCreateOrConnectWithoutOwnerShipInput[]
    createMany?: OwnerRelationCreateManyOwnerShipInputEnvelope
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
  }

  export type OwnerRelationUpdateManyWithoutOwnerShipNestedInput = {
    create?: XOR<OwnerRelationCreateWithoutOwnerShipInput, OwnerRelationUncheckedCreateWithoutOwnerShipInput> | OwnerRelationCreateWithoutOwnerShipInput[] | OwnerRelationUncheckedCreateWithoutOwnerShipInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutOwnerShipInput | OwnerRelationCreateOrConnectWithoutOwnerShipInput[]
    upsert?: OwnerRelationUpsertWithWhereUniqueWithoutOwnerShipInput | OwnerRelationUpsertWithWhereUniqueWithoutOwnerShipInput[]
    createMany?: OwnerRelationCreateManyOwnerShipInputEnvelope
    set?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    disconnect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    delete?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    update?: OwnerRelationUpdateWithWhereUniqueWithoutOwnerShipInput | OwnerRelationUpdateWithWhereUniqueWithoutOwnerShipInput[]
    updateMany?: OwnerRelationUpdateManyWithWhereWithoutOwnerShipInput | OwnerRelationUpdateManyWithWhereWithoutOwnerShipInput[]
    deleteMany?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
  }

  export type OwnerRelationUncheckedUpdateManyWithoutOwnerShipNestedInput = {
    create?: XOR<OwnerRelationCreateWithoutOwnerShipInput, OwnerRelationUncheckedCreateWithoutOwnerShipInput> | OwnerRelationCreateWithoutOwnerShipInput[] | OwnerRelationUncheckedCreateWithoutOwnerShipInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutOwnerShipInput | OwnerRelationCreateOrConnectWithoutOwnerShipInput[]
    upsert?: OwnerRelationUpsertWithWhereUniqueWithoutOwnerShipInput | OwnerRelationUpsertWithWhereUniqueWithoutOwnerShipInput[]
    createMany?: OwnerRelationCreateManyOwnerShipInputEnvelope
    set?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    disconnect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    delete?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    update?: OwnerRelationUpdateWithWhereUniqueWithoutOwnerShipInput | OwnerRelationUpdateWithWhereUniqueWithoutOwnerShipInput[]
    updateMany?: OwnerRelationUpdateManyWithWhereWithoutOwnerShipInput | OwnerRelationUpdateManyWithWhereWithoutOwnerShipInput[]
    deleteMany?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
  }

  export type OwnerRelationCreateNestedManyWithoutReasonDeletingInput = {
    create?: XOR<OwnerRelationCreateWithoutReasonDeletingInput, OwnerRelationUncheckedCreateWithoutReasonDeletingInput> | OwnerRelationCreateWithoutReasonDeletingInput[] | OwnerRelationUncheckedCreateWithoutReasonDeletingInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutReasonDeletingInput | OwnerRelationCreateOrConnectWithoutReasonDeletingInput[]
    createMany?: OwnerRelationCreateManyReasonDeletingInputEnvelope
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
  }

  export type OwnerRelationUncheckedCreateNestedManyWithoutReasonDeletingInput = {
    create?: XOR<OwnerRelationCreateWithoutReasonDeletingInput, OwnerRelationUncheckedCreateWithoutReasonDeletingInput> | OwnerRelationCreateWithoutReasonDeletingInput[] | OwnerRelationUncheckedCreateWithoutReasonDeletingInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutReasonDeletingInput | OwnerRelationCreateOrConnectWithoutReasonDeletingInput[]
    createMany?: OwnerRelationCreateManyReasonDeletingInputEnvelope
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
  }

  export type OwnerRelationUpdateManyWithoutReasonDeletingNestedInput = {
    create?: XOR<OwnerRelationCreateWithoutReasonDeletingInput, OwnerRelationUncheckedCreateWithoutReasonDeletingInput> | OwnerRelationCreateWithoutReasonDeletingInput[] | OwnerRelationUncheckedCreateWithoutReasonDeletingInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutReasonDeletingInput | OwnerRelationCreateOrConnectWithoutReasonDeletingInput[]
    upsert?: OwnerRelationUpsertWithWhereUniqueWithoutReasonDeletingInput | OwnerRelationUpsertWithWhereUniqueWithoutReasonDeletingInput[]
    createMany?: OwnerRelationCreateManyReasonDeletingInputEnvelope
    set?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    disconnect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    delete?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    update?: OwnerRelationUpdateWithWhereUniqueWithoutReasonDeletingInput | OwnerRelationUpdateWithWhereUniqueWithoutReasonDeletingInput[]
    updateMany?: OwnerRelationUpdateManyWithWhereWithoutReasonDeletingInput | OwnerRelationUpdateManyWithWhereWithoutReasonDeletingInput[]
    deleteMany?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
  }

  export type OwnerRelationUncheckedUpdateManyWithoutReasonDeletingNestedInput = {
    create?: XOR<OwnerRelationCreateWithoutReasonDeletingInput, OwnerRelationUncheckedCreateWithoutReasonDeletingInput> | OwnerRelationCreateWithoutReasonDeletingInput[] | OwnerRelationUncheckedCreateWithoutReasonDeletingInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutReasonDeletingInput | OwnerRelationCreateOrConnectWithoutReasonDeletingInput[]
    upsert?: OwnerRelationUpsertWithWhereUniqueWithoutReasonDeletingInput | OwnerRelationUpsertWithWhereUniqueWithoutReasonDeletingInput[]
    createMany?: OwnerRelationCreateManyReasonDeletingInputEnvelope
    set?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    disconnect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    delete?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    update?: OwnerRelationUpdateWithWhereUniqueWithoutReasonDeletingInput | OwnerRelationUpdateWithWhereUniqueWithoutReasonDeletingInput[]
    updateMany?: OwnerRelationUpdateManyWithWhereWithoutReasonDeletingInput | OwnerRelationUpdateManyWithWhereWithoutReasonDeletingInput[]
    deleteMany?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
  }

  export type OwnerRelationCreateNestedManyWithoutOwnerCooperationInput = {
    create?: XOR<OwnerRelationCreateWithoutOwnerCooperationInput, OwnerRelationUncheckedCreateWithoutOwnerCooperationInput> | OwnerRelationCreateWithoutOwnerCooperationInput[] | OwnerRelationUncheckedCreateWithoutOwnerCooperationInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutOwnerCooperationInput | OwnerRelationCreateOrConnectWithoutOwnerCooperationInput[]
    createMany?: OwnerRelationCreateManyOwnerCooperationInputEnvelope
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
  }

  export type OwnerRelationUncheckedCreateNestedManyWithoutOwnerCooperationInput = {
    create?: XOR<OwnerRelationCreateWithoutOwnerCooperationInput, OwnerRelationUncheckedCreateWithoutOwnerCooperationInput> | OwnerRelationCreateWithoutOwnerCooperationInput[] | OwnerRelationUncheckedCreateWithoutOwnerCooperationInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutOwnerCooperationInput | OwnerRelationCreateOrConnectWithoutOwnerCooperationInput[]
    createMany?: OwnerRelationCreateManyOwnerCooperationInputEnvelope
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
  }

  export type OwnerRelationUpdateManyWithoutOwnerCooperationNestedInput = {
    create?: XOR<OwnerRelationCreateWithoutOwnerCooperationInput, OwnerRelationUncheckedCreateWithoutOwnerCooperationInput> | OwnerRelationCreateWithoutOwnerCooperationInput[] | OwnerRelationUncheckedCreateWithoutOwnerCooperationInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutOwnerCooperationInput | OwnerRelationCreateOrConnectWithoutOwnerCooperationInput[]
    upsert?: OwnerRelationUpsertWithWhereUniqueWithoutOwnerCooperationInput | OwnerRelationUpsertWithWhereUniqueWithoutOwnerCooperationInput[]
    createMany?: OwnerRelationCreateManyOwnerCooperationInputEnvelope
    set?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    disconnect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    delete?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    update?: OwnerRelationUpdateWithWhereUniqueWithoutOwnerCooperationInput | OwnerRelationUpdateWithWhereUniqueWithoutOwnerCooperationInput[]
    updateMany?: OwnerRelationUpdateManyWithWhereWithoutOwnerCooperationInput | OwnerRelationUpdateManyWithWhereWithoutOwnerCooperationInput[]
    deleteMany?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
  }

  export type OwnerRelationUncheckedUpdateManyWithoutOwnerCooperationNestedInput = {
    create?: XOR<OwnerRelationCreateWithoutOwnerCooperationInput, OwnerRelationUncheckedCreateWithoutOwnerCooperationInput> | OwnerRelationCreateWithoutOwnerCooperationInput[] | OwnerRelationUncheckedCreateWithoutOwnerCooperationInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutOwnerCooperationInput | OwnerRelationCreateOrConnectWithoutOwnerCooperationInput[]
    upsert?: OwnerRelationUpsertWithWhereUniqueWithoutOwnerCooperationInput | OwnerRelationUpsertWithWhereUniqueWithoutOwnerCooperationInput[]
    createMany?: OwnerRelationCreateManyOwnerCooperationInputEnvelope
    set?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    disconnect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    delete?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    update?: OwnerRelationUpdateWithWhereUniqueWithoutOwnerCooperationInput | OwnerRelationUpdateWithWhereUniqueWithoutOwnerCooperationInput[]
    updateMany?: OwnerRelationUpdateManyWithWhereWithoutOwnerCooperationInput | OwnerRelationUpdateManyWithWhereWithoutOwnerCooperationInput[]
    deleteMany?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
  }

  export type OwnerRelationCreateNestedManyWithoutRelationshipTypeInput = {
    create?: XOR<OwnerRelationCreateWithoutRelationshipTypeInput, OwnerRelationUncheckedCreateWithoutRelationshipTypeInput> | OwnerRelationCreateWithoutRelationshipTypeInput[] | OwnerRelationUncheckedCreateWithoutRelationshipTypeInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutRelationshipTypeInput | OwnerRelationCreateOrConnectWithoutRelationshipTypeInput[]
    createMany?: OwnerRelationCreateManyRelationshipTypeInputEnvelope
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
  }

  export type OwnerRelationUncheckedCreateNestedManyWithoutRelationshipTypeInput = {
    create?: XOR<OwnerRelationCreateWithoutRelationshipTypeInput, OwnerRelationUncheckedCreateWithoutRelationshipTypeInput> | OwnerRelationCreateWithoutRelationshipTypeInput[] | OwnerRelationUncheckedCreateWithoutRelationshipTypeInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutRelationshipTypeInput | OwnerRelationCreateOrConnectWithoutRelationshipTypeInput[]
    createMany?: OwnerRelationCreateManyRelationshipTypeInputEnvelope
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
  }

  export type OwnerRelationUpdateManyWithoutRelationshipTypeNestedInput = {
    create?: XOR<OwnerRelationCreateWithoutRelationshipTypeInput, OwnerRelationUncheckedCreateWithoutRelationshipTypeInput> | OwnerRelationCreateWithoutRelationshipTypeInput[] | OwnerRelationUncheckedCreateWithoutRelationshipTypeInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutRelationshipTypeInput | OwnerRelationCreateOrConnectWithoutRelationshipTypeInput[]
    upsert?: OwnerRelationUpsertWithWhereUniqueWithoutRelationshipTypeInput | OwnerRelationUpsertWithWhereUniqueWithoutRelationshipTypeInput[]
    createMany?: OwnerRelationCreateManyRelationshipTypeInputEnvelope
    set?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    disconnect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    delete?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    update?: OwnerRelationUpdateWithWhereUniqueWithoutRelationshipTypeInput | OwnerRelationUpdateWithWhereUniqueWithoutRelationshipTypeInput[]
    updateMany?: OwnerRelationUpdateManyWithWhereWithoutRelationshipTypeInput | OwnerRelationUpdateManyWithWhereWithoutRelationshipTypeInput[]
    deleteMany?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
  }

  export type OwnerRelationUncheckedUpdateManyWithoutRelationshipTypeNestedInput = {
    create?: XOR<OwnerRelationCreateWithoutRelationshipTypeInput, OwnerRelationUncheckedCreateWithoutRelationshipTypeInput> | OwnerRelationCreateWithoutRelationshipTypeInput[] | OwnerRelationUncheckedCreateWithoutRelationshipTypeInput[]
    connectOrCreate?: OwnerRelationCreateOrConnectWithoutRelationshipTypeInput | OwnerRelationCreateOrConnectWithoutRelationshipTypeInput[]
    upsert?: OwnerRelationUpsertWithWhereUniqueWithoutRelationshipTypeInput | OwnerRelationUpsertWithWhereUniqueWithoutRelationshipTypeInput[]
    createMany?: OwnerRelationCreateManyRelationshipTypeInputEnvelope
    set?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    disconnect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    delete?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    connect?: OwnerRelationWhereUniqueInput | OwnerRelationWhereUniqueInput[]
    update?: OwnerRelationUpdateWithWhereUniqueWithoutRelationshipTypeInput | OwnerRelationUpdateWithWhereUniqueWithoutRelationshipTypeInput[]
    updateMany?: OwnerRelationUpdateManyWithWhereWithoutRelationshipTypeInput | OwnerRelationUpdateManyWithWhereWithoutRelationshipTypeInput[]
    deleteMany?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
  }

  export type OwnerShipCreateNestedOneWithoutOwnerRelationInput = {
    create?: XOR<OwnerShipCreateWithoutOwnerRelationInput, OwnerShipUncheckedCreateWithoutOwnerRelationInput>
    connectOrCreate?: OwnerShipCreateOrConnectWithoutOwnerRelationInput
    connect?: OwnerShipWhereUniqueInput
  }

  export type ReasonDeletingCreateNestedOneWithoutOwnerRelationInput = {
    create?: XOR<ReasonDeletingCreateWithoutOwnerRelationInput, ReasonDeletingUncheckedCreateWithoutOwnerRelationInput>
    connectOrCreate?: ReasonDeletingCreateOrConnectWithoutOwnerRelationInput
    connect?: ReasonDeletingWhereUniqueInput
  }

  export type OwnerCooperationCreateNestedOneWithoutOwnerRelationInput = {
    create?: XOR<OwnerCooperationCreateWithoutOwnerRelationInput, OwnerCooperationUncheckedCreateWithoutOwnerRelationInput>
    connectOrCreate?: OwnerCooperationCreateOrConnectWithoutOwnerRelationInput
    connect?: OwnerCooperationWhereUniqueInput
  }

  export type RelationshipTypeCreateNestedOneWithoutOwnerRelationInput = {
    create?: XOR<RelationshipTypeCreateWithoutOwnerRelationInput, RelationshipTypeUncheckedCreateWithoutOwnerRelationInput>
    connectOrCreate?: RelationshipTypeCreateOrConnectWithoutOwnerRelationInput
    connect?: RelationshipTypeWhereUniqueInput
  }

  export type OwnerShipUpdateOneWithoutOwnerRelationNestedInput = {
    create?: XOR<OwnerShipCreateWithoutOwnerRelationInput, OwnerShipUncheckedCreateWithoutOwnerRelationInput>
    connectOrCreate?: OwnerShipCreateOrConnectWithoutOwnerRelationInput
    upsert?: OwnerShipUpsertWithoutOwnerRelationInput
    disconnect?: OwnerShipWhereInput | boolean
    delete?: OwnerShipWhereInput | boolean
    connect?: OwnerShipWhereUniqueInput
    update?: XOR<XOR<OwnerShipUpdateToOneWithWhereWithoutOwnerRelationInput, OwnerShipUpdateWithoutOwnerRelationInput>, OwnerShipUncheckedUpdateWithoutOwnerRelationInput>
  }

  export type ReasonDeletingUpdateOneWithoutOwnerRelationNestedInput = {
    create?: XOR<ReasonDeletingCreateWithoutOwnerRelationInput, ReasonDeletingUncheckedCreateWithoutOwnerRelationInput>
    connectOrCreate?: ReasonDeletingCreateOrConnectWithoutOwnerRelationInput
    upsert?: ReasonDeletingUpsertWithoutOwnerRelationInput
    disconnect?: ReasonDeletingWhereInput | boolean
    delete?: ReasonDeletingWhereInput | boolean
    connect?: ReasonDeletingWhereUniqueInput
    update?: XOR<XOR<ReasonDeletingUpdateToOneWithWhereWithoutOwnerRelationInput, ReasonDeletingUpdateWithoutOwnerRelationInput>, ReasonDeletingUncheckedUpdateWithoutOwnerRelationInput>
  }

  export type OwnerCooperationUpdateOneWithoutOwnerRelationNestedInput = {
    create?: XOR<OwnerCooperationCreateWithoutOwnerRelationInput, OwnerCooperationUncheckedCreateWithoutOwnerRelationInput>
    connectOrCreate?: OwnerCooperationCreateOrConnectWithoutOwnerRelationInput
    upsert?: OwnerCooperationUpsertWithoutOwnerRelationInput
    disconnect?: OwnerCooperationWhereInput | boolean
    delete?: OwnerCooperationWhereInput | boolean
    connect?: OwnerCooperationWhereUniqueInput
    update?: XOR<XOR<OwnerCooperationUpdateToOneWithWhereWithoutOwnerRelationInput, OwnerCooperationUpdateWithoutOwnerRelationInput>, OwnerCooperationUncheckedUpdateWithoutOwnerRelationInput>
  }

  export type RelationshipTypeUpdateOneWithoutOwnerRelationNestedInput = {
    create?: XOR<RelationshipTypeCreateWithoutOwnerRelationInput, RelationshipTypeUncheckedCreateWithoutOwnerRelationInput>
    connectOrCreate?: RelationshipTypeCreateOrConnectWithoutOwnerRelationInput
    upsert?: RelationshipTypeUpsertWithoutOwnerRelationInput
    disconnect?: RelationshipTypeWhereInput | boolean
    delete?: RelationshipTypeWhereInput | boolean
    connect?: RelationshipTypeWhereUniqueInput
    update?: XOR<XOR<RelationshipTypeUpdateToOneWithWhereWithoutOwnerRelationInput, RelationshipTypeUpdateWithoutOwnerRelationInput>, RelationshipTypeUncheckedUpdateWithoutOwnerRelationInput>
  }

  export type AddressCreateNestedManyWithoutRegionInput = {
    create?: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput> | AddressCreateWithoutRegionInput[] | AddressUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutRegionInput | AddressCreateOrConnectWithoutRegionInput[]
    createMany?: AddressCreateManyRegionInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type DistrictCreateNestedManyWithoutRegionInput = {
    create?: XOR<DistrictCreateWithoutRegionInput, DistrictUncheckedCreateWithoutRegionInput> | DistrictCreateWithoutRegionInput[] | DistrictUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutRegionInput | DistrictCreateOrConnectWithoutRegionInput[]
    createMany?: DistrictCreateManyRegionInputEnvelope
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput> | AddressCreateWithoutRegionInput[] | AddressUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutRegionInput | AddressCreateOrConnectWithoutRegionInput[]
    createMany?: AddressCreateManyRegionInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type DistrictUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<DistrictCreateWithoutRegionInput, DistrictUncheckedCreateWithoutRegionInput> | DistrictCreateWithoutRegionInput[] | DistrictUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutRegionInput | DistrictCreateOrConnectWithoutRegionInput[]
    createMany?: DistrictCreateManyRegionInputEnvelope
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutRegionNestedInput = {
    create?: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput> | AddressCreateWithoutRegionInput[] | AddressUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutRegionInput | AddressCreateOrConnectWithoutRegionInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutRegionInput | AddressUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: AddressCreateManyRegionInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutRegionInput | AddressUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutRegionInput | AddressUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type DistrictUpdateManyWithoutRegionNestedInput = {
    create?: XOR<DistrictCreateWithoutRegionInput, DistrictUncheckedCreateWithoutRegionInput> | DistrictCreateWithoutRegionInput[] | DistrictUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutRegionInput | DistrictCreateOrConnectWithoutRegionInput[]
    upsert?: DistrictUpsertWithWhereUniqueWithoutRegionInput | DistrictUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: DistrictCreateManyRegionInputEnvelope
    set?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    disconnect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    delete?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    update?: DistrictUpdateWithWhereUniqueWithoutRegionInput | DistrictUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: DistrictUpdateManyWithWhereWithoutRegionInput | DistrictUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput> | AddressCreateWithoutRegionInput[] | AddressUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutRegionInput | AddressCreateOrConnectWithoutRegionInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutRegionInput | AddressUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: AddressCreateManyRegionInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutRegionInput | AddressUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutRegionInput | AddressUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type DistrictUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<DistrictCreateWithoutRegionInput, DistrictUncheckedCreateWithoutRegionInput> | DistrictCreateWithoutRegionInput[] | DistrictUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DistrictCreateOrConnectWithoutRegionInput | DistrictCreateOrConnectWithoutRegionInput[]
    upsert?: DistrictUpsertWithWhereUniqueWithoutRegionInput | DistrictUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: DistrictCreateManyRegionInputEnvelope
    set?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    disconnect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    delete?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    connect?: DistrictWhereUniqueInput | DistrictWhereUniqueInput[]
    update?: DistrictUpdateWithWhereUniqueWithoutRegionInput | DistrictUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: DistrictUpdateManyWithWhereWithoutRegionInput | DistrictUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
  }

  export type AddressCreateNestedManyWithoutDistrictInput = {
    create?: XOR<AddressCreateWithoutDistrictInput, AddressUncheckedCreateWithoutDistrictInput> | AddressCreateWithoutDistrictInput[] | AddressUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutDistrictInput | AddressCreateOrConnectWithoutDistrictInput[]
    createMany?: AddressCreateManyDistrictInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type RegionCreateNestedOneWithoutDistrictInput = {
    create?: XOR<RegionCreateWithoutDistrictInput, RegionUncheckedCreateWithoutDistrictInput>
    connectOrCreate?: RegionCreateOrConnectWithoutDistrictInput
    connect?: RegionWhereUniqueInput
  }

  export type AddressUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<AddressCreateWithoutDistrictInput, AddressUncheckedCreateWithoutDistrictInput> | AddressCreateWithoutDistrictInput[] | AddressUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutDistrictInput | AddressCreateOrConnectWithoutDistrictInput[]
    createMany?: AddressCreateManyDistrictInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<AddressCreateWithoutDistrictInput, AddressUncheckedCreateWithoutDistrictInput> | AddressCreateWithoutDistrictInput[] | AddressUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutDistrictInput | AddressCreateOrConnectWithoutDistrictInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutDistrictInput | AddressUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: AddressCreateManyDistrictInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutDistrictInput | AddressUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutDistrictInput | AddressUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type RegionUpdateOneWithoutDistrictNestedInput = {
    create?: XOR<RegionCreateWithoutDistrictInput, RegionUncheckedCreateWithoutDistrictInput>
    connectOrCreate?: RegionCreateOrConnectWithoutDistrictInput
    upsert?: RegionUpsertWithoutDistrictInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutDistrictInput, RegionUpdateWithoutDistrictInput>, RegionUncheckedUpdateWithoutDistrictInput>
  }

  export type AddressUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<AddressCreateWithoutDistrictInput, AddressUncheckedCreateWithoutDistrictInput> | AddressCreateWithoutDistrictInput[] | AddressUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutDistrictInput | AddressCreateOrConnectWithoutDistrictInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutDistrictInput | AddressUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: AddressCreateManyDistrictInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutDistrictInput | AddressUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutDistrictInput | AddressUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressCreateNestedManyWithoutAreaInput = {
    create?: XOR<AddressCreateWithoutAreaInput, AddressUncheckedCreateWithoutAreaInput> | AddressCreateWithoutAreaInput[] | AddressUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutAreaInput | AddressCreateOrConnectWithoutAreaInput[]
    createMany?: AddressCreateManyAreaInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<AddressCreateWithoutAreaInput, AddressUncheckedCreateWithoutAreaInput> | AddressCreateWithoutAreaInput[] | AddressUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutAreaInput | AddressCreateOrConnectWithoutAreaInput[]
    createMany?: AddressCreateManyAreaInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutAreaNestedInput = {
    create?: XOR<AddressCreateWithoutAreaInput, AddressUncheckedCreateWithoutAreaInput> | AddressCreateWithoutAreaInput[] | AddressUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutAreaInput | AddressCreateOrConnectWithoutAreaInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutAreaInput | AddressUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: AddressCreateManyAreaInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutAreaInput | AddressUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutAreaInput | AddressUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<AddressCreateWithoutAreaInput, AddressUncheckedCreateWithoutAreaInput> | AddressCreateWithoutAreaInput[] | AddressUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutAreaInput | AddressCreateOrConnectWithoutAreaInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutAreaInput | AddressUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: AddressCreateManyAreaInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutAreaInput | AddressUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutAreaInput | AddressUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressCreateNestedManyWithoutMahallaInput = {
    create?: XOR<AddressCreateWithoutMahallaInput, AddressUncheckedCreateWithoutMahallaInput> | AddressCreateWithoutMahallaInput[] | AddressUncheckedCreateWithoutMahallaInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutMahallaInput | AddressCreateOrConnectWithoutMahallaInput[]
    createMany?: AddressCreateManyMahallaInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutMahallaInput = {
    create?: XOR<AddressCreateWithoutMahallaInput, AddressUncheckedCreateWithoutMahallaInput> | AddressCreateWithoutMahallaInput[] | AddressUncheckedCreateWithoutMahallaInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutMahallaInput | AddressCreateOrConnectWithoutMahallaInput[]
    createMany?: AddressCreateManyMahallaInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutMahallaNestedInput = {
    create?: XOR<AddressCreateWithoutMahallaInput, AddressUncheckedCreateWithoutMahallaInput> | AddressCreateWithoutMahallaInput[] | AddressUncheckedCreateWithoutMahallaInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutMahallaInput | AddressCreateOrConnectWithoutMahallaInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutMahallaInput | AddressUpsertWithWhereUniqueWithoutMahallaInput[]
    createMany?: AddressCreateManyMahallaInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutMahallaInput | AddressUpdateWithWhereUniqueWithoutMahallaInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutMahallaInput | AddressUpdateManyWithWhereWithoutMahallaInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutMahallaNestedInput = {
    create?: XOR<AddressCreateWithoutMahallaInput, AddressUncheckedCreateWithoutMahallaInput> | AddressCreateWithoutMahallaInput[] | AddressUncheckedCreateWithoutMahallaInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutMahallaInput | AddressCreateOrConnectWithoutMahallaInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutMahallaInput | AddressUpsertWithWhereUniqueWithoutMahallaInput[]
    createMany?: AddressCreateManyMahallaInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutMahallaInput | AddressUpdateWithWhereUniqueWithoutMahallaInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutMahallaInput | AddressUpdateManyWithWhereWithoutMahallaInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressCreateNestedManyWithoutStreetInput = {
    create?: XOR<AddressCreateWithoutStreetInput, AddressUncheckedCreateWithoutStreetInput> | AddressCreateWithoutStreetInput[] | AddressUncheckedCreateWithoutStreetInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutStreetInput | AddressCreateOrConnectWithoutStreetInput[]
    createMany?: AddressCreateManyStreetInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutStreetInput = {
    create?: XOR<AddressCreateWithoutStreetInput, AddressUncheckedCreateWithoutStreetInput> | AddressCreateWithoutStreetInput[] | AddressUncheckedCreateWithoutStreetInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutStreetInput | AddressCreateOrConnectWithoutStreetInput[]
    createMany?: AddressCreateManyStreetInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutStreetNestedInput = {
    create?: XOR<AddressCreateWithoutStreetInput, AddressUncheckedCreateWithoutStreetInput> | AddressCreateWithoutStreetInput[] | AddressUncheckedCreateWithoutStreetInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutStreetInput | AddressCreateOrConnectWithoutStreetInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutStreetInput | AddressUpsertWithWhereUniqueWithoutStreetInput[]
    createMany?: AddressCreateManyStreetInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutStreetInput | AddressUpdateWithWhereUniqueWithoutStreetInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutStreetInput | AddressUpdateManyWithWhereWithoutStreetInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutStreetNestedInput = {
    create?: XOR<AddressCreateWithoutStreetInput, AddressUncheckedCreateWithoutStreetInput> | AddressCreateWithoutStreetInput[] | AddressUncheckedCreateWithoutStreetInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutStreetInput | AddressCreateOrConnectWithoutStreetInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutStreetInput | AddressUpsertWithWhereUniqueWithoutStreetInput[]
    createMany?: AddressCreateManyStreetInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutStreetInput | AddressUpdateWithWhereUniqueWithoutStreetInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutStreetInput | AddressUpdateManyWithWhereWithoutStreetInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressCreateNestedManyWithoutMetroInput = {
    create?: XOR<AddressCreateWithoutMetroInput, AddressUncheckedCreateWithoutMetroInput> | AddressCreateWithoutMetroInput[] | AddressUncheckedCreateWithoutMetroInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutMetroInput | AddressCreateOrConnectWithoutMetroInput[]
    createMany?: AddressCreateManyMetroInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutMetroInput = {
    create?: XOR<AddressCreateWithoutMetroInput, AddressUncheckedCreateWithoutMetroInput> | AddressCreateWithoutMetroInput[] | AddressUncheckedCreateWithoutMetroInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutMetroInput | AddressCreateOrConnectWithoutMetroInput[]
    createMany?: AddressCreateManyMetroInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutMetroNestedInput = {
    create?: XOR<AddressCreateWithoutMetroInput, AddressUncheckedCreateWithoutMetroInput> | AddressCreateWithoutMetroInput[] | AddressUncheckedCreateWithoutMetroInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutMetroInput | AddressCreateOrConnectWithoutMetroInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutMetroInput | AddressUpsertWithWhereUniqueWithoutMetroInput[]
    createMany?: AddressCreateManyMetroInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutMetroInput | AddressUpdateWithWhereUniqueWithoutMetroInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutMetroInput | AddressUpdateManyWithWhereWithoutMetroInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutMetroNestedInput = {
    create?: XOR<AddressCreateWithoutMetroInput, AddressUncheckedCreateWithoutMetroInput> | AddressCreateWithoutMetroInput[] | AddressUncheckedCreateWithoutMetroInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutMetroInput | AddressCreateOrConnectWithoutMetroInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutMetroInput | AddressUpsertWithWhereUniqueWithoutMetroInput[]
    createMany?: AddressCreateManyMetroInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutMetroInput | AddressUpdateWithWhereUniqueWithoutMetroInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutMetroInput | AddressUpdateManyWithWhereWithoutMetroInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutAddressInput = {
    create?: XOR<RegionCreateWithoutAddressInput, RegionUncheckedCreateWithoutAddressInput>
    connectOrCreate?: RegionCreateOrConnectWithoutAddressInput
    connect?: RegionWhereUniqueInput
  }

  export type DistrictCreateNestedOneWithoutAddressInput = {
    create?: XOR<DistrictCreateWithoutAddressInput, DistrictUncheckedCreateWithoutAddressInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutAddressInput
    connect?: DistrictWhereUniqueInput
  }

  export type AreaCreateNestedOneWithoutAddressInput = {
    create?: XOR<AreaCreateWithoutAddressInput, AreaUncheckedCreateWithoutAddressInput>
    connectOrCreate?: AreaCreateOrConnectWithoutAddressInput
    connect?: AreaWhereUniqueInput
  }

  export type MahallaCreateNestedOneWithoutAddressInput = {
    create?: XOR<MahallaCreateWithoutAddressInput, MahallaUncheckedCreateWithoutAddressInput>
    connectOrCreate?: MahallaCreateOrConnectWithoutAddressInput
    connect?: MahallaWhereUniqueInput
  }

  export type StreetCreateNestedOneWithoutAddressInput = {
    create?: XOR<StreetCreateWithoutAddressInput, StreetUncheckedCreateWithoutAddressInput>
    connectOrCreate?: StreetCreateOrConnectWithoutAddressInput
    connect?: StreetWhereUniqueInput
  }

  export type MetroCreateNestedOneWithoutAddressInput = {
    create?: XOR<MetroCreateWithoutAddressInput, MetroUncheckedCreateWithoutAddressInput>
    connectOrCreate?: MetroCreateOrConnectWithoutAddressInput
    connect?: MetroWhereUniqueInput
  }

  export type RegionUpdateOneWithoutAddressNestedInput = {
    create?: XOR<RegionCreateWithoutAddressInput, RegionUncheckedCreateWithoutAddressInput>
    connectOrCreate?: RegionCreateOrConnectWithoutAddressInput
    upsert?: RegionUpsertWithoutAddressInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutAddressInput, RegionUpdateWithoutAddressInput>, RegionUncheckedUpdateWithoutAddressInput>
  }

  export type DistrictUpdateOneWithoutAddressNestedInput = {
    create?: XOR<DistrictCreateWithoutAddressInput, DistrictUncheckedCreateWithoutAddressInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutAddressInput
    upsert?: DistrictUpsertWithoutAddressInput
    disconnect?: DistrictWhereInput | boolean
    delete?: DistrictWhereInput | boolean
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutAddressInput, DistrictUpdateWithoutAddressInput>, DistrictUncheckedUpdateWithoutAddressInput>
  }

  export type AreaUpdateOneWithoutAddressNestedInput = {
    create?: XOR<AreaCreateWithoutAddressInput, AreaUncheckedCreateWithoutAddressInput>
    connectOrCreate?: AreaCreateOrConnectWithoutAddressInput
    upsert?: AreaUpsertWithoutAddressInput
    disconnect?: AreaWhereInput | boolean
    delete?: AreaWhereInput | boolean
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutAddressInput, AreaUpdateWithoutAddressInput>, AreaUncheckedUpdateWithoutAddressInput>
  }

  export type MahallaUpdateOneWithoutAddressNestedInput = {
    create?: XOR<MahallaCreateWithoutAddressInput, MahallaUncheckedCreateWithoutAddressInput>
    connectOrCreate?: MahallaCreateOrConnectWithoutAddressInput
    upsert?: MahallaUpsertWithoutAddressInput
    disconnect?: MahallaWhereInput | boolean
    delete?: MahallaWhereInput | boolean
    connect?: MahallaWhereUniqueInput
    update?: XOR<XOR<MahallaUpdateToOneWithWhereWithoutAddressInput, MahallaUpdateWithoutAddressInput>, MahallaUncheckedUpdateWithoutAddressInput>
  }

  export type StreetUpdateOneWithoutAddressNestedInput = {
    create?: XOR<StreetCreateWithoutAddressInput, StreetUncheckedCreateWithoutAddressInput>
    connectOrCreate?: StreetCreateOrConnectWithoutAddressInput
    upsert?: StreetUpsertWithoutAddressInput
    disconnect?: StreetWhereInput | boolean
    delete?: StreetWhereInput | boolean
    connect?: StreetWhereUniqueInput
    update?: XOR<XOR<StreetUpdateToOneWithWhereWithoutAddressInput, StreetUpdateWithoutAddressInput>, StreetUncheckedUpdateWithoutAddressInput>
  }

  export type MetroUpdateOneWithoutAddressNestedInput = {
    create?: XOR<MetroCreateWithoutAddressInput, MetroUncheckedCreateWithoutAddressInput>
    connectOrCreate?: MetroCreateOrConnectWithoutAddressInput
    upsert?: MetroUpsertWithoutAddressInput
    disconnect?: MetroWhereInput | boolean
    delete?: MetroWhereInput | boolean
    connect?: MetroWhereUniqueInput
    update?: XOR<XOR<MetroUpdateToOneWithWhereWithoutAddressInput, MetroUpdateWithoutAddressInput>, MetroUncheckedUpdateWithoutAddressInput>
  }

  export type BuildingCharacterCreateNestedManyWithoutBuildingConditionInput = {
    create?: XOR<BuildingCharacterCreateWithoutBuildingConditionInput, BuildingCharacterUncheckedCreateWithoutBuildingConditionInput> | BuildingCharacterCreateWithoutBuildingConditionInput[] | BuildingCharacterUncheckedCreateWithoutBuildingConditionInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutBuildingConditionInput | BuildingCharacterCreateOrConnectWithoutBuildingConditionInput[]
    createMany?: BuildingCharacterCreateManyBuildingConditionInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUncheckedCreateNestedManyWithoutBuildingConditionInput = {
    create?: XOR<BuildingCharacterCreateWithoutBuildingConditionInput, BuildingCharacterUncheckedCreateWithoutBuildingConditionInput> | BuildingCharacterCreateWithoutBuildingConditionInput[] | BuildingCharacterUncheckedCreateWithoutBuildingConditionInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutBuildingConditionInput | BuildingCharacterCreateOrConnectWithoutBuildingConditionInput[]
    createMany?: BuildingCharacterCreateManyBuildingConditionInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUpdateManyWithoutBuildingConditionNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutBuildingConditionInput, BuildingCharacterUncheckedCreateWithoutBuildingConditionInput> | BuildingCharacterCreateWithoutBuildingConditionInput[] | BuildingCharacterUncheckedCreateWithoutBuildingConditionInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutBuildingConditionInput | BuildingCharacterCreateOrConnectWithoutBuildingConditionInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutBuildingConditionInput | BuildingCharacterUpsertWithWhereUniqueWithoutBuildingConditionInput[]
    createMany?: BuildingCharacterCreateManyBuildingConditionInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutBuildingConditionInput | BuildingCharacterUpdateWithWhereUniqueWithoutBuildingConditionInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutBuildingConditionInput | BuildingCharacterUpdateManyWithWhereWithoutBuildingConditionInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutBuildingConditionNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutBuildingConditionInput, BuildingCharacterUncheckedCreateWithoutBuildingConditionInput> | BuildingCharacterCreateWithoutBuildingConditionInput[] | BuildingCharacterUncheckedCreateWithoutBuildingConditionInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutBuildingConditionInput | BuildingCharacterCreateOrConnectWithoutBuildingConditionInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutBuildingConditionInput | BuildingCharacterUpsertWithWhereUniqueWithoutBuildingConditionInput[]
    createMany?: BuildingCharacterCreateManyBuildingConditionInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutBuildingConditionInput | BuildingCharacterUpdateWithWhereUniqueWithoutBuildingConditionInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutBuildingConditionInput | BuildingCharacterUpdateManyWithWhereWithoutBuildingConditionInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterCreateNestedManyWithoutBuildingSeriaInput = {
    create?: XOR<BuildingCharacterCreateWithoutBuildingSeriaInput, BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput> | BuildingCharacterCreateWithoutBuildingSeriaInput[] | BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput | BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput[]
    createMany?: BuildingCharacterCreateManyBuildingSeriaInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUncheckedCreateNestedManyWithoutBuildingSeriaInput = {
    create?: XOR<BuildingCharacterCreateWithoutBuildingSeriaInput, BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput> | BuildingCharacterCreateWithoutBuildingSeriaInput[] | BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput | BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput[]
    createMany?: BuildingCharacterCreateManyBuildingSeriaInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUpdateManyWithoutBuildingSeriaNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutBuildingSeriaInput, BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput> | BuildingCharacterCreateWithoutBuildingSeriaInput[] | BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput | BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutBuildingSeriaInput | BuildingCharacterUpsertWithWhereUniqueWithoutBuildingSeriaInput[]
    createMany?: BuildingCharacterCreateManyBuildingSeriaInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutBuildingSeriaInput | BuildingCharacterUpdateWithWhereUniqueWithoutBuildingSeriaInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutBuildingSeriaInput | BuildingCharacterUpdateManyWithWhereWithoutBuildingSeriaInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutBuildingSeriaNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutBuildingSeriaInput, BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput> | BuildingCharacterCreateWithoutBuildingSeriaInput[] | BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput | BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutBuildingSeriaInput | BuildingCharacterUpsertWithWhereUniqueWithoutBuildingSeriaInput[]
    createMany?: BuildingCharacterCreateManyBuildingSeriaInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutBuildingSeriaInput | BuildingCharacterUpdateWithWhereUniqueWithoutBuildingSeriaInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutBuildingSeriaInput | BuildingCharacterUpdateManyWithWhereWithoutBuildingSeriaInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterCreateNestedManyWithoutWallMaterialInput = {
    create?: XOR<BuildingCharacterCreateWithoutWallMaterialInput, BuildingCharacterUncheckedCreateWithoutWallMaterialInput> | BuildingCharacterCreateWithoutWallMaterialInput[] | BuildingCharacterUncheckedCreateWithoutWallMaterialInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutWallMaterialInput | BuildingCharacterCreateOrConnectWithoutWallMaterialInput[]
    createMany?: BuildingCharacterCreateManyWallMaterialInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUncheckedCreateNestedManyWithoutWallMaterialInput = {
    create?: XOR<BuildingCharacterCreateWithoutWallMaterialInput, BuildingCharacterUncheckedCreateWithoutWallMaterialInput> | BuildingCharacterCreateWithoutWallMaterialInput[] | BuildingCharacterUncheckedCreateWithoutWallMaterialInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutWallMaterialInput | BuildingCharacterCreateOrConnectWithoutWallMaterialInput[]
    createMany?: BuildingCharacterCreateManyWallMaterialInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUpdateManyWithoutWallMaterialNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutWallMaterialInput, BuildingCharacterUncheckedCreateWithoutWallMaterialInput> | BuildingCharacterCreateWithoutWallMaterialInput[] | BuildingCharacterUncheckedCreateWithoutWallMaterialInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutWallMaterialInput | BuildingCharacterCreateOrConnectWithoutWallMaterialInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutWallMaterialInput | BuildingCharacterUpsertWithWhereUniqueWithoutWallMaterialInput[]
    createMany?: BuildingCharacterCreateManyWallMaterialInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutWallMaterialInput | BuildingCharacterUpdateWithWhereUniqueWithoutWallMaterialInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutWallMaterialInput | BuildingCharacterUpdateManyWithWhereWithoutWallMaterialInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutWallMaterialNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutWallMaterialInput, BuildingCharacterUncheckedCreateWithoutWallMaterialInput> | BuildingCharacterCreateWithoutWallMaterialInput[] | BuildingCharacterUncheckedCreateWithoutWallMaterialInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutWallMaterialInput | BuildingCharacterCreateOrConnectWithoutWallMaterialInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutWallMaterialInput | BuildingCharacterUpsertWithWhereUniqueWithoutWallMaterialInput[]
    createMany?: BuildingCharacterCreateManyWallMaterialInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutWallMaterialInput | BuildingCharacterUpdateWithWhereUniqueWithoutWallMaterialInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutWallMaterialInput | BuildingCharacterUpdateManyWithWhereWithoutWallMaterialInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterCreateNestedManyWithoutOverlapsInput = {
    create?: XOR<BuildingCharacterCreateWithoutOverlapsInput, BuildingCharacterUncheckedCreateWithoutOverlapsInput> | BuildingCharacterCreateWithoutOverlapsInput[] | BuildingCharacterUncheckedCreateWithoutOverlapsInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutOverlapsInput | BuildingCharacterCreateOrConnectWithoutOverlapsInput[]
    createMany?: BuildingCharacterCreateManyOverlapsInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUncheckedCreateNestedManyWithoutOverlapsInput = {
    create?: XOR<BuildingCharacterCreateWithoutOverlapsInput, BuildingCharacterUncheckedCreateWithoutOverlapsInput> | BuildingCharacterCreateWithoutOverlapsInput[] | BuildingCharacterUncheckedCreateWithoutOverlapsInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutOverlapsInput | BuildingCharacterCreateOrConnectWithoutOverlapsInput[]
    createMany?: BuildingCharacterCreateManyOverlapsInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUpdateManyWithoutOverlapsNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutOverlapsInput, BuildingCharacterUncheckedCreateWithoutOverlapsInput> | BuildingCharacterCreateWithoutOverlapsInput[] | BuildingCharacterUncheckedCreateWithoutOverlapsInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutOverlapsInput | BuildingCharacterCreateOrConnectWithoutOverlapsInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutOverlapsInput | BuildingCharacterUpsertWithWhereUniqueWithoutOverlapsInput[]
    createMany?: BuildingCharacterCreateManyOverlapsInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutOverlapsInput | BuildingCharacterUpdateWithWhereUniqueWithoutOverlapsInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutOverlapsInput | BuildingCharacterUpdateManyWithWhereWithoutOverlapsInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutOverlapsNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutOverlapsInput, BuildingCharacterUncheckedCreateWithoutOverlapsInput> | BuildingCharacterCreateWithoutOverlapsInput[] | BuildingCharacterUncheckedCreateWithoutOverlapsInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutOverlapsInput | BuildingCharacterCreateOrConnectWithoutOverlapsInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutOverlapsInput | BuildingCharacterUpsertWithWhereUniqueWithoutOverlapsInput[]
    createMany?: BuildingCharacterCreateManyOverlapsInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutOverlapsInput | BuildingCharacterUpdateWithWhereUniqueWithoutOverlapsInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutOverlapsInput | BuildingCharacterUpdateManyWithWhereWithoutOverlapsInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterCreateNestedManyWithoutWaterSupplyInput = {
    create?: XOR<BuildingCharacterCreateWithoutWaterSupplyInput, BuildingCharacterUncheckedCreateWithoutWaterSupplyInput> | BuildingCharacterCreateWithoutWaterSupplyInput[] | BuildingCharacterUncheckedCreateWithoutWaterSupplyInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutWaterSupplyInput | BuildingCharacterCreateOrConnectWithoutWaterSupplyInput[]
    createMany?: BuildingCharacterCreateManyWaterSupplyInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUncheckedCreateNestedManyWithoutWaterSupplyInput = {
    create?: XOR<BuildingCharacterCreateWithoutWaterSupplyInput, BuildingCharacterUncheckedCreateWithoutWaterSupplyInput> | BuildingCharacterCreateWithoutWaterSupplyInput[] | BuildingCharacterUncheckedCreateWithoutWaterSupplyInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutWaterSupplyInput | BuildingCharacterCreateOrConnectWithoutWaterSupplyInput[]
    createMany?: BuildingCharacterCreateManyWaterSupplyInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUpdateManyWithoutWaterSupplyNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutWaterSupplyInput, BuildingCharacterUncheckedCreateWithoutWaterSupplyInput> | BuildingCharacterCreateWithoutWaterSupplyInput[] | BuildingCharacterUncheckedCreateWithoutWaterSupplyInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutWaterSupplyInput | BuildingCharacterCreateOrConnectWithoutWaterSupplyInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutWaterSupplyInput | BuildingCharacterUpsertWithWhereUniqueWithoutWaterSupplyInput[]
    createMany?: BuildingCharacterCreateManyWaterSupplyInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutWaterSupplyInput | BuildingCharacterUpdateWithWhereUniqueWithoutWaterSupplyInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutWaterSupplyInput | BuildingCharacterUpdateManyWithWhereWithoutWaterSupplyInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutWaterSupplyNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutWaterSupplyInput, BuildingCharacterUncheckedCreateWithoutWaterSupplyInput> | BuildingCharacterCreateWithoutWaterSupplyInput[] | BuildingCharacterUncheckedCreateWithoutWaterSupplyInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutWaterSupplyInput | BuildingCharacterCreateOrConnectWithoutWaterSupplyInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutWaterSupplyInput | BuildingCharacterUpsertWithWhereUniqueWithoutWaterSupplyInput[]
    createMany?: BuildingCharacterCreateManyWaterSupplyInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutWaterSupplyInput | BuildingCharacterUpdateWithWhereUniqueWithoutWaterSupplyInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutWaterSupplyInput | BuildingCharacterUpdateManyWithWhereWithoutWaterSupplyInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterCreateNestedManyWithoutHeatingSystemInput = {
    create?: XOR<BuildingCharacterCreateWithoutHeatingSystemInput, BuildingCharacterUncheckedCreateWithoutHeatingSystemInput> | BuildingCharacterCreateWithoutHeatingSystemInput[] | BuildingCharacterUncheckedCreateWithoutHeatingSystemInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutHeatingSystemInput | BuildingCharacterCreateOrConnectWithoutHeatingSystemInput[]
    createMany?: BuildingCharacterCreateManyHeatingSystemInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUncheckedCreateNestedManyWithoutHeatingSystemInput = {
    create?: XOR<BuildingCharacterCreateWithoutHeatingSystemInput, BuildingCharacterUncheckedCreateWithoutHeatingSystemInput> | BuildingCharacterCreateWithoutHeatingSystemInput[] | BuildingCharacterUncheckedCreateWithoutHeatingSystemInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutHeatingSystemInput | BuildingCharacterCreateOrConnectWithoutHeatingSystemInput[]
    createMany?: BuildingCharacterCreateManyHeatingSystemInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUpdateManyWithoutHeatingSystemNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutHeatingSystemInput, BuildingCharacterUncheckedCreateWithoutHeatingSystemInput> | BuildingCharacterCreateWithoutHeatingSystemInput[] | BuildingCharacterUncheckedCreateWithoutHeatingSystemInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutHeatingSystemInput | BuildingCharacterCreateOrConnectWithoutHeatingSystemInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutHeatingSystemInput | BuildingCharacterUpsertWithWhereUniqueWithoutHeatingSystemInput[]
    createMany?: BuildingCharacterCreateManyHeatingSystemInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutHeatingSystemInput | BuildingCharacterUpdateWithWhereUniqueWithoutHeatingSystemInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutHeatingSystemInput | BuildingCharacterUpdateManyWithWhereWithoutHeatingSystemInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutHeatingSystemNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutHeatingSystemInput, BuildingCharacterUncheckedCreateWithoutHeatingSystemInput> | BuildingCharacterCreateWithoutHeatingSystemInput[] | BuildingCharacterUncheckedCreateWithoutHeatingSystemInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutHeatingSystemInput | BuildingCharacterCreateOrConnectWithoutHeatingSystemInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutHeatingSystemInput | BuildingCharacterUpsertWithWhereUniqueWithoutHeatingSystemInput[]
    createMany?: BuildingCharacterCreateManyHeatingSystemInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutHeatingSystemInput | BuildingCharacterUpdateWithWhereUniqueWithoutHeatingSystemInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutHeatingSystemInput | BuildingCharacterUpdateManyWithWhereWithoutHeatingSystemInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterCreateNestedManyWithoutParkingInput = {
    create?: XOR<BuildingCharacterCreateWithoutParkingInput, BuildingCharacterUncheckedCreateWithoutParkingInput> | BuildingCharacterCreateWithoutParkingInput[] | BuildingCharacterUncheckedCreateWithoutParkingInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutParkingInput | BuildingCharacterCreateOrConnectWithoutParkingInput[]
    createMany?: BuildingCharacterCreateManyParkingInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUncheckedCreateNestedManyWithoutParkingInput = {
    create?: XOR<BuildingCharacterCreateWithoutParkingInput, BuildingCharacterUncheckedCreateWithoutParkingInput> | BuildingCharacterCreateWithoutParkingInput[] | BuildingCharacterUncheckedCreateWithoutParkingInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutParkingInput | BuildingCharacterCreateOrConnectWithoutParkingInput[]
    createMany?: BuildingCharacterCreateManyParkingInputEnvelope
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
  }

  export type BuildingCharacterUpdateManyWithoutParkingNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutParkingInput, BuildingCharacterUncheckedCreateWithoutParkingInput> | BuildingCharacterCreateWithoutParkingInput[] | BuildingCharacterUncheckedCreateWithoutParkingInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutParkingInput | BuildingCharacterCreateOrConnectWithoutParkingInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutParkingInput | BuildingCharacterUpsertWithWhereUniqueWithoutParkingInput[]
    createMany?: BuildingCharacterCreateManyParkingInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutParkingInput | BuildingCharacterUpdateWithWhereUniqueWithoutParkingInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutParkingInput | BuildingCharacterUpdateManyWithWhereWithoutParkingInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutParkingNestedInput = {
    create?: XOR<BuildingCharacterCreateWithoutParkingInput, BuildingCharacterUncheckedCreateWithoutParkingInput> | BuildingCharacterCreateWithoutParkingInput[] | BuildingCharacterUncheckedCreateWithoutParkingInput[]
    connectOrCreate?: BuildingCharacterCreateOrConnectWithoutParkingInput | BuildingCharacterCreateOrConnectWithoutParkingInput[]
    upsert?: BuildingCharacterUpsertWithWhereUniqueWithoutParkingInput | BuildingCharacterUpsertWithWhereUniqueWithoutParkingInput[]
    createMany?: BuildingCharacterCreateManyParkingInputEnvelope
    set?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    disconnect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    delete?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    connect?: BuildingCharacterWhereUniqueInput | BuildingCharacterWhereUniqueInput[]
    update?: BuildingCharacterUpdateWithWhereUniqueWithoutParkingInput | BuildingCharacterUpdateWithWhereUniqueWithoutParkingInput[]
    updateMany?: BuildingCharacterUpdateManyWithWhereWithoutParkingInput | BuildingCharacterUpdateManyWithWhereWithoutParkingInput[]
    deleteMany?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
  }

  export type BuildingConditionCreateNestedOneWithoutBuildingCharacterInput = {
    create?: XOR<BuildingConditionCreateWithoutBuildingCharacterInput, BuildingConditionUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: BuildingConditionCreateOrConnectWithoutBuildingCharacterInput
    connect?: BuildingConditionWhereUniqueInput
  }

  export type BuildingSeriaCreateNestedOneWithoutBuildingCharacterInput = {
    create?: XOR<BuildingSeriaCreateWithoutBuildingCharacterInput, BuildingSeriaUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: BuildingSeriaCreateOrConnectWithoutBuildingCharacterInput
    connect?: BuildingSeriaWhereUniqueInput
  }

  export type WallMaterialCreateNestedOneWithoutBuildingCharacterInput = {
    create?: XOR<WallMaterialCreateWithoutBuildingCharacterInput, WallMaterialUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: WallMaterialCreateOrConnectWithoutBuildingCharacterInput
    connect?: WallMaterialWhereUniqueInput
  }

  export type OverlapsCreateNestedOneWithoutBuildingCharacterInput = {
    create?: XOR<OverlapsCreateWithoutBuildingCharacterInput, OverlapsUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: OverlapsCreateOrConnectWithoutBuildingCharacterInput
    connect?: OverlapsWhereUniqueInput
  }

  export type WaterSupplyCreateNestedOneWithoutBuildingCharacterInput = {
    create?: XOR<WaterSupplyCreateWithoutBuildingCharacterInput, WaterSupplyUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: WaterSupplyCreateOrConnectWithoutBuildingCharacterInput
    connect?: WaterSupplyWhereUniqueInput
  }

  export type HeatingSystemCreateNestedOneWithoutBuildingCharacterInput = {
    create?: XOR<HeatingSystemCreateWithoutBuildingCharacterInput, HeatingSystemUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: HeatingSystemCreateOrConnectWithoutBuildingCharacterInput
    connect?: HeatingSystemWhereUniqueInput
  }

  export type ParkingCreateNestedOneWithoutBuildingCharacterInput = {
    create?: XOR<ParkingCreateWithoutBuildingCharacterInput, ParkingUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: ParkingCreateOrConnectWithoutBuildingCharacterInput
    connect?: ParkingWhereUniqueInput
  }

  export type BuildingConditionUpdateOneWithoutBuildingCharacterNestedInput = {
    create?: XOR<BuildingConditionCreateWithoutBuildingCharacterInput, BuildingConditionUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: BuildingConditionCreateOrConnectWithoutBuildingCharacterInput
    upsert?: BuildingConditionUpsertWithoutBuildingCharacterInput
    disconnect?: BuildingConditionWhereInput | boolean
    delete?: BuildingConditionWhereInput | boolean
    connect?: BuildingConditionWhereUniqueInput
    update?: XOR<XOR<BuildingConditionUpdateToOneWithWhereWithoutBuildingCharacterInput, BuildingConditionUpdateWithoutBuildingCharacterInput>, BuildingConditionUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type BuildingSeriaUpdateOneWithoutBuildingCharacterNestedInput = {
    create?: XOR<BuildingSeriaCreateWithoutBuildingCharacterInput, BuildingSeriaUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: BuildingSeriaCreateOrConnectWithoutBuildingCharacterInput
    upsert?: BuildingSeriaUpsertWithoutBuildingCharacterInput
    disconnect?: BuildingSeriaWhereInput | boolean
    delete?: BuildingSeriaWhereInput | boolean
    connect?: BuildingSeriaWhereUniqueInput
    update?: XOR<XOR<BuildingSeriaUpdateToOneWithWhereWithoutBuildingCharacterInput, BuildingSeriaUpdateWithoutBuildingCharacterInput>, BuildingSeriaUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type WallMaterialUpdateOneWithoutBuildingCharacterNestedInput = {
    create?: XOR<WallMaterialCreateWithoutBuildingCharacterInput, WallMaterialUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: WallMaterialCreateOrConnectWithoutBuildingCharacterInput
    upsert?: WallMaterialUpsertWithoutBuildingCharacterInput
    disconnect?: WallMaterialWhereInput | boolean
    delete?: WallMaterialWhereInput | boolean
    connect?: WallMaterialWhereUniqueInput
    update?: XOR<XOR<WallMaterialUpdateToOneWithWhereWithoutBuildingCharacterInput, WallMaterialUpdateWithoutBuildingCharacterInput>, WallMaterialUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type OverlapsUpdateOneWithoutBuildingCharacterNestedInput = {
    create?: XOR<OverlapsCreateWithoutBuildingCharacterInput, OverlapsUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: OverlapsCreateOrConnectWithoutBuildingCharacterInput
    upsert?: OverlapsUpsertWithoutBuildingCharacterInput
    disconnect?: OverlapsWhereInput | boolean
    delete?: OverlapsWhereInput | boolean
    connect?: OverlapsWhereUniqueInput
    update?: XOR<XOR<OverlapsUpdateToOneWithWhereWithoutBuildingCharacterInput, OverlapsUpdateWithoutBuildingCharacterInput>, OverlapsUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type WaterSupplyUpdateOneWithoutBuildingCharacterNestedInput = {
    create?: XOR<WaterSupplyCreateWithoutBuildingCharacterInput, WaterSupplyUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: WaterSupplyCreateOrConnectWithoutBuildingCharacterInput
    upsert?: WaterSupplyUpsertWithoutBuildingCharacterInput
    disconnect?: WaterSupplyWhereInput | boolean
    delete?: WaterSupplyWhereInput | boolean
    connect?: WaterSupplyWhereUniqueInput
    update?: XOR<XOR<WaterSupplyUpdateToOneWithWhereWithoutBuildingCharacterInput, WaterSupplyUpdateWithoutBuildingCharacterInput>, WaterSupplyUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type HeatingSystemUpdateOneWithoutBuildingCharacterNestedInput = {
    create?: XOR<HeatingSystemCreateWithoutBuildingCharacterInput, HeatingSystemUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: HeatingSystemCreateOrConnectWithoutBuildingCharacterInput
    upsert?: HeatingSystemUpsertWithoutBuildingCharacterInput
    disconnect?: HeatingSystemWhereInput | boolean
    delete?: HeatingSystemWhereInput | boolean
    connect?: HeatingSystemWhereUniqueInput
    update?: XOR<XOR<HeatingSystemUpdateToOneWithWhereWithoutBuildingCharacterInput, HeatingSystemUpdateWithoutBuildingCharacterInput>, HeatingSystemUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type ParkingUpdateOneWithoutBuildingCharacterNestedInput = {
    create?: XOR<ParkingCreateWithoutBuildingCharacterInput, ParkingUncheckedCreateWithoutBuildingCharacterInput>
    connectOrCreate?: ParkingCreateOrConnectWithoutBuildingCharacterInput
    upsert?: ParkingUpsertWithoutBuildingCharacterInput
    disconnect?: ParkingWhereInput | boolean
    delete?: ParkingWhereInput | boolean
    connect?: ParkingWhereUniqueInput
    update?: XOR<XOR<ParkingUpdateToOneWithWhereWithoutBuildingCharacterInput, ParkingUpdateWithoutBuildingCharacterInput>, ParkingUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ObjectCreateWithoutRealtorInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutRealtorInput = {
    id?: number
    name: string
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutRealtorInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutRealtorInput, ObjectUncheckedCreateWithoutRealtorInput>
  }

  export type ObjectCreateManyRealtorInputEnvelope = {
    data: ObjectCreateManyRealtorInput | ObjectCreateManyRealtorInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithWhereUniqueWithoutRealtorInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutRealtorInput, ObjectUncheckedUpdateWithoutRealtorInput>
    create: XOR<ObjectCreateWithoutRealtorInput, ObjectUncheckedCreateWithoutRealtorInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutRealtorInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutRealtorInput, ObjectUncheckedUpdateWithoutRealtorInput>
  }

  export type ObjectUpdateManyWithWhereWithoutRealtorInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutRealtorInput>
  }

  export type ObjectScalarWhereInput = {
    AND?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
    OR?: ObjectScalarWhereInput[]
    NOT?: ObjectScalarWhereInput | ObjectScalarWhereInput[]
    id?: IntFilter<"Object"> | number
    name?: StringFilter<"Object"> | string
    realtorId?: IntNullableFilter<"Object"> | number | null
    objectTypeId?: IntNullableFilter<"Object"> | number | null
    residenceTypeId?: IntNullableFilter<"Object"> | number | null
    objectCategoryId?: IntNullableFilter<"Object"> | number | null
    objectStatusId?: IntNullableFilter<"Object"> | number | null
    is_studio?: BoolFilter<"Object"> | boolean
    floor?: IntFilter<"Object"> | number
    floors_in_building?: IntFilter<"Object"> | number
    total_area?: FloatFilter<"Object"> | number
    live_area?: FloatFilter<"Object"> | number
    kitchen_area?: FloatFilter<"Object"> | number
    rooms_area?: FloatFilter<"Object"> | number
    price?: FloatFilter<"Object"> | number
    currencyId?: IntNullableFilter<"Object"> | number | null
    price_per_square?: FloatFilter<"Object"> | number
    price_type?: FloatFilter<"Object"> | number
    renovationId?: IntNullableFilter<"Object"> | number | null
    windowSideId?: IntNullableFilter<"Object"> | number | null
    roomTypeId?: IntNullableFilter<"Object"> | number | null
    is_apartment?: BoolFilter<"Object"> | boolean
    is_luxury?: BoolFilter<"Object"> | boolean
    ceiling_height?: FloatFilter<"Object"> | number
    combined_bath_count?: IntFilter<"Object"> | number
    separate_bath_count?: IntFilter<"Object"> | number
    loggia_count?: IntFilter<"Object"> | number
    loggia_description?: StringFilter<"Object"> | string
    balcony_count?: IntFilter<"Object"> | number
    balcony_description?: StringFilter<"Object"> | string
    general_description?: StringFilter<"Object"> | string
    cadastral_number?: IntFilter<"Object"> | number
    document?: StringFilter<"Object"> | string
    layout?: StringFilter<"Object"> | string
    fotos?: StringFilter<"Object"> | string
    online_show?: BoolFilter<"Object"> | boolean
    video?: StringFilter<"Object"> | string
  }

  export type ObjectCreateWithoutObjectTypeInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutObjectTypeInput = {
    id?: number
    name: string
    realtorId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutObjectTypeInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutObjectTypeInput, ObjectUncheckedCreateWithoutObjectTypeInput>
  }

  export type ObjectCreateManyObjectTypeInputEnvelope = {
    data: ObjectCreateManyObjectTypeInput | ObjectCreateManyObjectTypeInput[]
    skipDuplicates?: boolean
  }

  export type ResidenceTypeCreateWithoutObjectTypeInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutResidenceTypeInput
  }

  export type ResidenceTypeUncheckedCreateWithoutObjectTypeInput = {
    id?: number
    name: string
    object?: ObjectUncheckedCreateNestedManyWithoutResidenceTypeInput
  }

  export type ResidenceTypeCreateOrConnectWithoutObjectTypeInput = {
    where: ResidenceTypeWhereUniqueInput
    create: XOR<ResidenceTypeCreateWithoutObjectTypeInput, ResidenceTypeUncheckedCreateWithoutObjectTypeInput>
  }

  export type ResidenceTypeCreateManyObjectTypeInputEnvelope = {
    data: ResidenceTypeCreateManyObjectTypeInput | ResidenceTypeCreateManyObjectTypeInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithWhereUniqueWithoutObjectTypeInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutObjectTypeInput, ObjectUncheckedUpdateWithoutObjectTypeInput>
    create: XOR<ObjectCreateWithoutObjectTypeInput, ObjectUncheckedCreateWithoutObjectTypeInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutObjectTypeInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutObjectTypeInput, ObjectUncheckedUpdateWithoutObjectTypeInput>
  }

  export type ObjectUpdateManyWithWhereWithoutObjectTypeInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutObjectTypeInput>
  }

  export type ResidenceTypeUpsertWithWhereUniqueWithoutObjectTypeInput = {
    where: ResidenceTypeWhereUniqueInput
    update: XOR<ResidenceTypeUpdateWithoutObjectTypeInput, ResidenceTypeUncheckedUpdateWithoutObjectTypeInput>
    create: XOR<ResidenceTypeCreateWithoutObjectTypeInput, ResidenceTypeUncheckedCreateWithoutObjectTypeInput>
  }

  export type ResidenceTypeUpdateWithWhereUniqueWithoutObjectTypeInput = {
    where: ResidenceTypeWhereUniqueInput
    data: XOR<ResidenceTypeUpdateWithoutObjectTypeInput, ResidenceTypeUncheckedUpdateWithoutObjectTypeInput>
  }

  export type ResidenceTypeUpdateManyWithWhereWithoutObjectTypeInput = {
    where: ResidenceTypeScalarWhereInput
    data: XOR<ResidenceTypeUpdateManyMutationInput, ResidenceTypeUncheckedUpdateManyWithoutObjectTypeInput>
  }

  export type ResidenceTypeScalarWhereInput = {
    AND?: ResidenceTypeScalarWhereInput | ResidenceTypeScalarWhereInput[]
    OR?: ResidenceTypeScalarWhereInput[]
    NOT?: ResidenceTypeScalarWhereInput | ResidenceTypeScalarWhereInput[]
    id?: IntFilter<"ResidenceType"> | number
    name?: StringFilter<"ResidenceType"> | string
    objectTypeId?: IntNullableFilter<"ResidenceType"> | number | null
  }

  export type ObjectCreateWithoutResidenceTypeInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutResidenceTypeInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutResidenceTypeInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutResidenceTypeInput, ObjectUncheckedCreateWithoutResidenceTypeInput>
  }

  export type ObjectCreateManyResidenceTypeInputEnvelope = {
    data: ObjectCreateManyResidenceTypeInput | ObjectCreateManyResidenceTypeInput[]
    skipDuplicates?: boolean
  }

  export type ObjectTypeCreateWithoutResidenceTypeInput = {
    name: string
    object?: ObjectCreateNestedManyWithoutObjectTypeInput
  }

  export type ObjectTypeUncheckedCreateWithoutResidenceTypeInput = {
    id?: number
    name: string
    object?: ObjectUncheckedCreateNestedManyWithoutObjectTypeInput
  }

  export type ObjectTypeCreateOrConnectWithoutResidenceTypeInput = {
    where: ObjectTypeWhereUniqueInput
    create: XOR<ObjectTypeCreateWithoutResidenceTypeInput, ObjectTypeUncheckedCreateWithoutResidenceTypeInput>
  }

  export type ObjectUpsertWithWhereUniqueWithoutResidenceTypeInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutResidenceTypeInput, ObjectUncheckedUpdateWithoutResidenceTypeInput>
    create: XOR<ObjectCreateWithoutResidenceTypeInput, ObjectUncheckedCreateWithoutResidenceTypeInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutResidenceTypeInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutResidenceTypeInput, ObjectUncheckedUpdateWithoutResidenceTypeInput>
  }

  export type ObjectUpdateManyWithWhereWithoutResidenceTypeInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutResidenceTypeInput>
  }

  export type ObjectTypeUpsertWithoutResidenceTypeInput = {
    update: XOR<ObjectTypeUpdateWithoutResidenceTypeInput, ObjectTypeUncheckedUpdateWithoutResidenceTypeInput>
    create: XOR<ObjectTypeCreateWithoutResidenceTypeInput, ObjectTypeUncheckedCreateWithoutResidenceTypeInput>
    where?: ObjectTypeWhereInput
  }

  export type ObjectTypeUpdateToOneWithWhereWithoutResidenceTypeInput = {
    where?: ObjectTypeWhereInput
    data: XOR<ObjectTypeUpdateWithoutResidenceTypeInput, ObjectTypeUncheckedUpdateWithoutResidenceTypeInput>
  }

  export type ObjectTypeUpdateWithoutResidenceTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutObjectTypeNestedInput
  }

  export type ObjectTypeUncheckedUpdateWithoutResidenceTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutObjectTypeNestedInput
  }

  export type ObjectCreateWithoutObjectCategoryInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutObjectCategoryInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutObjectCategoryInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutObjectCategoryInput, ObjectUncheckedCreateWithoutObjectCategoryInput>
  }

  export type ObjectCreateManyObjectCategoryInputEnvelope = {
    data: ObjectCreateManyObjectCategoryInput | ObjectCreateManyObjectCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithWhereUniqueWithoutObjectCategoryInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutObjectCategoryInput, ObjectUncheckedUpdateWithoutObjectCategoryInput>
    create: XOR<ObjectCreateWithoutObjectCategoryInput, ObjectUncheckedCreateWithoutObjectCategoryInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutObjectCategoryInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutObjectCategoryInput, ObjectUncheckedUpdateWithoutObjectCategoryInput>
  }

  export type ObjectUpdateManyWithWhereWithoutObjectCategoryInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutObjectCategoryInput>
  }

  export type ObjectCreateWithoutObjectStatusInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutObjectStatusInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutObjectStatusInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutObjectStatusInput, ObjectUncheckedCreateWithoutObjectStatusInput>
  }

  export type ObjectCreateManyObjectStatusInputEnvelope = {
    data: ObjectCreateManyObjectStatusInput | ObjectCreateManyObjectStatusInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithWhereUniqueWithoutObjectStatusInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutObjectStatusInput, ObjectUncheckedUpdateWithoutObjectStatusInput>
    create: XOR<ObjectCreateWithoutObjectStatusInput, ObjectUncheckedCreateWithoutObjectStatusInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutObjectStatusInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutObjectStatusInput, ObjectUncheckedUpdateWithoutObjectStatusInput>
  }

  export type ObjectUpdateManyWithWhereWithoutObjectStatusInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutObjectStatusInput>
  }

  export type ObjectCreateWithoutCurrencyInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutCurrencyInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutCurrencyInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutCurrencyInput, ObjectUncheckedCreateWithoutCurrencyInput>
  }

  export type ObjectCreateManyCurrencyInputEnvelope = {
    data: ObjectCreateManyCurrencyInput | ObjectCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutCurrencyInput, ObjectUncheckedUpdateWithoutCurrencyInput>
    create: XOR<ObjectCreateWithoutCurrencyInput, ObjectUncheckedCreateWithoutCurrencyInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutCurrencyInput, ObjectUncheckedUpdateWithoutCurrencyInput>
  }

  export type ObjectUpdateManyWithWhereWithoutCurrencyInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type ObjectCreateWithoutRenovationInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutRenovationInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutRenovationInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutRenovationInput, ObjectUncheckedCreateWithoutRenovationInput>
  }

  export type ObjectCreateManyRenovationInputEnvelope = {
    data: ObjectCreateManyRenovationInput | ObjectCreateManyRenovationInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithWhereUniqueWithoutRenovationInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutRenovationInput, ObjectUncheckedUpdateWithoutRenovationInput>
    create: XOR<ObjectCreateWithoutRenovationInput, ObjectUncheckedCreateWithoutRenovationInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutRenovationInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutRenovationInput, ObjectUncheckedUpdateWithoutRenovationInput>
  }

  export type ObjectUpdateManyWithWhereWithoutRenovationInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutRenovationInput>
  }

  export type ObjectCreateWithoutWindowSideInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    RoomType?: RoomTypeCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutWindowSideInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutWindowSideInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutWindowSideInput, ObjectUncheckedCreateWithoutWindowSideInput>
  }

  export type ObjectCreateManyWindowSideInputEnvelope = {
    data: ObjectCreateManyWindowSideInput | ObjectCreateManyWindowSideInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithWhereUniqueWithoutWindowSideInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutWindowSideInput, ObjectUncheckedUpdateWithoutWindowSideInput>
    create: XOR<ObjectCreateWithoutWindowSideInput, ObjectUncheckedCreateWithoutWindowSideInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutWindowSideInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutWindowSideInput, ObjectUncheckedUpdateWithoutWindowSideInput>
  }

  export type ObjectUpdateManyWithWhereWithoutWindowSideInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutWindowSideInput>
  }

  export type ObjectCreateWithoutRoomTypeInput = {
    name: string
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
    Realtor?: RealtorCreateNestedOneWithoutObjectInput
    ObjectType?: ObjectTypeCreateNestedOneWithoutObjectInput
    ResidenceType?: ResidenceTypeCreateNestedOneWithoutObjectInput
    ObjectCategory?: ObjectCategoryCreateNestedOneWithoutObjectInput
    ObjectStatus?: ObjectStatusCreateNestedOneWithoutObjectInput
    Currency?: CurrencyCreateNestedOneWithoutObjectInput
    Renovation?: RenovationCreateNestedOneWithoutObjectInput
    WindowSide?: WindowSideCreateNestedOneWithoutObjectInput
  }

  export type ObjectUncheckedCreateWithoutRoomTypeInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectCreateOrConnectWithoutRoomTypeInput = {
    where: ObjectWhereUniqueInput
    create: XOR<ObjectCreateWithoutRoomTypeInput, ObjectUncheckedCreateWithoutRoomTypeInput>
  }

  export type ObjectCreateManyRoomTypeInputEnvelope = {
    data: ObjectCreateManyRoomTypeInput | ObjectCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type ObjectUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: ObjectWhereUniqueInput
    update: XOR<ObjectUpdateWithoutRoomTypeInput, ObjectUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<ObjectCreateWithoutRoomTypeInput, ObjectUncheckedCreateWithoutRoomTypeInput>
  }

  export type ObjectUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: ObjectWhereUniqueInput
    data: XOR<ObjectUpdateWithoutRoomTypeInput, ObjectUncheckedUpdateWithoutRoomTypeInput>
  }

  export type ObjectUpdateManyWithWhereWithoutRoomTypeInput = {
    where: ObjectScalarWhereInput
    data: XOR<ObjectUpdateManyMutationInput, ObjectUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type RealtorCreateWithoutObjectInput = {
    name: string
    is_active: boolean
    reg_date: Date | string
    deactivate_date: Date | string
    photo: string
    login: string
    password: string
  }

  export type RealtorUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
    is_active: boolean
    reg_date: Date | string
    deactivate_date: Date | string
    photo: string
    login: string
    password: string
  }

  export type RealtorCreateOrConnectWithoutObjectInput = {
    where: RealtorWhereUniqueInput
    create: XOR<RealtorCreateWithoutObjectInput, RealtorUncheckedCreateWithoutObjectInput>
  }

  export type ObjectTypeCreateWithoutObjectInput = {
    name: string
    residenceType?: ResidenceTypeCreateNestedManyWithoutObjectTypeInput
  }

  export type ObjectTypeUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
    residenceType?: ResidenceTypeUncheckedCreateNestedManyWithoutObjectTypeInput
  }

  export type ObjectTypeCreateOrConnectWithoutObjectInput = {
    where: ObjectTypeWhereUniqueInput
    create: XOR<ObjectTypeCreateWithoutObjectInput, ObjectTypeUncheckedCreateWithoutObjectInput>
  }

  export type ResidenceTypeCreateWithoutObjectInput = {
    name: string
    ObjectType?: ObjectTypeCreateNestedOneWithoutResidenceTypeInput
  }

  export type ResidenceTypeUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
    objectTypeId?: number | null
  }

  export type ResidenceTypeCreateOrConnectWithoutObjectInput = {
    where: ResidenceTypeWhereUniqueInput
    create: XOR<ResidenceTypeCreateWithoutObjectInput, ResidenceTypeUncheckedCreateWithoutObjectInput>
  }

  export type ObjectCategoryCreateWithoutObjectInput = {
    name: string
  }

  export type ObjectCategoryUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
  }

  export type ObjectCategoryCreateOrConnectWithoutObjectInput = {
    where: ObjectCategoryWhereUniqueInput
    create: XOR<ObjectCategoryCreateWithoutObjectInput, ObjectCategoryUncheckedCreateWithoutObjectInput>
  }

  export type ObjectStatusCreateWithoutObjectInput = {
    name: string
  }

  export type ObjectStatusUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
  }

  export type ObjectStatusCreateOrConnectWithoutObjectInput = {
    where: ObjectStatusWhereUniqueInput
    create: XOR<ObjectStatusCreateWithoutObjectInput, ObjectStatusUncheckedCreateWithoutObjectInput>
  }

  export type CurrencyCreateWithoutObjectInput = {
    name: string
    rate: string
  }

  export type CurrencyUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
    rate: string
  }

  export type CurrencyCreateOrConnectWithoutObjectInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutObjectInput, CurrencyUncheckedCreateWithoutObjectInput>
  }

  export type RenovationCreateWithoutObjectInput = {
    name: string
  }

  export type RenovationUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
  }

  export type RenovationCreateOrConnectWithoutObjectInput = {
    where: RenovationWhereUniqueInput
    create: XOR<RenovationCreateWithoutObjectInput, RenovationUncheckedCreateWithoutObjectInput>
  }

  export type WindowSideCreateWithoutObjectInput = {
    name: string
  }

  export type WindowSideUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
  }

  export type WindowSideCreateOrConnectWithoutObjectInput = {
    where: WindowSideWhereUniqueInput
    create: XOR<WindowSideCreateWithoutObjectInput, WindowSideUncheckedCreateWithoutObjectInput>
  }

  export type RoomTypeCreateWithoutObjectInput = {
    name: string
  }

  export type RoomTypeUncheckedCreateWithoutObjectInput = {
    id?: number
    name: string
  }

  export type RoomTypeCreateOrConnectWithoutObjectInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutObjectInput, RoomTypeUncheckedCreateWithoutObjectInput>
  }

  export type RealtorUpsertWithoutObjectInput = {
    update: XOR<RealtorUpdateWithoutObjectInput, RealtorUncheckedUpdateWithoutObjectInput>
    create: XOR<RealtorCreateWithoutObjectInput, RealtorUncheckedCreateWithoutObjectInput>
    where?: RealtorWhereInput
  }

  export type RealtorUpdateToOneWithWhereWithoutObjectInput = {
    where?: RealtorWhereInput
    data: XOR<RealtorUpdateWithoutObjectInput, RealtorUncheckedUpdateWithoutObjectInput>
  }

  export type RealtorUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    reg_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivate_date?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type RealtorUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    reg_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivate_date?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectTypeUpsertWithoutObjectInput = {
    update: XOR<ObjectTypeUpdateWithoutObjectInput, ObjectTypeUncheckedUpdateWithoutObjectInput>
    create: XOR<ObjectTypeCreateWithoutObjectInput, ObjectTypeUncheckedCreateWithoutObjectInput>
    where?: ObjectTypeWhereInput
  }

  export type ObjectTypeUpdateToOneWithWhereWithoutObjectInput = {
    where?: ObjectTypeWhereInput
    data: XOR<ObjectTypeUpdateWithoutObjectInput, ObjectTypeUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectTypeUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    residenceType?: ResidenceTypeUpdateManyWithoutObjectTypeNestedInput
  }

  export type ObjectTypeUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    residenceType?: ResidenceTypeUncheckedUpdateManyWithoutObjectTypeNestedInput
  }

  export type ResidenceTypeUpsertWithoutObjectInput = {
    update: XOR<ResidenceTypeUpdateWithoutObjectInput, ResidenceTypeUncheckedUpdateWithoutObjectInput>
    create: XOR<ResidenceTypeCreateWithoutObjectInput, ResidenceTypeUncheckedCreateWithoutObjectInput>
    where?: ResidenceTypeWhereInput
  }

  export type ResidenceTypeUpdateToOneWithWhereWithoutObjectInput = {
    where?: ResidenceTypeWhereInput
    data: XOR<ResidenceTypeUpdateWithoutObjectInput, ResidenceTypeUncheckedUpdateWithoutObjectInput>
  }

  export type ResidenceTypeUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    ObjectType?: ObjectTypeUpdateOneWithoutResidenceTypeNestedInput
  }

  export type ResidenceTypeUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ObjectCategoryUpsertWithoutObjectInput = {
    update: XOR<ObjectCategoryUpdateWithoutObjectInput, ObjectCategoryUncheckedUpdateWithoutObjectInput>
    create: XOR<ObjectCategoryCreateWithoutObjectInput, ObjectCategoryUncheckedCreateWithoutObjectInput>
    where?: ObjectCategoryWhereInput
  }

  export type ObjectCategoryUpdateToOneWithWhereWithoutObjectInput = {
    where?: ObjectCategoryWhereInput
    data: XOR<ObjectCategoryUpdateWithoutObjectInput, ObjectCategoryUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectCategoryUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCategoryUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectStatusUpsertWithoutObjectInput = {
    update: XOR<ObjectStatusUpdateWithoutObjectInput, ObjectStatusUncheckedUpdateWithoutObjectInput>
    create: XOR<ObjectStatusCreateWithoutObjectInput, ObjectStatusUncheckedCreateWithoutObjectInput>
    where?: ObjectStatusWhereInput
  }

  export type ObjectStatusUpdateToOneWithWhereWithoutObjectInput = {
    where?: ObjectStatusWhereInput
    data: XOR<ObjectStatusUpdateWithoutObjectInput, ObjectStatusUncheckedUpdateWithoutObjectInput>
  }

  export type ObjectStatusUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectStatusUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyUpsertWithoutObjectInput = {
    update: XOR<CurrencyUpdateWithoutObjectInput, CurrencyUncheckedUpdateWithoutObjectInput>
    create: XOR<CurrencyCreateWithoutObjectInput, CurrencyUncheckedCreateWithoutObjectInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutObjectInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutObjectInput, CurrencyUncheckedUpdateWithoutObjectInput>
  }

  export type CurrencyUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
  }

  export type RenovationUpsertWithoutObjectInput = {
    update: XOR<RenovationUpdateWithoutObjectInput, RenovationUncheckedUpdateWithoutObjectInput>
    create: XOR<RenovationCreateWithoutObjectInput, RenovationUncheckedCreateWithoutObjectInput>
    where?: RenovationWhereInput
  }

  export type RenovationUpdateToOneWithWhereWithoutObjectInput = {
    where?: RenovationWhereInput
    data: XOR<RenovationUpdateWithoutObjectInput, RenovationUncheckedUpdateWithoutObjectInput>
  }

  export type RenovationUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RenovationUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WindowSideUpsertWithoutObjectInput = {
    update: XOR<WindowSideUpdateWithoutObjectInput, WindowSideUncheckedUpdateWithoutObjectInput>
    create: XOR<WindowSideCreateWithoutObjectInput, WindowSideUncheckedCreateWithoutObjectInput>
    where?: WindowSideWhereInput
  }

  export type WindowSideUpdateToOneWithWhereWithoutObjectInput = {
    where?: WindowSideWhereInput
    data: XOR<WindowSideUpdateWithoutObjectInput, WindowSideUncheckedUpdateWithoutObjectInput>
  }

  export type WindowSideUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WindowSideUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTypeUpsertWithoutObjectInput = {
    update: XOR<RoomTypeUpdateWithoutObjectInput, RoomTypeUncheckedUpdateWithoutObjectInput>
    create: XOR<RoomTypeCreateWithoutObjectInput, RoomTypeUncheckedCreateWithoutObjectInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutObjectInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutObjectInput, RoomTypeUncheckedUpdateWithoutObjectInput>
  }

  export type RoomTypeUpdateWithoutObjectInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomTypeUncheckedUpdateWithoutObjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerRelationCreateWithoutOwnerShipInput = {
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
    ReasonDeleting?: ReasonDeletingCreateNestedOneWithoutOwnerRelationInput
    OwnerCooperation?: OwnerCooperationCreateNestedOneWithoutOwnerRelationInput
    RelationshipType?: RelationshipTypeCreateNestedOneWithoutOwnerRelationInput
  }

  export type OwnerRelationUncheckedCreateWithoutOwnerShipInput = {
    id?: number
    reasonDeletingId?: number | null
    ownerCooperationId?: number | null
    relationshipTypeId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationCreateOrConnectWithoutOwnerShipInput = {
    where: OwnerRelationWhereUniqueInput
    create: XOR<OwnerRelationCreateWithoutOwnerShipInput, OwnerRelationUncheckedCreateWithoutOwnerShipInput>
  }

  export type OwnerRelationCreateManyOwnerShipInputEnvelope = {
    data: OwnerRelationCreateManyOwnerShipInput | OwnerRelationCreateManyOwnerShipInput[]
    skipDuplicates?: boolean
  }

  export type OwnerRelationUpsertWithWhereUniqueWithoutOwnerShipInput = {
    where: OwnerRelationWhereUniqueInput
    update: XOR<OwnerRelationUpdateWithoutOwnerShipInput, OwnerRelationUncheckedUpdateWithoutOwnerShipInput>
    create: XOR<OwnerRelationCreateWithoutOwnerShipInput, OwnerRelationUncheckedCreateWithoutOwnerShipInput>
  }

  export type OwnerRelationUpdateWithWhereUniqueWithoutOwnerShipInput = {
    where: OwnerRelationWhereUniqueInput
    data: XOR<OwnerRelationUpdateWithoutOwnerShipInput, OwnerRelationUncheckedUpdateWithoutOwnerShipInput>
  }

  export type OwnerRelationUpdateManyWithWhereWithoutOwnerShipInput = {
    where: OwnerRelationScalarWhereInput
    data: XOR<OwnerRelationUpdateManyMutationInput, OwnerRelationUncheckedUpdateManyWithoutOwnerShipInput>
  }

  export type OwnerRelationScalarWhereInput = {
    AND?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
    OR?: OwnerRelationScalarWhereInput[]
    NOT?: OwnerRelationScalarWhereInput | OwnerRelationScalarWhereInput[]
    id?: IntFilter<"OwnerRelation"> | number
    ownerShipId?: IntNullableFilter<"OwnerRelation"> | number | null
    reasonDeletingId?: IntNullableFilter<"OwnerRelation"> | number | null
    ownerCooperationId?: IntNullableFilter<"OwnerRelation"> | number | null
    relationshipTypeId?: IntNullableFilter<"OwnerRelation"> | number | null
    commission_amount?: FloatFilter<"OwnerRelation"> | number
    commission_comment?: StringFilter<"OwnerRelation"> | string
    deposit_amount?: FloatFilter<"OwnerRelation"> | number
    deposit_paid?: FloatFilter<"OwnerRelation"> | number
    owner_price_ideal?: FloatFilter<"OwnerRelation"> | number
    owner_price_real?: FloatFilter<"OwnerRelation"> | number
    owner_price_minimal?: FloatFilter<"OwnerRelation"> | number
  }

  export type OwnerRelationCreateWithoutReasonDeletingInput = {
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
    OwnerShip?: OwnerShipCreateNestedOneWithoutOwnerRelationInput
    OwnerCooperation?: OwnerCooperationCreateNestedOneWithoutOwnerRelationInput
    RelationshipType?: RelationshipTypeCreateNestedOneWithoutOwnerRelationInput
  }

  export type OwnerRelationUncheckedCreateWithoutReasonDeletingInput = {
    id?: number
    ownerShipId?: number | null
    ownerCooperationId?: number | null
    relationshipTypeId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationCreateOrConnectWithoutReasonDeletingInput = {
    where: OwnerRelationWhereUniqueInput
    create: XOR<OwnerRelationCreateWithoutReasonDeletingInput, OwnerRelationUncheckedCreateWithoutReasonDeletingInput>
  }

  export type OwnerRelationCreateManyReasonDeletingInputEnvelope = {
    data: OwnerRelationCreateManyReasonDeletingInput | OwnerRelationCreateManyReasonDeletingInput[]
    skipDuplicates?: boolean
  }

  export type OwnerRelationUpsertWithWhereUniqueWithoutReasonDeletingInput = {
    where: OwnerRelationWhereUniqueInput
    update: XOR<OwnerRelationUpdateWithoutReasonDeletingInput, OwnerRelationUncheckedUpdateWithoutReasonDeletingInput>
    create: XOR<OwnerRelationCreateWithoutReasonDeletingInput, OwnerRelationUncheckedCreateWithoutReasonDeletingInput>
  }

  export type OwnerRelationUpdateWithWhereUniqueWithoutReasonDeletingInput = {
    where: OwnerRelationWhereUniqueInput
    data: XOR<OwnerRelationUpdateWithoutReasonDeletingInput, OwnerRelationUncheckedUpdateWithoutReasonDeletingInput>
  }

  export type OwnerRelationUpdateManyWithWhereWithoutReasonDeletingInput = {
    where: OwnerRelationScalarWhereInput
    data: XOR<OwnerRelationUpdateManyMutationInput, OwnerRelationUncheckedUpdateManyWithoutReasonDeletingInput>
  }

  export type OwnerRelationCreateWithoutOwnerCooperationInput = {
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
    OwnerShip?: OwnerShipCreateNestedOneWithoutOwnerRelationInput
    ReasonDeleting?: ReasonDeletingCreateNestedOneWithoutOwnerRelationInput
    RelationshipType?: RelationshipTypeCreateNestedOneWithoutOwnerRelationInput
  }

  export type OwnerRelationUncheckedCreateWithoutOwnerCooperationInput = {
    id?: number
    ownerShipId?: number | null
    reasonDeletingId?: number | null
    relationshipTypeId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationCreateOrConnectWithoutOwnerCooperationInput = {
    where: OwnerRelationWhereUniqueInput
    create: XOR<OwnerRelationCreateWithoutOwnerCooperationInput, OwnerRelationUncheckedCreateWithoutOwnerCooperationInput>
  }

  export type OwnerRelationCreateManyOwnerCooperationInputEnvelope = {
    data: OwnerRelationCreateManyOwnerCooperationInput | OwnerRelationCreateManyOwnerCooperationInput[]
    skipDuplicates?: boolean
  }

  export type OwnerRelationUpsertWithWhereUniqueWithoutOwnerCooperationInput = {
    where: OwnerRelationWhereUniqueInput
    update: XOR<OwnerRelationUpdateWithoutOwnerCooperationInput, OwnerRelationUncheckedUpdateWithoutOwnerCooperationInput>
    create: XOR<OwnerRelationCreateWithoutOwnerCooperationInput, OwnerRelationUncheckedCreateWithoutOwnerCooperationInput>
  }

  export type OwnerRelationUpdateWithWhereUniqueWithoutOwnerCooperationInput = {
    where: OwnerRelationWhereUniqueInput
    data: XOR<OwnerRelationUpdateWithoutOwnerCooperationInput, OwnerRelationUncheckedUpdateWithoutOwnerCooperationInput>
  }

  export type OwnerRelationUpdateManyWithWhereWithoutOwnerCooperationInput = {
    where: OwnerRelationScalarWhereInput
    data: XOR<OwnerRelationUpdateManyMutationInput, OwnerRelationUncheckedUpdateManyWithoutOwnerCooperationInput>
  }

  export type OwnerRelationCreateWithoutRelationshipTypeInput = {
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
    OwnerShip?: OwnerShipCreateNestedOneWithoutOwnerRelationInput
    ReasonDeleting?: ReasonDeletingCreateNestedOneWithoutOwnerRelationInput
    OwnerCooperation?: OwnerCooperationCreateNestedOneWithoutOwnerRelationInput
  }

  export type OwnerRelationUncheckedCreateWithoutRelationshipTypeInput = {
    id?: number
    ownerShipId?: number | null
    reasonDeletingId?: number | null
    ownerCooperationId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationCreateOrConnectWithoutRelationshipTypeInput = {
    where: OwnerRelationWhereUniqueInput
    create: XOR<OwnerRelationCreateWithoutRelationshipTypeInput, OwnerRelationUncheckedCreateWithoutRelationshipTypeInput>
  }

  export type OwnerRelationCreateManyRelationshipTypeInputEnvelope = {
    data: OwnerRelationCreateManyRelationshipTypeInput | OwnerRelationCreateManyRelationshipTypeInput[]
    skipDuplicates?: boolean
  }

  export type OwnerRelationUpsertWithWhereUniqueWithoutRelationshipTypeInput = {
    where: OwnerRelationWhereUniqueInput
    update: XOR<OwnerRelationUpdateWithoutRelationshipTypeInput, OwnerRelationUncheckedUpdateWithoutRelationshipTypeInput>
    create: XOR<OwnerRelationCreateWithoutRelationshipTypeInput, OwnerRelationUncheckedCreateWithoutRelationshipTypeInput>
  }

  export type OwnerRelationUpdateWithWhereUniqueWithoutRelationshipTypeInput = {
    where: OwnerRelationWhereUniqueInput
    data: XOR<OwnerRelationUpdateWithoutRelationshipTypeInput, OwnerRelationUncheckedUpdateWithoutRelationshipTypeInput>
  }

  export type OwnerRelationUpdateManyWithWhereWithoutRelationshipTypeInput = {
    where: OwnerRelationScalarWhereInput
    data: XOR<OwnerRelationUpdateManyMutationInput, OwnerRelationUncheckedUpdateManyWithoutRelationshipTypeInput>
  }

  export type OwnerShipCreateWithoutOwnerRelationInput = {
    name: string
  }

  export type OwnerShipUncheckedCreateWithoutOwnerRelationInput = {
    id?: number
    name: string
  }

  export type OwnerShipCreateOrConnectWithoutOwnerRelationInput = {
    where: OwnerShipWhereUniqueInput
    create: XOR<OwnerShipCreateWithoutOwnerRelationInput, OwnerShipUncheckedCreateWithoutOwnerRelationInput>
  }

  export type ReasonDeletingCreateWithoutOwnerRelationInput = {
    name: string
  }

  export type ReasonDeletingUncheckedCreateWithoutOwnerRelationInput = {
    id?: number
    name: string
  }

  export type ReasonDeletingCreateOrConnectWithoutOwnerRelationInput = {
    where: ReasonDeletingWhereUniqueInput
    create: XOR<ReasonDeletingCreateWithoutOwnerRelationInput, ReasonDeletingUncheckedCreateWithoutOwnerRelationInput>
  }

  export type OwnerCooperationCreateWithoutOwnerRelationInput = {
    name: string
  }

  export type OwnerCooperationUncheckedCreateWithoutOwnerRelationInput = {
    id?: number
    name: string
  }

  export type OwnerCooperationCreateOrConnectWithoutOwnerRelationInput = {
    where: OwnerCooperationWhereUniqueInput
    create: XOR<OwnerCooperationCreateWithoutOwnerRelationInput, OwnerCooperationUncheckedCreateWithoutOwnerRelationInput>
  }

  export type RelationshipTypeCreateWithoutOwnerRelationInput = {
    name: string
  }

  export type RelationshipTypeUncheckedCreateWithoutOwnerRelationInput = {
    id?: number
    name: string
  }

  export type RelationshipTypeCreateOrConnectWithoutOwnerRelationInput = {
    where: RelationshipTypeWhereUniqueInput
    create: XOR<RelationshipTypeCreateWithoutOwnerRelationInput, RelationshipTypeUncheckedCreateWithoutOwnerRelationInput>
  }

  export type OwnerShipUpsertWithoutOwnerRelationInput = {
    update: XOR<OwnerShipUpdateWithoutOwnerRelationInput, OwnerShipUncheckedUpdateWithoutOwnerRelationInput>
    create: XOR<OwnerShipCreateWithoutOwnerRelationInput, OwnerShipUncheckedCreateWithoutOwnerRelationInput>
    where?: OwnerShipWhereInput
  }

  export type OwnerShipUpdateToOneWithWhereWithoutOwnerRelationInput = {
    where?: OwnerShipWhereInput
    data: XOR<OwnerShipUpdateWithoutOwnerRelationInput, OwnerShipUncheckedUpdateWithoutOwnerRelationInput>
  }

  export type OwnerShipUpdateWithoutOwnerRelationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerShipUncheckedUpdateWithoutOwnerRelationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReasonDeletingUpsertWithoutOwnerRelationInput = {
    update: XOR<ReasonDeletingUpdateWithoutOwnerRelationInput, ReasonDeletingUncheckedUpdateWithoutOwnerRelationInput>
    create: XOR<ReasonDeletingCreateWithoutOwnerRelationInput, ReasonDeletingUncheckedCreateWithoutOwnerRelationInput>
    where?: ReasonDeletingWhereInput
  }

  export type ReasonDeletingUpdateToOneWithWhereWithoutOwnerRelationInput = {
    where?: ReasonDeletingWhereInput
    data: XOR<ReasonDeletingUpdateWithoutOwnerRelationInput, ReasonDeletingUncheckedUpdateWithoutOwnerRelationInput>
  }

  export type ReasonDeletingUpdateWithoutOwnerRelationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReasonDeletingUncheckedUpdateWithoutOwnerRelationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerCooperationUpsertWithoutOwnerRelationInput = {
    update: XOR<OwnerCooperationUpdateWithoutOwnerRelationInput, OwnerCooperationUncheckedUpdateWithoutOwnerRelationInput>
    create: XOR<OwnerCooperationCreateWithoutOwnerRelationInput, OwnerCooperationUncheckedCreateWithoutOwnerRelationInput>
    where?: OwnerCooperationWhereInput
  }

  export type OwnerCooperationUpdateToOneWithWhereWithoutOwnerRelationInput = {
    where?: OwnerCooperationWhereInput
    data: XOR<OwnerCooperationUpdateWithoutOwnerRelationInput, OwnerCooperationUncheckedUpdateWithoutOwnerRelationInput>
  }

  export type OwnerCooperationUpdateWithoutOwnerRelationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerCooperationUncheckedUpdateWithoutOwnerRelationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RelationshipTypeUpsertWithoutOwnerRelationInput = {
    update: XOR<RelationshipTypeUpdateWithoutOwnerRelationInput, RelationshipTypeUncheckedUpdateWithoutOwnerRelationInput>
    create: XOR<RelationshipTypeCreateWithoutOwnerRelationInput, RelationshipTypeUncheckedCreateWithoutOwnerRelationInput>
    where?: RelationshipTypeWhereInput
  }

  export type RelationshipTypeUpdateToOneWithWhereWithoutOwnerRelationInput = {
    where?: RelationshipTypeWhereInput
    data: XOR<RelationshipTypeUpdateWithoutOwnerRelationInput, RelationshipTypeUncheckedUpdateWithoutOwnerRelationInput>
  }

  export type RelationshipTypeUpdateWithoutOwnerRelationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RelationshipTypeUncheckedUpdateWithoutOwnerRelationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateWithoutRegionInput = {
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
    District?: DistrictCreateNestedOneWithoutAddressInput
    Area?: AreaCreateNestedOneWithoutAddressInput
    Mahalla?: MahallaCreateNestedOneWithoutAddressInput
    Street?: StreetCreateNestedOneWithoutAddressInput
    Metro?: MetroCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutRegionInput = {
    id?: number
    districtId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressCreateOrConnectWithoutRegionInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput>
  }

  export type AddressCreateManyRegionInputEnvelope = {
    data: AddressCreateManyRegionInput | AddressCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type DistrictCreateWithoutRegionInput = {
    name: string
    address?: AddressCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateWithoutRegionInput = {
    id?: number
    name: string
    address?: AddressUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictCreateOrConnectWithoutRegionInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutRegionInput, DistrictUncheckedCreateWithoutRegionInput>
  }

  export type DistrictCreateManyRegionInputEnvelope = {
    data: DistrictCreateManyRegionInput | DistrictCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutRegionInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutRegionInput, AddressUncheckedUpdateWithoutRegionInput>
    create: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutRegionInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutRegionInput, AddressUncheckedUpdateWithoutRegionInput>
  }

  export type AddressUpdateManyWithWhereWithoutRegionInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutRegionInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    regionId?: IntNullableFilter<"Address"> | number | null
    districtId?: IntNullableFilter<"Address"> | number | null
    areaId?: IntNullableFilter<"Address"> | number | null
    mahallaId?: IntNullableFilter<"Address"> | number | null
    streetId?: IntNullableFilter<"Address"> | number | null
    house_number?: IntFilter<"Address"> | number
    apartment_number?: IntFilter<"Address"> | number
    location?: StringFilter<"Address"> | string
    landmark?: BoolFilter<"Address"> | boolean
    metroId?: IntNullableFilter<"Address"> | number | null
    location_description?: StringFilter<"Address"> | string
  }

  export type DistrictUpsertWithWhereUniqueWithoutRegionInput = {
    where: DistrictWhereUniqueInput
    update: XOR<DistrictUpdateWithoutRegionInput, DistrictUncheckedUpdateWithoutRegionInput>
    create: XOR<DistrictCreateWithoutRegionInput, DistrictUncheckedCreateWithoutRegionInput>
  }

  export type DistrictUpdateWithWhereUniqueWithoutRegionInput = {
    where: DistrictWhereUniqueInput
    data: XOR<DistrictUpdateWithoutRegionInput, DistrictUncheckedUpdateWithoutRegionInput>
  }

  export type DistrictUpdateManyWithWhereWithoutRegionInput = {
    where: DistrictScalarWhereInput
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyWithoutRegionInput>
  }

  export type DistrictScalarWhereInput = {
    AND?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
    OR?: DistrictScalarWhereInput[]
    NOT?: DistrictScalarWhereInput | DistrictScalarWhereInput[]
    id?: IntFilter<"District"> | number
    name?: StringFilter<"District"> | string
    regionId?: IntNullableFilter<"District"> | number | null
  }

  export type AddressCreateWithoutDistrictInput = {
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
    Region?: RegionCreateNestedOneWithoutAddressInput
    Area?: AreaCreateNestedOneWithoutAddressInput
    Mahalla?: MahallaCreateNestedOneWithoutAddressInput
    Street?: StreetCreateNestedOneWithoutAddressInput
    Metro?: MetroCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutDistrictInput = {
    id?: number
    regionId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressCreateOrConnectWithoutDistrictInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutDistrictInput, AddressUncheckedCreateWithoutDistrictInput>
  }

  export type AddressCreateManyDistrictInputEnvelope = {
    data: AddressCreateManyDistrictInput | AddressCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type RegionCreateWithoutDistrictInput = {
    name: string
    address?: AddressCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutDistrictInput = {
    id?: number
    name: string
    address?: AddressUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutDistrictInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutDistrictInput, RegionUncheckedCreateWithoutDistrictInput>
  }

  export type AddressUpsertWithWhereUniqueWithoutDistrictInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutDistrictInput, AddressUncheckedUpdateWithoutDistrictInput>
    create: XOR<AddressCreateWithoutDistrictInput, AddressUncheckedCreateWithoutDistrictInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutDistrictInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutDistrictInput, AddressUncheckedUpdateWithoutDistrictInput>
  }

  export type AddressUpdateManyWithWhereWithoutDistrictInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutDistrictInput>
  }

  export type RegionUpsertWithoutDistrictInput = {
    update: XOR<RegionUpdateWithoutDistrictInput, RegionUncheckedUpdateWithoutDistrictInput>
    create: XOR<RegionCreateWithoutDistrictInput, RegionUncheckedCreateWithoutDistrictInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutDistrictInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutDistrictInput, RegionUncheckedUpdateWithoutDistrictInput>
  }

  export type RegionUpdateWithoutDistrictInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type AddressCreateWithoutAreaInput = {
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
    Region?: RegionCreateNestedOneWithoutAddressInput
    District?: DistrictCreateNestedOneWithoutAddressInput
    Mahalla?: MahallaCreateNestedOneWithoutAddressInput
    Street?: StreetCreateNestedOneWithoutAddressInput
    Metro?: MetroCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutAreaInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressCreateOrConnectWithoutAreaInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutAreaInput, AddressUncheckedCreateWithoutAreaInput>
  }

  export type AddressCreateManyAreaInputEnvelope = {
    data: AddressCreateManyAreaInput | AddressCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutAreaInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutAreaInput, AddressUncheckedUpdateWithoutAreaInput>
    create: XOR<AddressCreateWithoutAreaInput, AddressUncheckedCreateWithoutAreaInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutAreaInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutAreaInput, AddressUncheckedUpdateWithoutAreaInput>
  }

  export type AddressUpdateManyWithWhereWithoutAreaInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAreaInput>
  }

  export type AddressCreateWithoutMahallaInput = {
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
    Region?: RegionCreateNestedOneWithoutAddressInput
    District?: DistrictCreateNestedOneWithoutAddressInput
    Area?: AreaCreateNestedOneWithoutAddressInput
    Street?: StreetCreateNestedOneWithoutAddressInput
    Metro?: MetroCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutMahallaInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    areaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressCreateOrConnectWithoutMahallaInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutMahallaInput, AddressUncheckedCreateWithoutMahallaInput>
  }

  export type AddressCreateManyMahallaInputEnvelope = {
    data: AddressCreateManyMahallaInput | AddressCreateManyMahallaInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutMahallaInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutMahallaInput, AddressUncheckedUpdateWithoutMahallaInput>
    create: XOR<AddressCreateWithoutMahallaInput, AddressUncheckedCreateWithoutMahallaInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutMahallaInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutMahallaInput, AddressUncheckedUpdateWithoutMahallaInput>
  }

  export type AddressUpdateManyWithWhereWithoutMahallaInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutMahallaInput>
  }

  export type AddressCreateWithoutStreetInput = {
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
    Region?: RegionCreateNestedOneWithoutAddressInput
    District?: DistrictCreateNestedOneWithoutAddressInput
    Area?: AreaCreateNestedOneWithoutAddressInput
    Mahalla?: MahallaCreateNestedOneWithoutAddressInput
    Metro?: MetroCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutStreetInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressCreateOrConnectWithoutStreetInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutStreetInput, AddressUncheckedCreateWithoutStreetInput>
  }

  export type AddressCreateManyStreetInputEnvelope = {
    data: AddressCreateManyStreetInput | AddressCreateManyStreetInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutStreetInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutStreetInput, AddressUncheckedUpdateWithoutStreetInput>
    create: XOR<AddressCreateWithoutStreetInput, AddressUncheckedCreateWithoutStreetInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutStreetInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutStreetInput, AddressUncheckedUpdateWithoutStreetInput>
  }

  export type AddressUpdateManyWithWhereWithoutStreetInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutStreetInput>
  }

  export type AddressCreateWithoutMetroInput = {
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
    Region?: RegionCreateNestedOneWithoutAddressInput
    District?: DistrictCreateNestedOneWithoutAddressInput
    Area?: AreaCreateNestedOneWithoutAddressInput
    Mahalla?: MahallaCreateNestedOneWithoutAddressInput
    Street?: StreetCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutMetroInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
  }

  export type AddressCreateOrConnectWithoutMetroInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutMetroInput, AddressUncheckedCreateWithoutMetroInput>
  }

  export type AddressCreateManyMetroInputEnvelope = {
    data: AddressCreateManyMetroInput | AddressCreateManyMetroInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutMetroInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutMetroInput, AddressUncheckedUpdateWithoutMetroInput>
    create: XOR<AddressCreateWithoutMetroInput, AddressUncheckedCreateWithoutMetroInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutMetroInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutMetroInput, AddressUncheckedUpdateWithoutMetroInput>
  }

  export type AddressUpdateManyWithWhereWithoutMetroInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutMetroInput>
  }

  export type RegionCreateWithoutAddressInput = {
    name: string
    district?: DistrictCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
    district?: DistrictUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutAddressInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutAddressInput, RegionUncheckedCreateWithoutAddressInput>
  }

  export type DistrictCreateWithoutAddressInput = {
    name: string
    Region?: RegionCreateNestedOneWithoutDistrictInput
  }

  export type DistrictUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
    regionId?: number | null
  }

  export type DistrictCreateOrConnectWithoutAddressInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutAddressInput, DistrictUncheckedCreateWithoutAddressInput>
  }

  export type AreaCreateWithoutAddressInput = {
    name: string
  }

  export type AreaUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
  }

  export type AreaCreateOrConnectWithoutAddressInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutAddressInput, AreaUncheckedCreateWithoutAddressInput>
  }

  export type MahallaCreateWithoutAddressInput = {
    name: string
  }

  export type MahallaUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
  }

  export type MahallaCreateOrConnectWithoutAddressInput = {
    where: MahallaWhereUniqueInput
    create: XOR<MahallaCreateWithoutAddressInput, MahallaUncheckedCreateWithoutAddressInput>
  }

  export type StreetCreateWithoutAddressInput = {
    name: string
  }

  export type StreetUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
  }

  export type StreetCreateOrConnectWithoutAddressInput = {
    where: StreetWhereUniqueInput
    create: XOR<StreetCreateWithoutAddressInput, StreetUncheckedCreateWithoutAddressInput>
  }

  export type MetroCreateWithoutAddressInput = {
    name: string
  }

  export type MetroUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
  }

  export type MetroCreateOrConnectWithoutAddressInput = {
    where: MetroWhereUniqueInput
    create: XOR<MetroCreateWithoutAddressInput, MetroUncheckedCreateWithoutAddressInput>
  }

  export type RegionUpsertWithoutAddressInput = {
    update: XOR<RegionUpdateWithoutAddressInput, RegionUncheckedUpdateWithoutAddressInput>
    create: XOR<RegionCreateWithoutAddressInput, RegionUncheckedCreateWithoutAddressInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutAddressInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutAddressInput, RegionUncheckedUpdateWithoutAddressInput>
  }

  export type RegionUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    district?: DistrictUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    district?: DistrictUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type DistrictUpsertWithoutAddressInput = {
    update: XOR<DistrictUpdateWithoutAddressInput, DistrictUncheckedUpdateWithoutAddressInput>
    create: XOR<DistrictCreateWithoutAddressInput, DistrictUncheckedCreateWithoutAddressInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutAddressInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutAddressInput, DistrictUncheckedUpdateWithoutAddressInput>
  }

  export type DistrictUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    Region?: RegionUpdateOneWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaUpsertWithoutAddressInput = {
    update: XOR<AreaUpdateWithoutAddressInput, AreaUncheckedUpdateWithoutAddressInput>
    create: XOR<AreaCreateWithoutAddressInput, AreaUncheckedCreateWithoutAddressInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutAddressInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutAddressInput, AreaUncheckedUpdateWithoutAddressInput>
  }

  export type AreaUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AreaUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MahallaUpsertWithoutAddressInput = {
    update: XOR<MahallaUpdateWithoutAddressInput, MahallaUncheckedUpdateWithoutAddressInput>
    create: XOR<MahallaCreateWithoutAddressInput, MahallaUncheckedCreateWithoutAddressInput>
    where?: MahallaWhereInput
  }

  export type MahallaUpdateToOneWithWhereWithoutAddressInput = {
    where?: MahallaWhereInput
    data: XOR<MahallaUpdateWithoutAddressInput, MahallaUncheckedUpdateWithoutAddressInput>
  }

  export type MahallaUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MahallaUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StreetUpsertWithoutAddressInput = {
    update: XOR<StreetUpdateWithoutAddressInput, StreetUncheckedUpdateWithoutAddressInput>
    create: XOR<StreetCreateWithoutAddressInput, StreetUncheckedCreateWithoutAddressInput>
    where?: StreetWhereInput
  }

  export type StreetUpdateToOneWithWhereWithoutAddressInput = {
    where?: StreetWhereInput
    data: XOR<StreetUpdateWithoutAddressInput, StreetUncheckedUpdateWithoutAddressInput>
  }

  export type StreetUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StreetUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MetroUpsertWithoutAddressInput = {
    update: XOR<MetroUpdateWithoutAddressInput, MetroUncheckedUpdateWithoutAddressInput>
    create: XOR<MetroCreateWithoutAddressInput, MetroUncheckedCreateWithoutAddressInput>
    where?: MetroWhereInput
  }

  export type MetroUpdateToOneWithWhereWithoutAddressInput = {
    where?: MetroWhereInput
    data: XOR<MetroUpdateWithoutAddressInput, MetroUncheckedUpdateWithoutAddressInput>
  }

  export type MetroUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MetroUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingCharacterCreateWithoutBuildingConditionInput = {
    building_year: string
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
    BuildingSeria?: BuildingSeriaCreateNestedOneWithoutBuildingCharacterInput
    WallMaterial?: WallMaterialCreateNestedOneWithoutBuildingCharacterInput
    Overlaps?: OverlapsCreateNestedOneWithoutBuildingCharacterInput
    WaterSupply?: WaterSupplyCreateNestedOneWithoutBuildingCharacterInput
    HeatingSystem?: HeatingSystemCreateNestedOneWithoutBuildingCharacterInput
    Parking?: ParkingCreateNestedOneWithoutBuildingCharacterInput
  }

  export type BuildingCharacterUncheckedCreateWithoutBuildingConditionInput = {
    id?: number
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterCreateOrConnectWithoutBuildingConditionInput = {
    where: BuildingCharacterWhereUniqueInput
    create: XOR<BuildingCharacterCreateWithoutBuildingConditionInput, BuildingCharacterUncheckedCreateWithoutBuildingConditionInput>
  }

  export type BuildingCharacterCreateManyBuildingConditionInputEnvelope = {
    data: BuildingCharacterCreateManyBuildingConditionInput | BuildingCharacterCreateManyBuildingConditionInput[]
    skipDuplicates?: boolean
  }

  export type BuildingCharacterUpsertWithWhereUniqueWithoutBuildingConditionInput = {
    where: BuildingCharacterWhereUniqueInput
    update: XOR<BuildingCharacterUpdateWithoutBuildingConditionInput, BuildingCharacterUncheckedUpdateWithoutBuildingConditionInput>
    create: XOR<BuildingCharacterCreateWithoutBuildingConditionInput, BuildingCharacterUncheckedCreateWithoutBuildingConditionInput>
  }

  export type BuildingCharacterUpdateWithWhereUniqueWithoutBuildingConditionInput = {
    where: BuildingCharacterWhereUniqueInput
    data: XOR<BuildingCharacterUpdateWithoutBuildingConditionInput, BuildingCharacterUncheckedUpdateWithoutBuildingConditionInput>
  }

  export type BuildingCharacterUpdateManyWithWhereWithoutBuildingConditionInput = {
    where: BuildingCharacterScalarWhereInput
    data: XOR<BuildingCharacterUpdateManyMutationInput, BuildingCharacterUncheckedUpdateManyWithoutBuildingConditionInput>
  }

  export type BuildingCharacterScalarWhereInput = {
    AND?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
    OR?: BuildingCharacterScalarWhereInput[]
    NOT?: BuildingCharacterScalarWhereInput | BuildingCharacterScalarWhereInput[]
    id?: IntFilter<"BuildingCharacter"> | number
    buildingConditionId?: IntNullableFilter<"BuildingCharacter"> | number | null
    buildingSeriaId?: IntNullableFilter<"BuildingCharacter"> | number | null
    building_year?: StringFilter<"BuildingCharacter"> | string
    wallMaterialId?: IntNullableFilter<"BuildingCharacter"> | number | null
    overlapsId?: IntNullableFilter<"BuildingCharacter"> | number | null
    waterSupplyId?: IntNullableFilter<"BuildingCharacter"> | number | null
    heatingSystemId?: IntNullableFilter<"BuildingCharacter"> | number | null
    is_gas?: BoolFilter<"BuildingCharacter"> | boolean
    is_electric?: BoolFilter<"BuildingCharacter"> | boolean
    passenger_elevators_count?: IntFilter<"BuildingCharacter"> | number
    freight_elevators_count?: IntFilter<"BuildingCharacter"> | number
    is_building_security?: BoolFilter<"BuildingCharacter"> | boolean
    parkingId?: IntNullableFilter<"BuildingCharacter"> | number | null
    is_demolition_planned?: BoolFilter<"BuildingCharacter"> | boolean
  }

  export type BuildingCharacterCreateWithoutBuildingSeriaInput = {
    building_year: string
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
    BuildingCondition?: BuildingConditionCreateNestedOneWithoutBuildingCharacterInput
    WallMaterial?: WallMaterialCreateNestedOneWithoutBuildingCharacterInput
    Overlaps?: OverlapsCreateNestedOneWithoutBuildingCharacterInput
    WaterSupply?: WaterSupplyCreateNestedOneWithoutBuildingCharacterInput
    HeatingSystem?: HeatingSystemCreateNestedOneWithoutBuildingCharacterInput
    Parking?: ParkingCreateNestedOneWithoutBuildingCharacterInput
  }

  export type BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput = {
    id?: number
    buildingConditionId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterCreateOrConnectWithoutBuildingSeriaInput = {
    where: BuildingCharacterWhereUniqueInput
    create: XOR<BuildingCharacterCreateWithoutBuildingSeriaInput, BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput>
  }

  export type BuildingCharacterCreateManyBuildingSeriaInputEnvelope = {
    data: BuildingCharacterCreateManyBuildingSeriaInput | BuildingCharacterCreateManyBuildingSeriaInput[]
    skipDuplicates?: boolean
  }

  export type BuildingCharacterUpsertWithWhereUniqueWithoutBuildingSeriaInput = {
    where: BuildingCharacterWhereUniqueInput
    update: XOR<BuildingCharacterUpdateWithoutBuildingSeriaInput, BuildingCharacterUncheckedUpdateWithoutBuildingSeriaInput>
    create: XOR<BuildingCharacterCreateWithoutBuildingSeriaInput, BuildingCharacterUncheckedCreateWithoutBuildingSeriaInput>
  }

  export type BuildingCharacterUpdateWithWhereUniqueWithoutBuildingSeriaInput = {
    where: BuildingCharacterWhereUniqueInput
    data: XOR<BuildingCharacterUpdateWithoutBuildingSeriaInput, BuildingCharacterUncheckedUpdateWithoutBuildingSeriaInput>
  }

  export type BuildingCharacterUpdateManyWithWhereWithoutBuildingSeriaInput = {
    where: BuildingCharacterScalarWhereInput
    data: XOR<BuildingCharacterUpdateManyMutationInput, BuildingCharacterUncheckedUpdateManyWithoutBuildingSeriaInput>
  }

  export type BuildingCharacterCreateWithoutWallMaterialInput = {
    building_year: string
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
    BuildingCondition?: BuildingConditionCreateNestedOneWithoutBuildingCharacterInput
    BuildingSeria?: BuildingSeriaCreateNestedOneWithoutBuildingCharacterInput
    Overlaps?: OverlapsCreateNestedOneWithoutBuildingCharacterInput
    WaterSupply?: WaterSupplyCreateNestedOneWithoutBuildingCharacterInput
    HeatingSystem?: HeatingSystemCreateNestedOneWithoutBuildingCharacterInput
    Parking?: ParkingCreateNestedOneWithoutBuildingCharacterInput
  }

  export type BuildingCharacterUncheckedCreateWithoutWallMaterialInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterCreateOrConnectWithoutWallMaterialInput = {
    where: BuildingCharacterWhereUniqueInput
    create: XOR<BuildingCharacterCreateWithoutWallMaterialInput, BuildingCharacterUncheckedCreateWithoutWallMaterialInput>
  }

  export type BuildingCharacterCreateManyWallMaterialInputEnvelope = {
    data: BuildingCharacterCreateManyWallMaterialInput | BuildingCharacterCreateManyWallMaterialInput[]
    skipDuplicates?: boolean
  }

  export type BuildingCharacterUpsertWithWhereUniqueWithoutWallMaterialInput = {
    where: BuildingCharacterWhereUniqueInput
    update: XOR<BuildingCharacterUpdateWithoutWallMaterialInput, BuildingCharacterUncheckedUpdateWithoutWallMaterialInput>
    create: XOR<BuildingCharacterCreateWithoutWallMaterialInput, BuildingCharacterUncheckedCreateWithoutWallMaterialInput>
  }

  export type BuildingCharacterUpdateWithWhereUniqueWithoutWallMaterialInput = {
    where: BuildingCharacterWhereUniqueInput
    data: XOR<BuildingCharacterUpdateWithoutWallMaterialInput, BuildingCharacterUncheckedUpdateWithoutWallMaterialInput>
  }

  export type BuildingCharacterUpdateManyWithWhereWithoutWallMaterialInput = {
    where: BuildingCharacterScalarWhereInput
    data: XOR<BuildingCharacterUpdateManyMutationInput, BuildingCharacterUncheckedUpdateManyWithoutWallMaterialInput>
  }

  export type BuildingCharacterCreateWithoutOverlapsInput = {
    building_year: string
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
    BuildingCondition?: BuildingConditionCreateNestedOneWithoutBuildingCharacterInput
    BuildingSeria?: BuildingSeriaCreateNestedOneWithoutBuildingCharacterInput
    WallMaterial?: WallMaterialCreateNestedOneWithoutBuildingCharacterInput
    WaterSupply?: WaterSupplyCreateNestedOneWithoutBuildingCharacterInput
    HeatingSystem?: HeatingSystemCreateNestedOneWithoutBuildingCharacterInput
    Parking?: ParkingCreateNestedOneWithoutBuildingCharacterInput
  }

  export type BuildingCharacterUncheckedCreateWithoutOverlapsInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterCreateOrConnectWithoutOverlapsInput = {
    where: BuildingCharacterWhereUniqueInput
    create: XOR<BuildingCharacterCreateWithoutOverlapsInput, BuildingCharacterUncheckedCreateWithoutOverlapsInput>
  }

  export type BuildingCharacterCreateManyOverlapsInputEnvelope = {
    data: BuildingCharacterCreateManyOverlapsInput | BuildingCharacterCreateManyOverlapsInput[]
    skipDuplicates?: boolean
  }

  export type BuildingCharacterUpsertWithWhereUniqueWithoutOverlapsInput = {
    where: BuildingCharacterWhereUniqueInput
    update: XOR<BuildingCharacterUpdateWithoutOverlapsInput, BuildingCharacterUncheckedUpdateWithoutOverlapsInput>
    create: XOR<BuildingCharacterCreateWithoutOverlapsInput, BuildingCharacterUncheckedCreateWithoutOverlapsInput>
  }

  export type BuildingCharacterUpdateWithWhereUniqueWithoutOverlapsInput = {
    where: BuildingCharacterWhereUniqueInput
    data: XOR<BuildingCharacterUpdateWithoutOverlapsInput, BuildingCharacterUncheckedUpdateWithoutOverlapsInput>
  }

  export type BuildingCharacterUpdateManyWithWhereWithoutOverlapsInput = {
    where: BuildingCharacterScalarWhereInput
    data: XOR<BuildingCharacterUpdateManyMutationInput, BuildingCharacterUncheckedUpdateManyWithoutOverlapsInput>
  }

  export type BuildingCharacterCreateWithoutWaterSupplyInput = {
    building_year: string
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
    BuildingCondition?: BuildingConditionCreateNestedOneWithoutBuildingCharacterInput
    BuildingSeria?: BuildingSeriaCreateNestedOneWithoutBuildingCharacterInput
    WallMaterial?: WallMaterialCreateNestedOneWithoutBuildingCharacterInput
    Overlaps?: OverlapsCreateNestedOneWithoutBuildingCharacterInput
    HeatingSystem?: HeatingSystemCreateNestedOneWithoutBuildingCharacterInput
    Parking?: ParkingCreateNestedOneWithoutBuildingCharacterInput
  }

  export type BuildingCharacterUncheckedCreateWithoutWaterSupplyInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterCreateOrConnectWithoutWaterSupplyInput = {
    where: BuildingCharacterWhereUniqueInput
    create: XOR<BuildingCharacterCreateWithoutWaterSupplyInput, BuildingCharacterUncheckedCreateWithoutWaterSupplyInput>
  }

  export type BuildingCharacterCreateManyWaterSupplyInputEnvelope = {
    data: BuildingCharacterCreateManyWaterSupplyInput | BuildingCharacterCreateManyWaterSupplyInput[]
    skipDuplicates?: boolean
  }

  export type BuildingCharacterUpsertWithWhereUniqueWithoutWaterSupplyInput = {
    where: BuildingCharacterWhereUniqueInput
    update: XOR<BuildingCharacterUpdateWithoutWaterSupplyInput, BuildingCharacterUncheckedUpdateWithoutWaterSupplyInput>
    create: XOR<BuildingCharacterCreateWithoutWaterSupplyInput, BuildingCharacterUncheckedCreateWithoutWaterSupplyInput>
  }

  export type BuildingCharacterUpdateWithWhereUniqueWithoutWaterSupplyInput = {
    where: BuildingCharacterWhereUniqueInput
    data: XOR<BuildingCharacterUpdateWithoutWaterSupplyInput, BuildingCharacterUncheckedUpdateWithoutWaterSupplyInput>
  }

  export type BuildingCharacterUpdateManyWithWhereWithoutWaterSupplyInput = {
    where: BuildingCharacterScalarWhereInput
    data: XOR<BuildingCharacterUpdateManyMutationInput, BuildingCharacterUncheckedUpdateManyWithoutWaterSupplyInput>
  }

  export type BuildingCharacterCreateWithoutHeatingSystemInput = {
    building_year: string
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
    BuildingCondition?: BuildingConditionCreateNestedOneWithoutBuildingCharacterInput
    BuildingSeria?: BuildingSeriaCreateNestedOneWithoutBuildingCharacterInput
    WallMaterial?: WallMaterialCreateNestedOneWithoutBuildingCharacterInput
    Overlaps?: OverlapsCreateNestedOneWithoutBuildingCharacterInput
    WaterSupply?: WaterSupplyCreateNestedOneWithoutBuildingCharacterInput
    Parking?: ParkingCreateNestedOneWithoutBuildingCharacterInput
  }

  export type BuildingCharacterUncheckedCreateWithoutHeatingSystemInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterCreateOrConnectWithoutHeatingSystemInput = {
    where: BuildingCharacterWhereUniqueInput
    create: XOR<BuildingCharacterCreateWithoutHeatingSystemInput, BuildingCharacterUncheckedCreateWithoutHeatingSystemInput>
  }

  export type BuildingCharacterCreateManyHeatingSystemInputEnvelope = {
    data: BuildingCharacterCreateManyHeatingSystemInput | BuildingCharacterCreateManyHeatingSystemInput[]
    skipDuplicates?: boolean
  }

  export type BuildingCharacterUpsertWithWhereUniqueWithoutHeatingSystemInput = {
    where: BuildingCharacterWhereUniqueInput
    update: XOR<BuildingCharacterUpdateWithoutHeatingSystemInput, BuildingCharacterUncheckedUpdateWithoutHeatingSystemInput>
    create: XOR<BuildingCharacterCreateWithoutHeatingSystemInput, BuildingCharacterUncheckedCreateWithoutHeatingSystemInput>
  }

  export type BuildingCharacterUpdateWithWhereUniqueWithoutHeatingSystemInput = {
    where: BuildingCharacterWhereUniqueInput
    data: XOR<BuildingCharacterUpdateWithoutHeatingSystemInput, BuildingCharacterUncheckedUpdateWithoutHeatingSystemInput>
  }

  export type BuildingCharacterUpdateManyWithWhereWithoutHeatingSystemInput = {
    where: BuildingCharacterScalarWhereInput
    data: XOR<BuildingCharacterUpdateManyMutationInput, BuildingCharacterUncheckedUpdateManyWithoutHeatingSystemInput>
  }

  export type BuildingCharacterCreateWithoutParkingInput = {
    building_year: string
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
    BuildingCondition?: BuildingConditionCreateNestedOneWithoutBuildingCharacterInput
    BuildingSeria?: BuildingSeriaCreateNestedOneWithoutBuildingCharacterInput
    WallMaterial?: WallMaterialCreateNestedOneWithoutBuildingCharacterInput
    Overlaps?: OverlapsCreateNestedOneWithoutBuildingCharacterInput
    WaterSupply?: WaterSupplyCreateNestedOneWithoutBuildingCharacterInput
    HeatingSystem?: HeatingSystemCreateNestedOneWithoutBuildingCharacterInput
  }

  export type BuildingCharacterUncheckedCreateWithoutParkingInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
  }

  export type BuildingCharacterCreateOrConnectWithoutParkingInput = {
    where: BuildingCharacterWhereUniqueInput
    create: XOR<BuildingCharacterCreateWithoutParkingInput, BuildingCharacterUncheckedCreateWithoutParkingInput>
  }

  export type BuildingCharacterCreateManyParkingInputEnvelope = {
    data: BuildingCharacterCreateManyParkingInput | BuildingCharacterCreateManyParkingInput[]
    skipDuplicates?: boolean
  }

  export type BuildingCharacterUpsertWithWhereUniqueWithoutParkingInput = {
    where: BuildingCharacterWhereUniqueInput
    update: XOR<BuildingCharacterUpdateWithoutParkingInput, BuildingCharacterUncheckedUpdateWithoutParkingInput>
    create: XOR<BuildingCharacterCreateWithoutParkingInput, BuildingCharacterUncheckedCreateWithoutParkingInput>
  }

  export type BuildingCharacterUpdateWithWhereUniqueWithoutParkingInput = {
    where: BuildingCharacterWhereUniqueInput
    data: XOR<BuildingCharacterUpdateWithoutParkingInput, BuildingCharacterUncheckedUpdateWithoutParkingInput>
  }

  export type BuildingCharacterUpdateManyWithWhereWithoutParkingInput = {
    where: BuildingCharacterScalarWhereInput
    data: XOR<BuildingCharacterUpdateManyMutationInput, BuildingCharacterUncheckedUpdateManyWithoutParkingInput>
  }

  export type BuildingConditionCreateWithoutBuildingCharacterInput = {
    name: string
  }

  export type BuildingConditionUncheckedCreateWithoutBuildingCharacterInput = {
    id?: number
    name: string
  }

  export type BuildingConditionCreateOrConnectWithoutBuildingCharacterInput = {
    where: BuildingConditionWhereUniqueInput
    create: XOR<BuildingConditionCreateWithoutBuildingCharacterInput, BuildingConditionUncheckedCreateWithoutBuildingCharacterInput>
  }

  export type BuildingSeriaCreateWithoutBuildingCharacterInput = {
    name: string
  }

  export type BuildingSeriaUncheckedCreateWithoutBuildingCharacterInput = {
    id?: number
    name: string
  }

  export type BuildingSeriaCreateOrConnectWithoutBuildingCharacterInput = {
    where: BuildingSeriaWhereUniqueInput
    create: XOR<BuildingSeriaCreateWithoutBuildingCharacterInput, BuildingSeriaUncheckedCreateWithoutBuildingCharacterInput>
  }

  export type WallMaterialCreateWithoutBuildingCharacterInput = {
    name: string
  }

  export type WallMaterialUncheckedCreateWithoutBuildingCharacterInput = {
    id?: number
    name: string
  }

  export type WallMaterialCreateOrConnectWithoutBuildingCharacterInput = {
    where: WallMaterialWhereUniqueInput
    create: XOR<WallMaterialCreateWithoutBuildingCharacterInput, WallMaterialUncheckedCreateWithoutBuildingCharacterInput>
  }

  export type OverlapsCreateWithoutBuildingCharacterInput = {
    name: string
  }

  export type OverlapsUncheckedCreateWithoutBuildingCharacterInput = {
    id?: number
    name: string
  }

  export type OverlapsCreateOrConnectWithoutBuildingCharacterInput = {
    where: OverlapsWhereUniqueInput
    create: XOR<OverlapsCreateWithoutBuildingCharacterInput, OverlapsUncheckedCreateWithoutBuildingCharacterInput>
  }

  export type WaterSupplyCreateWithoutBuildingCharacterInput = {
    name: string
  }

  export type WaterSupplyUncheckedCreateWithoutBuildingCharacterInput = {
    id?: number
    name: string
  }

  export type WaterSupplyCreateOrConnectWithoutBuildingCharacterInput = {
    where: WaterSupplyWhereUniqueInput
    create: XOR<WaterSupplyCreateWithoutBuildingCharacterInput, WaterSupplyUncheckedCreateWithoutBuildingCharacterInput>
  }

  export type HeatingSystemCreateWithoutBuildingCharacterInput = {
    name: string
  }

  export type HeatingSystemUncheckedCreateWithoutBuildingCharacterInput = {
    id?: number
    name: string
  }

  export type HeatingSystemCreateOrConnectWithoutBuildingCharacterInput = {
    where: HeatingSystemWhereUniqueInput
    create: XOR<HeatingSystemCreateWithoutBuildingCharacterInput, HeatingSystemUncheckedCreateWithoutBuildingCharacterInput>
  }

  export type ParkingCreateWithoutBuildingCharacterInput = {
    name: string
  }

  export type ParkingUncheckedCreateWithoutBuildingCharacterInput = {
    id?: number
    name: string
  }

  export type ParkingCreateOrConnectWithoutBuildingCharacterInput = {
    where: ParkingWhereUniqueInput
    create: XOR<ParkingCreateWithoutBuildingCharacterInput, ParkingUncheckedCreateWithoutBuildingCharacterInput>
  }

  export type BuildingConditionUpsertWithoutBuildingCharacterInput = {
    update: XOR<BuildingConditionUpdateWithoutBuildingCharacterInput, BuildingConditionUncheckedUpdateWithoutBuildingCharacterInput>
    create: XOR<BuildingConditionCreateWithoutBuildingCharacterInput, BuildingConditionUncheckedCreateWithoutBuildingCharacterInput>
    where?: BuildingConditionWhereInput
  }

  export type BuildingConditionUpdateToOneWithWhereWithoutBuildingCharacterInput = {
    where?: BuildingConditionWhereInput
    data: XOR<BuildingConditionUpdateWithoutBuildingCharacterInput, BuildingConditionUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type BuildingConditionUpdateWithoutBuildingCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingConditionUncheckedUpdateWithoutBuildingCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingSeriaUpsertWithoutBuildingCharacterInput = {
    update: XOR<BuildingSeriaUpdateWithoutBuildingCharacterInput, BuildingSeriaUncheckedUpdateWithoutBuildingCharacterInput>
    create: XOR<BuildingSeriaCreateWithoutBuildingCharacterInput, BuildingSeriaUncheckedCreateWithoutBuildingCharacterInput>
    where?: BuildingSeriaWhereInput
  }

  export type BuildingSeriaUpdateToOneWithWhereWithoutBuildingCharacterInput = {
    where?: BuildingSeriaWhereInput
    data: XOR<BuildingSeriaUpdateWithoutBuildingCharacterInput, BuildingSeriaUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type BuildingSeriaUpdateWithoutBuildingCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingSeriaUncheckedUpdateWithoutBuildingCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WallMaterialUpsertWithoutBuildingCharacterInput = {
    update: XOR<WallMaterialUpdateWithoutBuildingCharacterInput, WallMaterialUncheckedUpdateWithoutBuildingCharacterInput>
    create: XOR<WallMaterialCreateWithoutBuildingCharacterInput, WallMaterialUncheckedCreateWithoutBuildingCharacterInput>
    where?: WallMaterialWhereInput
  }

  export type WallMaterialUpdateToOneWithWhereWithoutBuildingCharacterInput = {
    where?: WallMaterialWhereInput
    data: XOR<WallMaterialUpdateWithoutBuildingCharacterInput, WallMaterialUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type WallMaterialUpdateWithoutBuildingCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WallMaterialUncheckedUpdateWithoutBuildingCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OverlapsUpsertWithoutBuildingCharacterInput = {
    update: XOR<OverlapsUpdateWithoutBuildingCharacterInput, OverlapsUncheckedUpdateWithoutBuildingCharacterInput>
    create: XOR<OverlapsCreateWithoutBuildingCharacterInput, OverlapsUncheckedCreateWithoutBuildingCharacterInput>
    where?: OverlapsWhereInput
  }

  export type OverlapsUpdateToOneWithWhereWithoutBuildingCharacterInput = {
    where?: OverlapsWhereInput
    data: XOR<OverlapsUpdateWithoutBuildingCharacterInput, OverlapsUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type OverlapsUpdateWithoutBuildingCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OverlapsUncheckedUpdateWithoutBuildingCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WaterSupplyUpsertWithoutBuildingCharacterInput = {
    update: XOR<WaterSupplyUpdateWithoutBuildingCharacterInput, WaterSupplyUncheckedUpdateWithoutBuildingCharacterInput>
    create: XOR<WaterSupplyCreateWithoutBuildingCharacterInput, WaterSupplyUncheckedCreateWithoutBuildingCharacterInput>
    where?: WaterSupplyWhereInput
  }

  export type WaterSupplyUpdateToOneWithWhereWithoutBuildingCharacterInput = {
    where?: WaterSupplyWhereInput
    data: XOR<WaterSupplyUpdateWithoutBuildingCharacterInput, WaterSupplyUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type WaterSupplyUpdateWithoutBuildingCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WaterSupplyUncheckedUpdateWithoutBuildingCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HeatingSystemUpsertWithoutBuildingCharacterInput = {
    update: XOR<HeatingSystemUpdateWithoutBuildingCharacterInput, HeatingSystemUncheckedUpdateWithoutBuildingCharacterInput>
    create: XOR<HeatingSystemCreateWithoutBuildingCharacterInput, HeatingSystemUncheckedCreateWithoutBuildingCharacterInput>
    where?: HeatingSystemWhereInput
  }

  export type HeatingSystemUpdateToOneWithWhereWithoutBuildingCharacterInput = {
    where?: HeatingSystemWhereInput
    data: XOR<HeatingSystemUpdateWithoutBuildingCharacterInput, HeatingSystemUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type HeatingSystemUpdateWithoutBuildingCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HeatingSystemUncheckedUpdateWithoutBuildingCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ParkingUpsertWithoutBuildingCharacterInput = {
    update: XOR<ParkingUpdateWithoutBuildingCharacterInput, ParkingUncheckedUpdateWithoutBuildingCharacterInput>
    create: XOR<ParkingCreateWithoutBuildingCharacterInput, ParkingUncheckedCreateWithoutBuildingCharacterInput>
    where?: ParkingWhereInput
  }

  export type ParkingUpdateToOneWithWhereWithoutBuildingCharacterInput = {
    where?: ParkingWhereInput
    data: XOR<ParkingUpdateWithoutBuildingCharacterInput, ParkingUncheckedUpdateWithoutBuildingCharacterInput>
  }

  export type ParkingUpdateWithoutBuildingCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ParkingUncheckedUpdateWithoutBuildingCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyRealtorInput = {
    id?: number
    name: string
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateWithoutRealtorInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutRealtorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutRealtorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyObjectTypeInput = {
    id?: number
    name: string
    realtorId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ResidenceTypeCreateManyObjectTypeInput = {
    id?: number
    name: string
  }

  export type ObjectUpdateWithoutObjectTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutObjectTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutObjectTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ResidenceTypeUpdateWithoutObjectTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUpdateManyWithoutResidenceTypeNestedInput
  }

  export type ResidenceTypeUncheckedUpdateWithoutObjectTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    object?: ObjectUncheckedUpdateManyWithoutResidenceTypeNestedInput
  }

  export type ResidenceTypeUncheckedUpdateManyWithoutObjectTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyResidenceTypeInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateWithoutResidenceTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutResidenceTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutResidenceTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyObjectCategoryInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateWithoutObjectCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutObjectCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutObjectCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyObjectStatusInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateWithoutObjectStatusInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutObjectStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutObjectStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyCurrencyInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateWithoutCurrencyInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyRenovationInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    windowSideId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateWithoutRenovationInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutRenovationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutRenovationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyWindowSideInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    roomTypeId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateWithoutWindowSideInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    RoomType?: RoomTypeUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutWindowSideInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutWindowSideInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectCreateManyRoomTypeInput = {
    id?: number
    name: string
    realtorId?: number | null
    objectTypeId?: number | null
    residenceTypeId?: number | null
    objectCategoryId?: number | null
    objectStatusId?: number | null
    is_studio: boolean
    floor: number
    floors_in_building: number
    total_area: number
    live_area: number
    kitchen_area: number
    rooms_area: number
    price: number
    currencyId?: number | null
    price_per_square: number
    price_type: number
    renovationId?: number | null
    windowSideId?: number | null
    is_apartment: boolean
    is_luxury: boolean
    ceiling_height: number
    combined_bath_count: number
    separate_bath_count: number
    loggia_count: number
    loggia_description: string
    balcony_count: number
    balcony_description: string
    general_description: string
    cadastral_number: number
    document: string
    layout: string
    fotos: string
    online_show: boolean
    video: string
  }

  export type ObjectUpdateWithoutRoomTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
    Realtor?: RealtorUpdateOneWithoutObjectNestedInput
    ObjectType?: ObjectTypeUpdateOneWithoutObjectNestedInput
    ResidenceType?: ResidenceTypeUpdateOneWithoutObjectNestedInput
    ObjectCategory?: ObjectCategoryUpdateOneWithoutObjectNestedInput
    ObjectStatus?: ObjectStatusUpdateOneWithoutObjectNestedInput
    Currency?: CurrencyUpdateOneWithoutObjectNestedInput
    Renovation?: RenovationUpdateOneWithoutObjectNestedInput
    WindowSide?: WindowSideUpdateOneWithoutObjectNestedInput
  }

  export type ObjectUncheckedUpdateWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    realtorId?: NullableIntFieldUpdateOperationsInput | number | null
    objectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    residenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    objectCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    objectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    is_studio?: BoolFieldUpdateOperationsInput | boolean
    floor?: IntFieldUpdateOperationsInput | number
    floors_in_building?: IntFieldUpdateOperationsInput | number
    total_area?: FloatFieldUpdateOperationsInput | number
    live_area?: FloatFieldUpdateOperationsInput | number
    kitchen_area?: FloatFieldUpdateOperationsInput | number
    rooms_area?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_square?: FloatFieldUpdateOperationsInput | number
    price_type?: FloatFieldUpdateOperationsInput | number
    renovationId?: NullableIntFieldUpdateOperationsInput | number | null
    windowSideId?: NullableIntFieldUpdateOperationsInput | number | null
    is_apartment?: BoolFieldUpdateOperationsInput | boolean
    is_luxury?: BoolFieldUpdateOperationsInput | boolean
    ceiling_height?: FloatFieldUpdateOperationsInput | number
    combined_bath_count?: IntFieldUpdateOperationsInput | number
    separate_bath_count?: IntFieldUpdateOperationsInput | number
    loggia_count?: IntFieldUpdateOperationsInput | number
    loggia_description?: StringFieldUpdateOperationsInput | string
    balcony_count?: IntFieldUpdateOperationsInput | number
    balcony_description?: StringFieldUpdateOperationsInput | string
    general_description?: StringFieldUpdateOperationsInput | string
    cadastral_number?: IntFieldUpdateOperationsInput | number
    document?: StringFieldUpdateOperationsInput | string
    layout?: StringFieldUpdateOperationsInput | string
    fotos?: StringFieldUpdateOperationsInput | string
    online_show?: BoolFieldUpdateOperationsInput | boolean
    video?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerRelationCreateManyOwnerShipInput = {
    id?: number
    reasonDeletingId?: number | null
    ownerCooperationId?: number | null
    relationshipTypeId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationUpdateWithoutOwnerShipInput = {
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
    ReasonDeleting?: ReasonDeletingUpdateOneWithoutOwnerRelationNestedInput
    OwnerCooperation?: OwnerCooperationUpdateOneWithoutOwnerRelationNestedInput
    RelationshipType?: RelationshipTypeUpdateOneWithoutOwnerRelationNestedInput
  }

  export type OwnerRelationUncheckedUpdateWithoutOwnerShipInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasonDeletingId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerCooperationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationUncheckedUpdateManyWithoutOwnerShipInput = {
    id?: IntFieldUpdateOperationsInput | number
    reasonDeletingId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerCooperationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationCreateManyReasonDeletingInput = {
    id?: number
    ownerShipId?: number | null
    ownerCooperationId?: number | null
    relationshipTypeId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationUpdateWithoutReasonDeletingInput = {
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
    OwnerShip?: OwnerShipUpdateOneWithoutOwnerRelationNestedInput
    OwnerCooperation?: OwnerCooperationUpdateOneWithoutOwnerRelationNestedInput
    RelationshipType?: RelationshipTypeUpdateOneWithoutOwnerRelationNestedInput
  }

  export type OwnerRelationUncheckedUpdateWithoutReasonDeletingInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerShipId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerCooperationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationUncheckedUpdateManyWithoutReasonDeletingInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerShipId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerCooperationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationCreateManyOwnerCooperationInput = {
    id?: number
    ownerShipId?: number | null
    reasonDeletingId?: number | null
    relationshipTypeId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationUpdateWithoutOwnerCooperationInput = {
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
    OwnerShip?: OwnerShipUpdateOneWithoutOwnerRelationNestedInput
    ReasonDeleting?: ReasonDeletingUpdateOneWithoutOwnerRelationNestedInput
    RelationshipType?: RelationshipTypeUpdateOneWithoutOwnerRelationNestedInput
  }

  export type OwnerRelationUncheckedUpdateWithoutOwnerCooperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerShipId?: NullableIntFieldUpdateOperationsInput | number | null
    reasonDeletingId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationUncheckedUpdateManyWithoutOwnerCooperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerShipId?: NullableIntFieldUpdateOperationsInput | number | null
    reasonDeletingId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationCreateManyRelationshipTypeInput = {
    id?: number
    ownerShipId?: number | null
    reasonDeletingId?: number | null
    ownerCooperationId?: number | null
    commission_amount: number
    commission_comment: string
    deposit_amount: number
    deposit_paid: number
    owner_price_ideal: number
    owner_price_real: number
    owner_price_minimal: number
  }

  export type OwnerRelationUpdateWithoutRelationshipTypeInput = {
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
    OwnerShip?: OwnerShipUpdateOneWithoutOwnerRelationNestedInput
    ReasonDeleting?: ReasonDeletingUpdateOneWithoutOwnerRelationNestedInput
    OwnerCooperation?: OwnerCooperationUpdateOneWithoutOwnerRelationNestedInput
  }

  export type OwnerRelationUncheckedUpdateWithoutRelationshipTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerShipId?: NullableIntFieldUpdateOperationsInput | number | null
    reasonDeletingId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerCooperationId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type OwnerRelationUncheckedUpdateManyWithoutRelationshipTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerShipId?: NullableIntFieldUpdateOperationsInput | number | null
    reasonDeletingId?: NullableIntFieldUpdateOperationsInput | number | null
    ownerCooperationId?: NullableIntFieldUpdateOperationsInput | number | null
    commission_amount?: FloatFieldUpdateOperationsInput | number
    commission_comment?: StringFieldUpdateOperationsInput | string
    deposit_amount?: FloatFieldUpdateOperationsInput | number
    deposit_paid?: FloatFieldUpdateOperationsInput | number
    owner_price_ideal?: FloatFieldUpdateOperationsInput | number
    owner_price_real?: FloatFieldUpdateOperationsInput | number
    owner_price_minimal?: FloatFieldUpdateOperationsInput | number
  }

  export type AddressCreateManyRegionInput = {
    id?: number
    districtId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type DistrictCreateManyRegionInput = {
    id?: number
    name: string
  }

  export type AddressUpdateWithoutRegionInput = {
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
    District?: DistrictUpdateOneWithoutAddressNestedInput
    Area?: AreaUpdateOneWithoutAddressNestedInput
    Mahalla?: MahallaUpdateOneWithoutAddressNestedInput
    Street?: StreetUpdateOneWithoutAddressNestedInput
    Metro?: MetroUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type DistrictUpdateWithoutRegionInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyDistrictInput = {
    id?: number
    regionId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressUpdateWithoutDistrictInput = {
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
    Region?: RegionUpdateOneWithoutAddressNestedInput
    Area?: AreaUpdateOneWithoutAddressNestedInput
    Mahalla?: MahallaUpdateOneWithoutAddressNestedInput
    Street?: StreetUpdateOneWithoutAddressNestedInput
    Metro?: MetroUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyAreaInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressUpdateWithoutAreaInput = {
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
    Region?: RegionUpdateOneWithoutAddressNestedInput
    District?: DistrictUpdateOneWithoutAddressNestedInput
    Mahalla?: MahallaUpdateOneWithoutAddressNestedInput
    Street?: StreetUpdateOneWithoutAddressNestedInput
    Metro?: MetroUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyMahallaInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    areaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressUpdateWithoutMahallaInput = {
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
    Region?: RegionUpdateOneWithoutAddressNestedInput
    District?: DistrictUpdateOneWithoutAddressNestedInput
    Area?: AreaUpdateOneWithoutAddressNestedInput
    Street?: StreetUpdateOneWithoutAddressNestedInput
    Metro?: MetroUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutMahallaInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutMahallaInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyStreetInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    metroId?: number | null
    location_description: string
  }

  export type AddressUpdateWithoutStreetInput = {
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
    Region?: RegionUpdateOneWithoutAddressNestedInput
    District?: DistrictUpdateOneWithoutAddressNestedInput
    Area?: AreaUpdateOneWithoutAddressNestedInput
    Mahalla?: MahallaUpdateOneWithoutAddressNestedInput
    Metro?: MetroUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutStreetInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutStreetInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    metroId?: NullableIntFieldUpdateOperationsInput | number | null
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyMetroInput = {
    id?: number
    regionId?: number | null
    districtId?: number | null
    areaId?: number | null
    mahallaId?: number | null
    streetId?: number | null
    house_number: number
    apartment_number: number
    location: string
    landmark: boolean
    location_description: string
  }

  export type AddressUpdateWithoutMetroInput = {
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
    Region?: RegionUpdateOneWithoutAddressNestedInput
    District?: DistrictUpdateOneWithoutAddressNestedInput
    Area?: AreaUpdateOneWithoutAddressNestedInput
    Mahalla?: MahallaUpdateOneWithoutAddressNestedInput
    Street?: StreetUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutMetroInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutMetroInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    districtId?: NullableIntFieldUpdateOperationsInput | number | null
    areaId?: NullableIntFieldUpdateOperationsInput | number | null
    mahallaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetId?: NullableIntFieldUpdateOperationsInput | number | null
    house_number?: IntFieldUpdateOperationsInput | number
    apartment_number?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    landmark?: BoolFieldUpdateOperationsInput | boolean
    location_description?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingCharacterCreateManyBuildingConditionInput = {
    id?: number
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateWithoutBuildingConditionInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
    BuildingSeria?: BuildingSeriaUpdateOneWithoutBuildingCharacterNestedInput
    WallMaterial?: WallMaterialUpdateOneWithoutBuildingCharacterNestedInput
    Overlaps?: OverlapsUpdateOneWithoutBuildingCharacterNestedInput
    WaterSupply?: WaterSupplyUpdateOneWithoutBuildingCharacterNestedInput
    HeatingSystem?: HeatingSystemUpdateOneWithoutBuildingCharacterNestedInput
    Parking?: ParkingUpdateOneWithoutBuildingCharacterNestedInput
  }

  export type BuildingCharacterUncheckedUpdateWithoutBuildingConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutBuildingConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterCreateManyBuildingSeriaInput = {
    id?: number
    buildingConditionId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateWithoutBuildingSeriaInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
    BuildingCondition?: BuildingConditionUpdateOneWithoutBuildingCharacterNestedInput
    WallMaterial?: WallMaterialUpdateOneWithoutBuildingCharacterNestedInput
    Overlaps?: OverlapsUpdateOneWithoutBuildingCharacterNestedInput
    WaterSupply?: WaterSupplyUpdateOneWithoutBuildingCharacterNestedInput
    HeatingSystem?: HeatingSystemUpdateOneWithoutBuildingCharacterNestedInput
    Parking?: ParkingUpdateOneWithoutBuildingCharacterNestedInput
  }

  export type BuildingCharacterUncheckedUpdateWithoutBuildingSeriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutBuildingSeriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterCreateManyWallMaterialInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateWithoutWallMaterialInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
    BuildingCondition?: BuildingConditionUpdateOneWithoutBuildingCharacterNestedInput
    BuildingSeria?: BuildingSeriaUpdateOneWithoutBuildingCharacterNestedInput
    Overlaps?: OverlapsUpdateOneWithoutBuildingCharacterNestedInput
    WaterSupply?: WaterSupplyUpdateOneWithoutBuildingCharacterNestedInput
    HeatingSystem?: HeatingSystemUpdateOneWithoutBuildingCharacterNestedInput
    Parking?: ParkingUpdateOneWithoutBuildingCharacterNestedInput
  }

  export type BuildingCharacterUncheckedUpdateWithoutWallMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutWallMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterCreateManyOverlapsInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateWithoutOverlapsInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
    BuildingCondition?: BuildingConditionUpdateOneWithoutBuildingCharacterNestedInput
    BuildingSeria?: BuildingSeriaUpdateOneWithoutBuildingCharacterNestedInput
    WallMaterial?: WallMaterialUpdateOneWithoutBuildingCharacterNestedInput
    WaterSupply?: WaterSupplyUpdateOneWithoutBuildingCharacterNestedInput
    HeatingSystem?: HeatingSystemUpdateOneWithoutBuildingCharacterNestedInput
    Parking?: ParkingUpdateOneWithoutBuildingCharacterNestedInput
  }

  export type BuildingCharacterUncheckedUpdateWithoutOverlapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutOverlapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterCreateManyWaterSupplyInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateWithoutWaterSupplyInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
    BuildingCondition?: BuildingConditionUpdateOneWithoutBuildingCharacterNestedInput
    BuildingSeria?: BuildingSeriaUpdateOneWithoutBuildingCharacterNestedInput
    WallMaterial?: WallMaterialUpdateOneWithoutBuildingCharacterNestedInput
    Overlaps?: OverlapsUpdateOneWithoutBuildingCharacterNestedInput
    HeatingSystem?: HeatingSystemUpdateOneWithoutBuildingCharacterNestedInput
    Parking?: ParkingUpdateOneWithoutBuildingCharacterNestedInput
  }

  export type BuildingCharacterUncheckedUpdateWithoutWaterSupplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutWaterSupplyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterCreateManyHeatingSystemInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    parkingId?: number | null
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateWithoutHeatingSystemInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
    BuildingCondition?: BuildingConditionUpdateOneWithoutBuildingCharacterNestedInput
    BuildingSeria?: BuildingSeriaUpdateOneWithoutBuildingCharacterNestedInput
    WallMaterial?: WallMaterialUpdateOneWithoutBuildingCharacterNestedInput
    Overlaps?: OverlapsUpdateOneWithoutBuildingCharacterNestedInput
    WaterSupply?: WaterSupplyUpdateOneWithoutBuildingCharacterNestedInput
    Parking?: ParkingUpdateOneWithoutBuildingCharacterNestedInput
  }

  export type BuildingCharacterUncheckedUpdateWithoutHeatingSystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutHeatingSystemInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    parkingId?: NullableIntFieldUpdateOperationsInput | number | null
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterCreateManyParkingInput = {
    id?: number
    buildingConditionId?: number | null
    buildingSeriaId?: number | null
    building_year: string
    wallMaterialId?: number | null
    overlapsId?: number | null
    waterSupplyId?: number | null
    heatingSystemId?: number | null
    is_gas: boolean
    is_electric: boolean
    passenger_elevators_count: number
    freight_elevators_count: number
    is_building_security: boolean
    is_demolition_planned: boolean
  }

  export type BuildingCharacterUpdateWithoutParkingInput = {
    building_year?: StringFieldUpdateOperationsInput | string
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
    BuildingCondition?: BuildingConditionUpdateOneWithoutBuildingCharacterNestedInput
    BuildingSeria?: BuildingSeriaUpdateOneWithoutBuildingCharacterNestedInput
    WallMaterial?: WallMaterialUpdateOneWithoutBuildingCharacterNestedInput
    Overlaps?: OverlapsUpdateOneWithoutBuildingCharacterNestedInput
    WaterSupply?: WaterSupplyUpdateOneWithoutBuildingCharacterNestedInput
    HeatingSystem?: HeatingSystemUpdateOneWithoutBuildingCharacterNestedInput
  }

  export type BuildingCharacterUncheckedUpdateWithoutParkingInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuildingCharacterUncheckedUpdateManyWithoutParkingInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildingConditionId?: NullableIntFieldUpdateOperationsInput | number | null
    buildingSeriaId?: NullableIntFieldUpdateOperationsInput | number | null
    building_year?: StringFieldUpdateOperationsInput | string
    wallMaterialId?: NullableIntFieldUpdateOperationsInput | number | null
    overlapsId?: NullableIntFieldUpdateOperationsInput | number | null
    waterSupplyId?: NullableIntFieldUpdateOperationsInput | number | null
    heatingSystemId?: NullableIntFieldUpdateOperationsInput | number | null
    is_gas?: BoolFieldUpdateOperationsInput | boolean
    is_electric?: BoolFieldUpdateOperationsInput | boolean
    passenger_elevators_count?: IntFieldUpdateOperationsInput | number
    freight_elevators_count?: IntFieldUpdateOperationsInput | number
    is_building_security?: BoolFieldUpdateOperationsInput | boolean
    is_demolition_planned?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RealtorCountOutputTypeDefaultArgs instead
     */
    export type RealtorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealtorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectTypeCountOutputTypeDefaultArgs instead
     */
    export type ObjectTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResidenceTypeCountOutputTypeDefaultArgs instead
     */
    export type ResidenceTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResidenceTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectCategoryCountOutputTypeDefaultArgs instead
     */
    export type ObjectCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectStatusCountOutputTypeDefaultArgs instead
     */
    export type ObjectStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CurrencyCountOutputTypeDefaultArgs instead
     */
    export type CurrencyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CurrencyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RenovationCountOutputTypeDefaultArgs instead
     */
    export type RenovationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RenovationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WindowSideCountOutputTypeDefaultArgs instead
     */
    export type WindowSideCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WindowSideCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomTypeCountOutputTypeDefaultArgs instead
     */
    export type RoomTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerShipCountOutputTypeDefaultArgs instead
     */
    export type OwnerShipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerShipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReasonDeletingCountOutputTypeDefaultArgs instead
     */
    export type ReasonDeletingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReasonDeletingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerCooperationCountOutputTypeDefaultArgs instead
     */
    export type OwnerCooperationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerCooperationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationshipTypeCountOutputTypeDefaultArgs instead
     */
    export type RelationshipTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationshipTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionCountOutputTypeDefaultArgs instead
     */
    export type RegionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictCountOutputTypeDefaultArgs instead
     */
    export type DistrictCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaCountOutputTypeDefaultArgs instead
     */
    export type AreaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MahallaCountOutputTypeDefaultArgs instead
     */
    export type MahallaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MahallaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StreetCountOutputTypeDefaultArgs instead
     */
    export type StreetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StreetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MetroCountOutputTypeDefaultArgs instead
     */
    export type MetroCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MetroCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingConditionCountOutputTypeDefaultArgs instead
     */
    export type BuildingConditionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingConditionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingSeriaCountOutputTypeDefaultArgs instead
     */
    export type BuildingSeriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingSeriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WallMaterialCountOutputTypeDefaultArgs instead
     */
    export type WallMaterialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WallMaterialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OverlapsCountOutputTypeDefaultArgs instead
     */
    export type OverlapsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OverlapsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaterSupplyCountOutputTypeDefaultArgs instead
     */
    export type WaterSupplyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaterSupplyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HeatingSystemCountOutputTypeDefaultArgs instead
     */
    export type HeatingSystemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HeatingSystemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParkingCountOutputTypeDefaultArgs instead
     */
    export type ParkingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParkingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealtorDefaultArgs instead
     */
    export type RealtorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealtorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectTypeDefaultArgs instead
     */
    export type ObjectTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResidenceTypeDefaultArgs instead
     */
    export type ResidenceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResidenceTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectCategoryDefaultArgs instead
     */
    export type ObjectCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectStatusDefaultArgs instead
     */
    export type ObjectStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CurrencyDefaultArgs instead
     */
    export type CurrencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CurrencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RenovationDefaultArgs instead
     */
    export type RenovationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RenovationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WindowSideDefaultArgs instead
     */
    export type WindowSideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WindowSideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomTypeDefaultArgs instead
     */
    export type RoomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectDefaultArgs instead
     */
    export type ObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerShipDefaultArgs instead
     */
    export type OwnerShipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerShipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReasonDeletingDefaultArgs instead
     */
    export type ReasonDeletingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReasonDeletingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerCooperationDefaultArgs instead
     */
    export type OwnerCooperationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerCooperationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationshipTypeDefaultArgs instead
     */
    export type RelationshipTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationshipTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerRelationDefaultArgs instead
     */
    export type OwnerRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerRelationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionDefaultArgs instead
     */
    export type RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictDefaultArgs instead
     */
    export type DistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaDefaultArgs instead
     */
    export type AreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MahallaDefaultArgs instead
     */
    export type MahallaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MahallaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StreetDefaultArgs instead
     */
    export type StreetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StreetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MetroDefaultArgs instead
     */
    export type MetroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MetroDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressDefaultArgs instead
     */
    export type AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingConditionDefaultArgs instead
     */
    export type BuildingConditionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingConditionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingSeriaDefaultArgs instead
     */
    export type BuildingSeriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingSeriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WallMaterialDefaultArgs instead
     */
    export type WallMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WallMaterialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OverlapsDefaultArgs instead
     */
    export type OverlapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OverlapsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaterSupplyDefaultArgs instead
     */
    export type WaterSupplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaterSupplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HeatingSystemDefaultArgs instead
     */
    export type HeatingSystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HeatingSystemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParkingDefaultArgs instead
     */
    export type ParkingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParkingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingCharacterDefaultArgs instead
     */
    export type BuildingCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingCharacterDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}